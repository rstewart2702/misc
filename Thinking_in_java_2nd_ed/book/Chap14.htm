<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/21/2001
Translation Time:10:39:26
Translation Platform:Win32
Number of Output files:23
This File:Chap14.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>14: Multiple Threads</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevHist.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 12</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap13.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap15.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_16"></A><A NAME="_Toc375545471"></A><A NAME="_Toc477690734"></A><A NAME="_Toc481064845"></A><A NAME="Heading480"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
14: Multiple Threads</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=4><backtalk:display ID=TIJ3_CHAPTER14_I0>
Objects
provide a way to divide a program into independent sections. Often, you also
need to turn a program into separate, independently running
subtasks.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of these independent subtasks is
called a <A NAME="Index1890"></A><A NAME="Index1891"></A><I>thread</I>, and you
program as if each thread runs by itself and has the CPU to itself. Some
underlying mechanism is actually dividing up the CPU time for you, but in
general, you don&#8217;t have to think about it, which makes programming with
multiple threads a much easier task.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I0' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I1>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <A NAME="Index1892"></A><I>process</I>
is a self-contained running program with its own address space. A
<A NAME="Index1893"></A><I>multitasking</I> operating system is capable of
running more than one process (program) at a time, while making it look like
each one is chugging along on its own, by periodically providing CPU cycles to
each process. A thread is a single sequential flow of control within a process.
A single process can thus have multiple concurrently executing threads.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I1' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I2>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are many possible uses for
multithreading, but in general, you&#8217;ll have some part of your program tied
to a particular event or resource, and you don&#8217;t want to hang up the rest
of your program because of that. So you create a thread associated with that
event or resource and let it run independently of the main program. A good
example is a &#8220;quit&#8221; button&#8212;you don&#8217;t want to be forced
to poll the quit button in every piece of code you write in your program and yet
you want the quit button to be responsive, as if you <I>were</I> checking it
regularly. In fact, one of the most immediately compelling reasons for
multithreading is to produce a responsive user interface.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I2' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I3>
</FONT><A NAME="_Toc375545472"></A><A NAME="_Toc481064846"></A><BR></P></DIV>
<A NAME="Heading481"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Responsive user interfaces<BR><A NAME="Index1894"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a starting point, consider a program
that performs some CPU-intensive operation and thus ends up ignoring user input
and being unresponsive. This one, a combined applet/application, will simply
display the result of a running counter:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Counter1.java</font>
<font color=#009900>// A non-responsive user interface.</font>
<font color=#009900>// &lt;applet code=Counter1 width=300 height=100&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Counter1 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>private</font> JButton
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    onOff = <font color=#0000ff>new</font> JButton(<font color=#004488>"Toggle"</font>);
  <font color=#0000ff>private</font> JTextField t = <font color=#0000ff>new</font> JTextField(10);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> runFlag = <font color=#0000ff>true</font>;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    cp.add(t);
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    cp.add(start);
    onOff.addActionListener(<font color=#0000ff>new</font> OnOffL());
    cp.add(onOff);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> go() {
    <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
      <font color=#0000ff>try</font> {
        Thread.sleep(100);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
      <font color=#0000ff>if</font> (runFlag)
        t.setText(Integer.toString(count++));
    }
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      go();
    }
  }
  <font color=#0000ff>class</font> OnOffL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Counter1(), 300, 100);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, the Swing and applet code
should be reasonably familiar from Chapter 13. The <B>go(&#160;)</B> method is
where the program stays busy: it puts the current value of <B>count</B> into
the<B> JTextField t</B>, then increments <B>count</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I3' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I4>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Part of the infinite loop inside
<B>go(&#160;)</B> is to call <B>sleep(&#160;)</B>.
<A NAME="Index1895"></A><B>sleep(&#160;)</B> must be associated with a
<A NAME="Index1896"></A><B>Thread</B> object, and it turns out that every
application has <I>some</I> thread associated with it. (Indeed, Java is based on
threads and there are always some running along with your application.) So
regardless of whether you&#8217;re explicitly using threads, you can produce the
current thread used by your program with <B>Thread </B>and the static
<B>sleep(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I4' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I5>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>sleep(&#160;)</B> can throw
an <A NAME="Index1897"></A><B>InterruptedException</B>, although throwing such
an exception is considered a hostile way to break from a thread and should be
discouraged. (Once again, exceptions are for exceptional conditions, not normal
flow of control.) Interrupting a sleeping thread is included to support a future
language feature. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I5' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I6>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the <B>start</B> button is pressed,
<B>go(&#160;)</B> is invoked. On examining <B>go(&#160;)</B>, you might naively
think (as I did) that it should allow multithreading because it goes to sleep.
That is, while the method is asleep, it seems like the CPU could be busy
monitoring other button presses. But it turns out that the real problem is that
<B>go(&#160;)</B> never returns, since it&#8217;s in an infinite loop, and this
means that <B>actionPerformed(&#160;)</B> never returns. Since you&#8217;re
stuck inside <B>actionPerformed(&#160;)</B> for the first keypress, the program
can&#8217;t handle any other events. (To get out, you must somehow kill the
process; the easiest way to do this is to press Control-C in the console window,
if you started it from the console. If you start it via the browser, you have to
kill the browser window.) 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I6' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I7>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic problem here is that
<B>go(&#160;)</B> needs to continue performing its operations, and at the same
time it needs to return so that <B>actionPerformed(&#160;)</B> can complete and
the user interface can continue responding to the user. But in a conventional
method like <B>go(&#160;)</B> it cannot continue <I>and</I> at the same time
return control to the rest of the program. This sounds like an impossible thing
to accomplish, as if the CPU must be in two places at once, but this is
precisely the illusion that threading provides. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I7' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I8>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The thread model (and its programming
support in Java) is a programming convenience to simplify juggling several
operations at the same time within a single program. With threads, the CPU will
pop around and give each thread some of its time. Each thread has the
consciousness of constantly having the CPU to itself, but the CPU&#8217;s time
is actually sliced between all the threads. The exception to this is if your
program is running on multiple CPUs. But one of the great things about threading
is that you are abstracted away from this layer, so your code does not need to
know whether it is actually running on a single CPU or many. Thus, threads are a
way to create transparently scalable programs.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I8' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I9>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1898"></A><A NAME="Index1899"></A><FONT FACE="Georgia">Threading
reduces computing efficiency somewhat, but the net improvement in program
design, resource balancing, and user convenience is often quite valuable. Of
course, if you have more than one CPU, then the operating system can dedicate
each CPU to a set of threads or even a single thread and the whole program can
run much faster. Multitasking and multithreading tend to be the most reasonable
ways to utilize multiprocessor systems.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I9' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I10>
</FONT><A NAME="_Toc375545473"></A><A NAME="_Toc481064847"></A><BR></P></DIV>
<A NAME="Heading482"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Inheriting from Thread</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The simplest way to create a thread is to
inherit from class <B>Thread</B>, which has all the wiring necessary to create
and run threads. The most important method for <B>Thread</B> is
<B>run(&#160;)</B>, which you must override to make the thread do your bidding.
Thus, <B>run(&#160;)</B> is the code that will be executed
&#8220;simultaneously&#8221; with the other threads in a program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I10' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I11>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example creates any number
of threads that it keeps track of by assigning each thread a unique number,
generated with a <B>static</B> variable. The
<A NAME="Index1900"></A><B>Thread</B>&#8217;s <B>run(&#160;)</B> method is
overridden to count down each time it passes through its loop and to finish when
the count is zero (at the point when <B>run(&#160;)</B> returns, the thread is
terminated).</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:SimpleThread.java</font>
<font color=#009900>// Very simple Threading example.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleThread <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> countDown = 5;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> threadCount = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> threadNumber = ++threadCount;
  <font color=#0000ff>public</font> SimpleThread() {
    System.out.println(<font color=#004488>"Making "</font> + threadNumber);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      System.out.println(<font color=#004488>"Thread "</font> + 
        threadNumber + <font color=#004488>"("</font> + countDown + <font color=#004488>")"</font>);
      <font color=#0000ff>if</font>(--countDown == 0) <font color=#0000ff>return</font>;
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      <font color=#0000ff>new</font> SimpleThread().start();
    System.out.println(<font color=#004488>"All Threads Started"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>run(&#160;)</B> method virtually
always has some kind of loop that continues until the thread is no longer
necessary, so you must establish the condition on which to break out of this
loop (or, in the case above, simply <B>return</B> from <B>run(&#160;)</B>).
Often, <B>run(&#160;)</B> is cast in the form of an infinite loop, which means
that, barring some external factor that causes <B>run(&#160;)</B> to terminate,
it will continue forever. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I11' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I12>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;) </B>you can see a
number of threads being created and run. The <B>start(&#160;) </B>method in the
<A NAME="Index1901"></A><B>Thread</B> class performs special initialization for
the thread and then calls <B>run(&#160;)</B>. So the steps are: the constructor
is called to build the object, then <B>start(&#160;)</B> configures the thread
and calls <B>run(&#160;)</B>. If you don&#8217;t call <B>start(&#160;)</B>
(which you can do in the constructor, if that&#8217;s appropriate) the thread
will never be started. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I12' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I13>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for one run of this program
(it will be different from one run to another) is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Making 1
Making 2
Making 3
Making 4
Making 5
Thread 1(5)
Thread 1(4)
Thread 1(3)
Thread 1(2)
Thread 2(5)
Thread 2(4)
Thread 2(3)
Thread 2(2)
Thread 2(1)
Thread 1(1)
All Threads Started
Thread 3(5)
Thread 4(5)
Thread 4(4)
Thread 4(3)
Thread 4(2)
Thread 4(1)
Thread 5(5)
Thread 5(4)
Thread 5(3)
Thread 5(2)
Thread 5(1)
Thread 3(4)
Thread 3(3)
Thread 3(2)
Thread 3(1)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that nowhere in this
example is <B>sleep(&#160;)</B> called, and yet the output indicates that each
thread gets a portion of the CPU&#8217;s time in which to execute. This shows
that <B>sleep(&#160;)</B>, while it relies on the existence of a thread in order
to execute, is not involved with either enabling or disabling threading.
It&#8217;s simply another method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I13' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I14>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also see that the
<A NAME="Index1902"></A>threads are not run in the order that they&#8217;re
created. In fact, the order that the CPU attends to an existing set of threads
is indeterminate, unless you go in and adjust the priorities using
<B>Thread</B>&#8217;s <B>setPriority(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I14' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I15>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>main(&#160;)</B> creates the
<B>Thread</B> objects it isn&#8217;t capturing the references for any of them.
An ordinary object would be fair game for garbage collection, but not a
<B>Thread</B>. Each <B>Thread</B> &#8220;registers&#8221; itself so there is
actually a reference to it someplace and the garbage collector can&#8217;t clean
it up.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I15' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I16>
</FONT><A NAME="_Toc375545474"></A><A NAME="_Toc481064848"></A><BR></P></DIV>
<A NAME="Heading483"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Threading for a responsive interface<BR><A NAME="Index1903"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now it&#8217;s possible to solve the
problem in <B>Counter1.java </B>with a thread. The trick is to place the
subtask&#8212;that is, the loop that&#8217;s inside
<B>go(&#160;)</B>&#8212;inside the <B>run(&#160;)</B> method of a thread. When
the user presses the <B>start</B> button, the thread is started, but then the
<I>creation</I> of the thread completes, so even though the thread is running,
the main job of the program (watching for and responding to user-interface
events) can continue. Here&#8217;s the solution:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Counter2.java</font>
<font color=#009900>// A responsive user interface with threads.</font>
<font color=#009900>// &lt;applet code=Counter2 width=300 height=100&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Counter2 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> <font color=#0000ff>class</font> SeparateSubTask <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> runFlag = <font color=#0000ff>true</font>;
    SeparateSubTask() { start(); }
    <font color=#0000ff>void</font> invertFlag() { runFlag = !runFlag; }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
       <font color=#0000ff>try</font> {
        sleep(100);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
       <font color=#0000ff>if</font>(runFlag) 
         t.setText(Integer.toString(count++));
      }
    }
  } 
  <font color=#0000ff>private</font> SeparateSubTask sp = <font color=#0000ff>null</font>;
  <font color=#0000ff>private</font> JTextField t = <font color=#0000ff>new</font> JTextField(10);
  <font color=#0000ff>private</font> JButton 
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    onOff = <font color=#0000ff>new</font> JButton(<font color=#004488>"Toggle"</font>);
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(sp == <font color=#0000ff>null</font>)
        sp = <font color=#0000ff>new</font> SeparateSubTask();
    }
  }
  <font color=#0000ff>class</font> OnOffL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(sp != <font color=#0000ff>null</font>)
        sp.invertFlag();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    cp.add(t);
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    cp.add(start);
    onOff.addActionListener(<font color=#0000ff>new</font> OnOffL());
    cp.add(onOff);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Counter2 (), 300, 100);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Counter2</B> is a straightforward
program, whose only job is to set up and maintain the user interface. But now,
when the user presses the <B>start</B> button, the event-handling code does not
call a method. Instead a thread of class <B>SeparateSubTask</B> is created, and
then the <B>Counter2</B> event loop continues. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I16' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I17>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The class <B>SeparateSubTask</B> is a
simple extension of <B>Thread</B> with a constructor that runs the thread by
calling <B>start(&#160;)</B>, and a <B>run(&#160;)</B> that essentially contains
the &#8220;<B>go(&#160;)</B>&#8221; code from <B>Counter1.java</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I17' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I18>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>SeparateSubTask</B> is an
inner class, it can directly access the <B>JTextField t </B>in <B>Counter2</B>;
you can see this happening inside <B>run(&#160;)</B>. The <B>t</B> field in the
outer class is <B>private</B> since <B>SeparateSubTask</B> can access it without
getting any special permission&#8212;and it&#8217;s always good to make fields
&#8220;as <B>private</B> as possible&#8221; so they cannot be accidentally
changed by forces outside your class.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I18' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I19>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press the <B>onOff</B> button it
toggles the <B>runFlag</B> inside the <B>SeparateSubTask</B> object. That thread
(when it looks at the flag) can then start and stop itself. Pressing the
<B>onOff</B> button produces an apparently instant response. Of course, the
response isn&#8217;t really instant, not like that of a system that&#8217;s
driven by interrupts. The counter stops only when the thread has the CPU and
notices that the flag has changed.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I19' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I20>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the
<A NAME="Index1904"></A><A NAME="Index1905"></A>inner class
<B>SeparateSubTask</B> is <B>private</B>, which means that its fields and
methods can be given default access (except for <B>run(&#160;)</B>, which must
be <B>public</B> since it is <B>public</B> in the base class). The <B>private
</B>inner class is not accessible to anyone but <B>Counter2</B>, and the two
classes are tightly coupled. Anytime you notice classes that appear to have high
coupling with each other, consider the coding and maintenance improvements you
might get by using inner classes.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I20' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I21>
</FONT><A NAME="_Toc375545475"></A><A NAME="_Toc481064849"></A><BR></P></DIV>
<A NAME="Heading484"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Combining the thread <BR>with the main class<BR><A NAME="Index1906"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the example above you can see that the
thread class is separate from the program&#8217;s main class. This makes a lot
of sense and is relatively easy to understand. There is, however, an alternate
form that you will often see used that is not so clear but is usually more
concise (which probably accounts for its popularity). This form combines the
main program class with the thread class by making the main program class a
thread. Since for a GUI program the main program class must be inherited from
either <B>Frame</B> or <B>Applet</B>, an interface must be used to paste on the
additional functionality. This interface is called <B>Runnable</B>, and it
contains the same basic method that <B>Thread</B> does. In fact, <B>Thread</B>
also implements <B>Runnable</B>, which specifies only that there be a
<B>run(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I21' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I22>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <I>use</I> of the combined
program/thread is not quite so obvious. When you start the program, you create
an object that&#8217;s <B>Runnable</B>, but you don&#8217;t start the thread.
This must be done explicitly. You can see this in the following program, which
reproduces the functionality of <B>Counter2</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Counter3.java</font>
<font color=#009900>// Using the Runnable interface to turn the </font>
<font color=#009900>// main class into a thread.</font>
<font color=#009900>// &lt;applet code=Counter3 width=300 height=100&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Counter3 
    <font color=#0000ff>extends</font> JApplet <font color=#0000ff>implements</font> Runnable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> runFlag = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> Thread selfThread = <font color=#0000ff>null</font>;
  <font color=#0000ff>private</font> JButton 
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    onOff = <font color=#0000ff>new</font> JButton(<font color=#004488>"Toggle"</font>);
  <font color=#0000ff>private</font> JTextField t = <font color=#0000ff>new</font> JTextField(10);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
      <font color=#0000ff>try</font> {
        selfThread.sleep(100);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
      <font color=#0000ff>if</font>(runFlag) 
        t.setText(Integer.toString(count++));
    }
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(selfThread == <font color=#0000ff>null</font>) {
        selfThread = <font color=#0000ff>new</font> Thread(Counter3.<font color=#0000ff>this</font>);
        selfThread.start();
      }
    }
  }
  <font color=#0000ff>class</font> OnOffL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    cp.add(t);
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    cp.add(start);
    onOff.addActionListener(<font color=#0000ff>new</font> OnOffL());
    cp.add(onOff);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Counter3(), 300, 100);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the <B>run(&#160;)</B> is inside the
class, but it&#8217;s still dormant after <B>init(&#160;)</B> completes. When
you press the <B>start</B> button, the thread is created (if it doesn&#8217;t
already exist) in the somewhat obscure expression:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I22' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I23>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>new</font> Thread(Counter3.<font color=#0000ff>this</font>);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When something has a
<A NAME="Index1907"></A><A NAME="Index1908"></A><A NAME="Index1909"></A><B>Runnable</B>
interface, it simply means that it has a <B>run(&#160;)</B> method, but
there&#8217;s nothing special about that&#8212;it doesn&#8217;t produce any
innate threading abilities, like those of a class inherited from <B>Thread</B>.
So to produce a thread from a <B>Runnable</B> object, you must create a separate
<B>Thread</B> object as shown above, handing the <B>Runnable</B> object to the
special <B>Thread </B>constructor. You can then call <B>start(&#160;)</B> for
that thread: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I23' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I24>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>selfThread.start();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This performs the usual initialization
and then calls <B>run(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I24' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I25>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The convenient aspect about the
<B>Runnable interface</B> is that everything belongs to the same class. If you
need to access something, you simply do it without going through a separate
object. However, as you saw in the previous example, this access is just as easy
using an inner
class</FONT><A NAME="fnB70" HREF="#fn70">[70]</A><FONT FACE="Georgia">.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I25' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I26>
</FONT><A NAME="_Toc375545476"></A><A NAME="_Toc481064850"></A><BR></P></DIV>
<A NAME="Heading485"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making many threads</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the creation of many different
threads. You can&#8217;t do this with the previous example, so you must go back
to having separate classes inherited from <B>Thread</B> to encapsulate the
<B>run(&#160;)</B>. But this is a more general solution and easier to
understand, so while the previous example shows a coding style you&#8217;ll
often see, I can&#8217;t recommend it for most cases because it&#8217;s just a
little bit more confusing and less flexible.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I26' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I27>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example repeats the form of
the examples above with counters and toggle buttons. But now all the information
for a particular counter, including the button and text field, is inside its own
object that is inherited from <B>Thread</B>. All the fields in <B>Ticker</B> are
<B>private</B>, which means that the <B>Ticker</B> implementation can be changed
at will, including the quantity and type of data components to acquire and
display information. When a <B>Ticker</B> object is created, the constructor
adds its visual components to the content pane of the outer
object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Counter4.java</font>
<font color=#009900>// By keeping your thread as a distinct class,</font>
<font color=#009900>// you can have as many threads as you want. </font>
<font color=#009900>// &lt;applet code=Counter4 width=200 height=600&gt;</font>
<font color=#009900>// &lt;param name=size value="12"&gt;&lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Counter4 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> JButton start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> started = <font color=#0000ff>false</font>;
  <font color=#0000ff>private</font> Ticker[] s;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isApplet = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> size = 12;
  <font color=#0000ff>class</font> Ticker <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> JButton b = <font color=#0000ff>new</font> JButton(<font color=#004488>"Toggle"</font>);
    <font color=#0000ff>private</font> JTextField t = <font color=#0000ff>new</font> JTextField(10);
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> runFlag = <font color=#0000ff>true</font>;
    <font color=#0000ff>public</font> Ticker() {
      b.addActionListener(<font color=#0000ff>new</font> ToggleL());
      JPanel p = <font color=#0000ff>new</font> JPanel();
      p.add(t);
      p.add(b);
      <font color=#009900>// Calls JApplet.getContentPane().add():</font>
      getContentPane().add(p); 
    }
    <font color=#0000ff>class</font> ToggleL <font color=#0000ff>implements</font> ActionListener {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
        runFlag = !runFlag;
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
        <font color=#0000ff>if</font> (runFlag)
          t.setText(Integer.toString(count++));
        <font color=#0000ff>try</font> {
          sleep(100);
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
      }
    }
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(!started) {
        started = <font color=#0000ff>true</font>;
        <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
          s[i].start();
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    <font color=#009900>// Get parameter "size" from Web page:</font>
    <font color=#0000ff>if</font> (isApplet) {
      String sz = getParameter(<font color=#004488>"size"</font>);
      <font color=#0000ff>if</font>(sz != <font color=#0000ff>null</font>)
        size = Integer.parseInt(sz);
    }
    s = <font color=#0000ff>new</font> Ticker[size];
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i] = <font color=#0000ff>new</font> Ticker();
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    cp.add(start);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Counter4 applet = <font color=#0000ff>new</font> Counter4();
    <font color=#009900>// This isn't an applet, so set the flag and</font>
    <font color=#009900>// produce the parameter values from args:</font>
    applet.isApplet = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args.length != 0)
      applet.size = Integer.parseInt(args[0]);
    Console.run(applet, 200, applet.size * 50);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Ticker</B> contains not only its
threading equipment but also the way to control and display the thread. You can
create as many threads as you want without explicitly creating the windowing
components. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I27' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I28>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Counter4</B> there&#8217;s an array
of <B>Ticker</B> objects called <B>s</B>. For maximum flexibility, the size of
this array is initialized by reaching out into the Web page using applet
parameters. Here&#8217;s what the size parameter looks like on the page,
embedded inside the applet tag:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;param name=size value=<font color=#004488>"20"</font>&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1910"></A><A NAME="Index1911"></A><B>param</B>,
<A NAME="Index1912"></A><A NAME="Index1913"></A><B>name</B>, and
<A NAME="Index1914"></A><A NAME="Index1915"></A><B>value</B> are all HTML
keywords. <B>name</B> is what you&#8217;ll be referring to in your program, and
<B>value</B> can be any string, not just something that resolves to a number.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I28' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I29>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that the
determination of the size of the array <B>s</B> is done inside
<B>init(&#160;)</B>, and not as part of an inline definition of <B>s</B>. That
is, you <I>cannot</I> say as part of the class definition (outside of any
methods):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> size = Integer.parseInt(getParameter(<font color=#004488>"size"</font>));
Ticker[] s = <font color=#0000ff>new</font> Ticker[size];</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can compile this, but you&#8217;ll
get a strange &#8220;null-pointer exception&#8221; at run-time. It works fine if
you move the <B>getParameter(&#160;) </B>initialization inside of
<B>init(&#160;)</B>. The <A NAME="Index1916"></A>applet framework performs the
necessary startup to grab the parameters before entering <B>init(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I29' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I30>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, this code is set up to be
either an <A NAME="Index1917"></A>applet or an
<A NAME="Index1918"></A>application. When it&#8217;s an application the
<B>size</B> argument is extracted from the command line (or a default value is
provided). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I30' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I31>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the size of the array is
established, new <B>Ticker</B> objects are created; as part of the <B>Ticker</B>
constructor the button and text field for each <B>Ticker </B>is added to the
applet. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I31' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I32>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pressing the <B>start</B> button means
looping through the entire array of <B>Ticker</B>s and calling
<B>start(&#160;)</B> for each one. Remember, <B>start(&#160;)</B> performs
necessary thread initialization and then calls <B>run(&#160;)</B> for that
thread. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I32' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I33>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ToggleL </B>listener simply
inverts the flag in <B>Ticker</B> and when the associated thread next takes note
it can react accordingly. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I33' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I34>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One value of this example is that it
allows you to easily create large sets of independent subtasks and to monitor
their behavior. In this case, you&#8217;ll see that as the number of subtasks
gets larger, your machine will probably show more divergence in the displayed
numbers because of the way that the threads are served.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I34' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I35>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also experiment to discover how
important the <B>sleep(100)</B> is inside <B>Ticker.run(&#160;)</B>. If you
remove the <B>sleep(&#160;)</B>, things will work fine until you press a toggle
button. Then that particular thread has a false <B>runFlag</B> and the
<B>run(&#160;)</B> is just tied up in a tight infinite loop, which appears
difficult to break during multithreading, so the responsiveness and speed of the
program really bogs down.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I35' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I36>
</FONT><A NAME="_Toc375545477"></A><A NAME="_Toc481064851"></A><BR></P></DIV>
<A NAME="Heading486"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Daemon threads<BR><A NAME="Index1919"></A><A NAME="Index1920"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A &#8220;daemon&#8221; thread is one that
is supposed to provide a general service in the background as long as the
program is running, but is not part of the essence of the program. Thus, when
all of the non-daemon threads complete, the program is terminated. Conversely,
if there are any non-daemon threads still running, the program doesn&#8217;t
terminate. (There is, for instance, a thread that runs <B>main(&#160;)</B>.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I36' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I37>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can find out if a thread is a daemon
by calling
<A NAME="Index1921"></A><A NAME="Index1922"></A><B>isDaemon(&#160;)</B>, and you
can turn the &#8220;daemonhood&#8221; of a thread on and off with
<A NAME="Index1923"></A><A NAME="Index1924"></A><B>setDaemon(&#160;)</B>. If a
thread is a daemon, then any threads it creates will automatically be daemons.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I37' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I38>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example demonstrates daemon
threads:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Daemons.java</font>
<font color=#009900>// Daemonic behavior.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Daemon <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SIZE = 10;
  <font color=#0000ff>private</font> Thread[] t = <font color=#0000ff>new</font> Thread[SIZE];
  <font color=#0000ff>public</font> Daemon() { 
    setDaemon(<font color=#0000ff>true</font>);
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; SIZE; i++)
      t[i] = <font color=#0000ff>new</font> DaemonSpawn(i);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; SIZE; i++)
      System.out.println(
        <font color=#004488>"t["</font> + i + <font color=#004488>"].isDaemon() = "</font> 
        + t[i].isDaemon());
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) 
      yield();
  }
}

<font color=#0000ff>class</font> DaemonSpawn <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>public</font> DaemonSpawn(<font color=#0000ff>int</font> i) {
    System.out.println(
      <font color=#004488>"DaemonSpawn "</font> + i + <font color=#004488>" started"</font>);
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) 
      yield();
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Daemons {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    Thread d = <font color=#0000ff>new</font> Daemon();
    System.out.println(
      <font color=#004488>"d.isDaemon() = "</font> + d.isDaemon());
    <font color=#009900>// Allow the daemon threads to</font>
    <font color=#009900>// finish their startup processes:</font>
    System.out.println(<font color=#004488>"Press any key"</font>);
    System.in.read();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Daemon</B> thread sets its daemon
flag to &#8220;true&#8221; and then spawns a bunch of other threads to show that
they are also daemons. Then it goes into an infinite loop that calls
<B>yield(&#160;)</B> to give up control to the other processes. In an earlier
version of this program, the infinite loops would increment <B>int </B>counters,
but this seemed to bring the whole program to a stop. Using <B>yield(&#160;)</B>
makes the program quite peppy.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I38' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I39>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s nothing to keep the program
from terminating once <B>main(&#160;)</B> finishes its job, since there are
nothing but daemon threads running. So that you can see the results of starting
all the daemon threads, <B>System.in</B> is set up to read so the program waits
for a keypress before terminating. Without this you see only some of the results
from the creation of the daemon threads. (Try replacing the <B>read(&#160;)</B>
code with <B>sleep(&#160;)</B> calls of various lengths to see this behavior.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I39' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I40>
</FONT><A NAME="_Toc375545478"></A><A NAME="_Toc481064852"></A><BR></P></DIV>
<A NAME="Heading487"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Sharing limited resources<BR><A NAME="Index1925"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can think of a single-threaded
program as one lonely entity moving around through your problem space and doing
one thing at a time. Because there&#8217;s only one entity, you never have to
think about the problem of two entities trying to use the same resource at the
same time, like two people trying to park in the same space, walk through a door
at the same time, or even talk at the same time.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I40' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I41>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With multithreading, things aren&#8217;t
lonely anymore, but you now have the possibility of two or more threads trying
to use the same limited resource at once. Colliding over a resource must be
prevented or else you&#8217;ll have two threads trying to access the same bank
account at the same time, print to the same printer, or adjust the same valve,
etc.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I41' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I42>
</FONT><A NAME="_Toc375545479"></A><A NAME="_Toc481064853"></A><BR></P></DIV>
<A NAME="Heading488"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Improperly accessing resources</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider a variation on the counters that
have been used so far in this chapter. In the following example, each thread
contains two counters that are incremented and displayed inside
<B>run(&#160;)</B>. In addition, there&#8217;s another thread of class
<B>Watcher</B> that is watching the counters to see if they&#8217;re always
equivalent. This seems like a needless activity, since looking at the code it
appears obvious that the counters will always be the same. But that&#8217;s
where the surprise comes in. Here&#8217;s the first version of the
program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Sharing1.java</font>
<font color=#009900>// Problems with resource sharing while threading.</font>
<font color=#009900>// &lt;applet code=Sharing1 width=350 height=500&gt;</font>
<font color=#009900>// &lt;param name=size value="12"&gt;</font>
<font color=#009900>// &lt;param name=watchers value="15"&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Sharing1 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> accessCount = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> JTextField aCount = 
    <font color=#0000ff>new</font> JTextField(<font color=#004488>"0"</font>, 7);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  <font color=#0000ff>private</font> JButton 
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    watcher = <font color=#0000ff>new</font> JButton(<font color=#004488>"Watch"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isApplet = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> numCounters = 12;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> numWatchers = 15;
  <font color=#0000ff>private</font> TwoCounter[] s;
  <font color=#0000ff>class</font> TwoCounter <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> started = <font color=#0000ff>false</font>;
    <font color=#0000ff>private</font> JTextField 
      t1 = <font color=#0000ff>new</font> JTextField(5),
      t2 = <font color=#0000ff>new</font> JTextField(5);
    <font color=#0000ff>private</font> JLabel l = 
      <font color=#0000ff>new</font> JLabel(<font color=#004488>"count1 == count2"</font>);
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count1 = 0, count2 = 0;
    <font color=#009900>// Add the display components as a panel:</font>
    <font color=#0000ff>public</font> TwoCounter() {
      JPanel p = <font color=#0000ff>new</font> JPanel();
      p.add(t1);
      p.add(t2);
      p.add(l);
      getContentPane().add(p);
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> start() {
      <font color=#0000ff>if</font>(!started) {
        started = <font color=#0000ff>true</font>;
        <font color=#0000ff>super</font>.start();
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
        t1.setText(Integer.toString(count1++));
        t2.setText(Integer.toString(count2++));
        <font color=#0000ff>try</font> {
          sleep(500);
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> synchTest() {
      incrementAccess();
      <font color=#0000ff>if</font>(count1 != count2)
        l.setText(<font color=#004488>"Unsynched"</font>);
    }
  }
  <font color=#0000ff>class</font> Watcher <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>public</font> Watcher() { start(); }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
          s[i].synchTest();
        <font color=#0000ff>try</font> {
          sleep(500);
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
      }
    }
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
        s[i].start();
    }
  }
  <font color=#0000ff>class</font> WatcherL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numWatchers; i++)
        <font color=#0000ff>new</font> Watcher();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    <font color=#0000ff>if</font>(isApplet) {
      String counters = getParameter(<font color=#004488>"size"</font>);
      <font color=#0000ff>if</font>(counters != <font color=#0000ff>null</font>)
        numCounters = Integer.parseInt(counters);
      String watchers = getParameter(<font color=#004488>"watchers"</font>);
      <font color=#0000ff>if</font>(watchers != <font color=#0000ff>null</font>)
        numWatchers = Integer.parseInt(watchers);
    }
    s = <font color=#0000ff>new</font> TwoCounter[numCounters];
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i] = <font color=#0000ff>new</font> TwoCounter();
    JPanel p = <font color=#0000ff>new</font> JPanel();
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    p.add(start);
    watcher.addActionListener(<font color=#0000ff>new</font> WatcherL());
    p.add(watcher);
    p.add(<font color=#0000ff>new</font> JLabel(<font color=#004488>"Access Count"</font>));
    p.add(aCount);
    cp.add(p);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Sharing1 applet = <font color=#0000ff>new</font> Sharing1();
    <font color=#009900>// This isn't an applet, so set the flag and</font>
    <font color=#009900>// produce the parameter values from args:</font>
    applet.isApplet = <font color=#0000ff>false</font>;
    applet.numCounters = 
      (args.length == 0 ? 12 :
        Integer.parseInt(args[0]));
    applet.numWatchers =
      (args.length &lt; 2 ? 15 :
        Integer.parseInt(args[1]));
    Console.run(applet, 350, 
      applet.numCounters * 50);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, each counter contains its own
display components: two text fields and a label that initially indicates that
the counts are equivalent. These components are added to the content pane of the
outer class object in the <B>TwoCounter</B> constructor. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I42' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I43>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because a <B>TwoCounter </B>thread is
started via a keypress by the user, it&#8217;s possible that
<B>start(&#160;)</B> could be called more than once. It&#8217;s illegal for
<B>Thread.start(&#160;)</B> to be called more than once for a thread (an
exception is thrown). You can see the machinery to prevent this in the
<B>started </B>flag and the overridden <B>start(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I43' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I44>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>run(&#160;)</B>, <B>count1</B> and
<B>count2</B> are incremented and displayed in a manner that would seem to keep
them identical. Then
<A NAME="Index1926"></A><A NAME="Index1927"></A><B>sleep(&#160;)</B> is called;
without this call the program balks because it becomes hard for the CPU to swap
tasks. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I44' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I45>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>synchTest(&#160;)</B> method
performs the apparently useless activity of checking to see if <B>count1</B> is
equivalent to <B>count2</B>; if they are not equivalent it sets the label to
&#8220;Unsynched&#8221; to indicate this. But first, it calls a static member of
the class <B>Sharing1</B> that increments and displays an access counter to show
how many times this check has occurred successfully. (The reason for this will
become apparent in later variations of this example.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I45' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I46>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Watcher</B> class is a thread
whose job is to call <B>synchTest(&#160;)</B> for all of the <B>TwoCounter</B>
objects that are active. It does this by stepping through the array that&#8217;s
kept in the <B>Sharing1</B> object. You can think of the <B>Watcher</B> as
constantly peeking over the shoulders of the <B>TwoCounter</B> objects.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I46' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I47>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sharing1</B> contains an array of
<B>TwoCounter</B> objects that it initializes in <B>init(&#160;)</B> and starts
as threads when you press the &#8220;start&#8221; button. Later, when you press
the &#8220;Watch&#8221; button, one or more watchers are created and freed upon
the unsuspecting <B>TwoCounter </B>threads.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I47' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I48>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that to run this as an applet in a
browser, your applet tag will need to contain the lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&lt;param name=size value=<font color=#004488>"20"</font>&gt;
&lt;param name=watchers value=<font color=#004488>"1"</font>&gt;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can experiment by changing the width,
height, and parameters to suit your tastes. By changing the <B>size</B> and
<B>watchers</B> you&#8217;ll change the behavior of the program. This program is
set up to run as a stand-alone application by pulling the arguments from the
command line (or providing defaults).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I48' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I49>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the surprising part. In
<B>TwoCounter.run(&#160;)</B>, the infinite loop is just repeatedly passing over
the adjacent lines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>t1.setText(Integer.toString(count1++));
t2.setText(Integer.toString(count2++));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(as well as sleeping, but that&#8217;s
not important here). When you run the program, however, you&#8217;ll discover
that <B>count1</B> and <B>count2</B> will be observed (by the <B>Watcher</B>s)
to be unequal at times! This is because of the nature of threads&#8212;they can
be <A NAME="Index1928"></A>suspended at any time. So at times, the suspension
occurs <I>between</I> the execution of the above two lines, and the
<B>Watcher</B> thread happens to come along and perform the comparison at just
this moment, thus finding the two counters to be different.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I49' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I50>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example shows a fundamental problem
with using threads. You never know when a thread might be run. Imagine sitting
at a table with a fork, about to spear the last piece of food on your plate and
as your fork reaches for it, the food suddenly vanishes (because your thread was
suspended and another thread came in and stole the food). That&#8217;s the
problem that you&#8217;re dealing with.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I50' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I51>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes you don&#8217;t care if a
resource is being accessed at the same time you&#8217;re trying to use it (the
food is on some other plate). But for multithreading to work, you need some way
to prevent two threads from accessing the same resource, at least during
critical periods. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I51' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I52>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Preventing this kind of collision is
simply a matter of putting a lock on a resource when one thread is using it. The
first thread that accesses a resource locks it, and then the other threads
cannot access that resource until it is unlocked, at which time another thread
locks and uses it, etc. If the front seat of the car is the limited resource,
the child who shouts &#8220;Dibs!&#8221; asserts the lock.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I52' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I53>
</FONT><A NAME="_Toc375545480"></A><A NAME="_Toc481064854"></A><BR></P></DIV>
<A NAME="Heading489"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
How Java shares resources</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java has built-in support to prevent
collisions over one kind of resource: the memory in an object. Since you
typically make the data elements of a class
<A NAME="Index1929"></A><B>private</B> and access that memory only through
methods, you can prevent collisions by making a particular method
<A NAME="Index1930"></A><B>synchronized</B>. Only one thread at a time can call
a <B>synchronized</B> method for a particular object (although that thread can
call more than one of the object&#8217;s synchronized methods). Here are simple
<B>synchronized</B> methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> f() { <font color=#009900>/* ... */</font> }
<font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> g(){ <font color=#009900>/* ... */</font> }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each object contains a single
<A NAME="Index1931"></A><A NAME="Index1932"></A>lock (also called a
<A NAME="Index1933"></A><I>monitor</I>) that is automatically part of the object
(you don&#8217;t have to write any special code). When you call any
<B>synchronized</B> method, that object is locked and no other
<B>synchronized</B> method of that object can be called until the first one
finishes and releases the lock. In the example above, if <B>f(&#160;)</B> is
called for an object, <B>g(&#160;)</B> cannot be called for the same object
until <B>f(&#160;)</B> is completed and releases the lock. Thus, there&#8217;s a
single lock that&#8217;s shared by all the <B>synchronized</B> methods of a
particular object, and this lock prevents common memory from being written by
more than one method at a time (i.e., more than one thread at a time).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I53' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I54>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s also a single lock per
class (as part of the
<A NAME="Index1934"></A><A NAME="Index1935"></A><B>Class</B> object for the
class), so that
<A NAME="Index1936"></A><A NAME="Index1937"></A><B>synchronized</B>
<B>static</B> methods can lock each other out from simultaneous access of
<B>static </B>data on a class-wide basis.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I54' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I55>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that if you want to guard some other
resource from simultaneous access by multiple threads, you can do so by forcing
access to that resource through <B>synchronized</B> methods.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I55' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I56>
</FONT><BR></P></DIV>
<A NAME="Heading490"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Synchronizing the counters</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Armed with this new keyword it appears
that the solution is at hand: we&#8217;ll simply use the <B>synchronized</B>
keyword for the methods in <B>TwoCounter</B>. The following example is the same
as the previous one, with the addition of the new keyword:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Sharing2.java</font>
<font color=#009900>// Using the synchronized keyword to prevent</font>
<font color=#009900>// multiple access to a particular resource.</font>
<font color=#009900>// &lt;applet code=Sharing2 width=350 height=500&gt;</font>
<font color=#009900>// &lt;param name=size value="12"&gt;</font>
<font color=#009900>// &lt;param name=watchers value="15"&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Sharing2 <font color=#0000ff>extends</font> JApplet {
  TwoCounter[] s;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> accessCount = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> JTextField aCount = 
    <font color=#0000ff>new</font> JTextField(<font color=#004488>"0"</font>, 7);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> incrementAccess() {
    accessCount++;
    aCount.setText(Integer.toString(accessCount));
  }
  <font color=#0000ff>private</font> JButton 
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    watcher = <font color=#0000ff>new</font> JButton(<font color=#004488>"Watch"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isApplet = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> numCounters = 12;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> numWatchers = 15;

  <font color=#0000ff>class</font> TwoCounter <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> started = <font color=#0000ff>false</font>;
    <font color=#0000ff>private</font> JTextField 
      t1 = <font color=#0000ff>new</font> JTextField(5),
      t2 = <font color=#0000ff>new</font> JTextField(5);
    <font color=#0000ff>private</font> JLabel l = 
      <font color=#0000ff>new</font> JLabel(<font color=#004488>"count1 == count2"</font>);
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count1 = 0, count2 = 0;
    <font color=#0000ff>public</font> TwoCounter() {
      JPanel p = <font color=#0000ff>new</font> JPanel();
      p.add(t1);
      p.add(t2);
      p.add(l);
      getContentPane().add(p);
    }    
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> start() {
      <font color=#0000ff>if</font>(!started) {
        started = <font color=#0000ff>true</font>;
        <font color=#0000ff>super</font>.start();
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
        t1.setText(Integer.toString(count1++));
        t2.setText(Integer.toString(count2++));
        <font color=#0000ff>try</font> {
          sleep(500);
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
      }
    }
    <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> synchTest() {
      incrementAccess();
      <font color=#0000ff>if</font>(count1 != count2)
        l.setText(<font color=#004488>"Unsynched"</font>);
    }
  }
  
  <font color=#0000ff>class</font> Watcher <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>public</font> Watcher() { start(); }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
          s[i].synchTest();
        <font color=#0000ff>try</font> {
          sleep(500);
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
      }
    }
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
        s[i].start();
    }
  }
  <font color=#0000ff>class</font> WatcherL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; numWatchers; i++)
        <font color=#0000ff>new</font> Watcher();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    <font color=#0000ff>if</font>(isApplet) {
      String counters = getParameter(<font color=#004488>"size"</font>);
      <font color=#0000ff>if</font>(counters != <font color=#0000ff>null</font>)
        numCounters = Integer.parseInt(counters);
      String watchers = getParameter(<font color=#004488>"watchers"</font>);
      <font color=#0000ff>if</font>(watchers != <font color=#0000ff>null</font>)
        numWatchers = Integer.parseInt(watchers);
    }
    s = <font color=#0000ff>new</font> TwoCounter[numCounters];
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i] = <font color=#0000ff>new</font> TwoCounter();
    JPanel p = <font color=#0000ff>new</font> JPanel();
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    p.add(start);
    watcher.addActionListener(<font color=#0000ff>new</font> WatcherL());
    p.add(watcher);
    p.add(<font color=#0000ff>new</font> Label(<font color=#004488>"Access Count"</font>));
    p.add(aCount);
    cp.add(p);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Sharing2 applet = <font color=#0000ff>new</font> Sharing2();
    <font color=#009900>// This isn't an applet, so set the flag and</font>
    <font color=#009900>// produce the parameter values from args:</font>
    applet.isApplet = <font color=#0000ff>false</font>;
    applet.numCounters = 
      (args.length == 0 ? 12 :
        Integer.parseInt(args[0]));
    applet.numWatchers =
      (args.length &lt; 2 ? 15 :
        Integer.parseInt(args[1]));
    Console.run(applet, 350, 
      applet.numCounters * 50);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that <I>both</I>
<B>run(&#160;)</B> and <B>synchTest(&#160;)</B> are <B>synchronized</B>. If you
synchronize only one of the methods, then the other is free to ignore the object
lock and can be called with impunity. This is an important point: Every method
that accesses a critical shared resource must be <B>synchronized</B> or it
won&#8217;t work right. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I56' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I57>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now a new issue arises. The
<B>Watcher</B> can never get a peek at what&#8217;s going on because the entire
<B>run(&#160;)</B> method has been <B>synchronized</B>, and since
<B>run(&#160;)</B> is always running for each object the lock is always tied up
and <B>synchTest(&#160;)</B> can never be called. You can see this because the
<B>accessCount</B> never changes.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I57' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I58>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What we&#8217;d like for this example is
a way to isolate only <I>part</I> of the code inside <B>run(&#160;)</B>. The
section of code you want to isolate this way is called a
<A NAME="Index1938"></A><A NAME="Index1939"></A><I>critical section</I> and you
use the <B>synchronized</B> keyword in a different way to set up a critical
section. Java supports critical sections with the
<A NAME="Index1940"></A><I>synchronized block;</I> this time <B>synchronized
</B>is used to specify the object whose lock is being used to synchronize the
enclosed code: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I58' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I59>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>synchronized</font>(syncObject) {
  <font color=#009900>// This code can be accessed </font>
  <font color=#009900>// by only one thread at a time</font>
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before the synchronized block can be
entered, the lock must be acquired on <B>syncObject</B>. If some other thread
already has this lock, then the block cannot be entered until the lock is given
up. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I59' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I60>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Sharing2</B> example can be
modified by removing the <B>synchronized</B> keyword from the entire
<B>run(&#160;)</B> method and instead putting a <B>synchronized</B> block around
the two critical lines. But what object should be used as the lock? The one that
is already respected by <B>synchTest(&#160;)</B>, which is the current object
(<B>this</B>)! So the modified <B>run(&#160;)</B> looks like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
      <font color=#0000ff>synchronized</font>(<font color=#0000ff>this</font>) {
        t1.setText(Integer.toString(count1++));
        t2.setText(Integer.toString(count2++));
      }
      <font color=#0000ff>try</font> {
        sleep(500);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the only change that must be made
to <B>Sharing2.java</B>, and you&#8217;ll see that while the two counters are
never out of synch (according to when the <B>Watcher</B> is allowed to look at
them), there is still adequate access provided to the <B>Watcher</B> during the
execution of <B>run(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I60' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I61>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, all synchronization depends on
programmer diligence: every piece of code that can access a shared resource must
be wrapped in an appropriate synchronized block. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I61' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I62>
</FONT><BR></P></DIV>
<A NAME="Heading491"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Synchronized efficiency<BR><A NAME="Index1941"></A><A NAME="Index1942"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since having two methods write to the
same piece of data <I>never </I>sounds like a particularly good idea, it might
seem to make sense for all methods to be automatically <B>synchronized</B> and
eliminate the <B>synchronized</B> keyword altogether. (Of course, the example
with a <B>synchronized run(&#160;)</B> shows that this wouldn&#8217;t work
either.) But it turns out that acquiring a lock is not a cheap
operation&#8212;it multiplies the cost of a method call (that is, entering and
exiting from the method, not executing the body of the method) by a minimum of
four times, and could be much more depending on your implementation. So if you
know that a particular method will not cause contention problems it is expedient
to leave off the <B>synchronized</B> keyword. On the other hand, leaving off the
<B>synchronized</B> keyword because you think it is a performance bottleneck,
and hoping that there aren&#8217;t any collisions is an invitation to disaster.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I62' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I63>
</FONT><A NAME="_Toc481064855"></A><BR></P></DIV>
<A NAME="Heading492"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
JavaBeans revisited</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that you understand synchronization,
you can take another look at
<A NAME="Index1943"></A><A NAME="Index1944"></A><A NAME="Index1945"></A>JavaBeans.
Whenever you create a Bean, you must assume that it will run in a multithreaded
environment. This means that:
<A NAME="Index1946"></A><A NAME="Index1947"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Whenever possible, all the
<B>public</B> methods of a Bean should be <B>synchronized</B>. Of course, this
incurs the <B>synchronized</B> run-time overhead. If that&#8217;s a problem,
methods that will not cause problems in critical sections can be left
un-<B>synchronized</B>, but keep in mind that this is not always obvious.
Methods that qualify tend to be small (such as <B>getCircleSize(&#160;)</B> in
the following example) and/or &#8220;atomic,&#8221; that is, the method call
executes in such a short amount of code that the object cannot be changed during
execution. Making such methods un-<B>synchronized </B>might not have a
significant effect on the execution speed of your program. You might as well
make all <B>public</B> methods of a Bean <B>synchronized</B> and remove the
<B>synchronized</B> keyword only when you know for sure that it&#8217;s
necessary and that it makes a difference.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I63' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I64>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">When
firing a multicast event to a bunch of listeners interested in that event, you
must assume that listeners might be added or removed while moving through the
list.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I64' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I65>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
first point is fairly easy to deal with, but the second point requires a little
more thought. Consider the <B>BangBean.java</B> example presented in the last
chapter. That ducked out of the multithreading question by ignoring the
<B>synchronized</B> keyword (which hadn&#8217;t been introduced yet) and making
the event unicast. Here&#8217;s that example modified to work in a multithreaded
environment and to use multicasting for events:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:BangBean2.java</font>
<font color=#009900>// You should write your Beans this way so they </font>
<font color=#009900>// can run in a multithreaded environment.</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> BangBean2 <font color=#0000ff>extends</font> JPanel 
    <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xm, ym;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> cSize = 20; <font color=#009900>// Circle size</font>
  <font color=#0000ff>private</font> String text = <font color=#004488>"Bang!"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> fontSize = 48;
  <font color=#0000ff>private</font> Color tColor = Color.red;
  <font color=#0000ff>private</font> ArrayList actionListeners = 
    <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> BangBean2() {
    addMouseListener(<font color=#0000ff>new</font> ML());
    addMouseMotionListener(<font color=#0000ff>new</font> MM());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>int</font> getCircleSize() { 
    <font color=#0000ff>return</font> cSize; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
  setCircleSize(<font color=#0000ff>int</font> newSize) {
    cSize = newSize;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> String getBangText() { 
    <font color=#0000ff>return</font> text; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
  setBangText(String newText) {
    text = newText;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>int</font> getFontSize() { 
    <font color=#0000ff>return</font> fontSize; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
  setFontSize(<font color=#0000ff>int</font> newSize) {
    fontSize = newSize;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> Color getTextColor() {
    <font color=#0000ff>return</font> tColor; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
  setTextColor(Color newColor) {
    tColor = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paintComponent(Graphics g) {
    <font color=#0000ff>super</font>.paintComponent(g);
    g.setColor(Color.black);
    g.drawOval(xm - cSize/2, ym - cSize/2, 
      cSize, cSize);
  }
  <font color=#009900>// This is a multicast listener, which is</font>
  <font color=#009900>// more typically used than the unicast</font>
  <font color=#009900>// approach taken in BangBean.java:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
    addActionListener(ActionListener l) {
    actionListeners.add(l);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> 
    removeActionListener(ActionListener l) {
    actionListeners.remove(l);
  }
  <font color=#009900>// Notice this isn't synchronized:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> notifyListeners() {
    ActionEvent a =
      <font color=#0000ff>new</font> ActionEvent(BangBean2.<font color=#0000ff>this</font>,
        ActionEvent.ACTION_PERFORMED, <font color=#0000ff>null</font>);
    ArrayList lv = <font color=#0000ff>null</font>;
    <font color=#009900>// Make a shallow copy of the List in case </font>
    <font color=#009900>// someone adds a listener while we're </font>
    <font color=#009900>// calling listeners:</font>
    <font color=#0000ff>synchronized</font>(<font color=#0000ff>this</font>) {
      lv = (ArrayList)actionListeners.clone();
    }
    <font color=#009900>// Call all the listener methods:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; lv.size(); i++)
      ((ActionListener)lv.get(i))
        .actionPerformed(a);
  }
  <font color=#0000ff>class</font> ML <font color=#0000ff>extends</font> MouseAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mousePressed(MouseEvent e) {
      Graphics g = getGraphics();
      g.setColor(tColor);
      g.setFont(
        <font color=#0000ff>new</font> Font(
          <font color=#004488>"TimesRoman"</font>, Font.BOLD, fontSize));
      <font color=#0000ff>int</font> width = 
        g.getFontMetrics().stringWidth(text);
      g.drawString(text, 
        (getSize().width - width) /2,
        getSize().height/2);
      g.dispose();
      notifyListeners();
    }
  }
  <font color=#0000ff>class</font> MM <font color=#0000ff>extends</font> MouseMotionAdapter {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> mouseMoved(MouseEvent e) {
      xm = e.getX();
      ym = e.getY();
      repaint();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    BangBean2 bb = <font color=#0000ff>new</font> BangBean2();
    bb.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        System.out.println(<font color=#004488>"ActionEvent"</font> + e);
      }
    });
    bb.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        System.out.println(<font color=#004488>"BangBean2 action"</font>);
      }
    });
    bb.addActionListener(<font color=#0000ff>new</font> ActionListener() {
      <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e){
        System.out.println(<font color=#004488>"More action"</font>);
      }
    });
    Console.run(bb, 300, 300);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adding <B>synchronized</B> to the methods
is an easy change. However, notice in
<A NAME="Index1948"></A><B>addActionListener(&#160;)</B> and
<A NAME="Index1949"></A><B>removeActionListener(&#160;)</B> that the
<B>ActionListener</B>s are now added to and removed from an <B>ArrayList</B>, so
you can have as many as you want.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I65' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I66>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the method
<A NAME="Index1950"></A><B>notifyListeners(&#160;)</B> is <I>not</I>
<B>synchronized</B>. It can be called from more than one thread at a time.
It&#8217;s also possible for <B>addActionListener(&#160;)</B> or
<B>removeActionListener(&#160;)</B> to be called in the middle of a call to
<B>notifyListeners(&#160;)</B>, which is a problem since it traverses the
<B>ArrayList actionListeners</B>. To alleviate the problem, the <B>ArrayList</B>
is cloned inside a <B>synchronized</B> clause and the clone is traversed (see
Appendix A for details of cloning). This way the original <B>ArrayList</B> can
be manipulated without impact on <B>notifyListeners(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I66' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I67>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>paintComponent(&#160;)</B> method
is also not
<A NAME="Index1951"></A><A NAME="Index1952"></A><A NAME="Index1953"></A><B>synchronized</B>.
Deciding whether to synchronize overridden methods is not as clear as when
you&#8217;re just adding your own methods. In this example it turns out that
<B>paint(&#160;)</B> seems to work OK whether it&#8217;s <B>synchronized</B> or
not. But the issues you must consider are:
<A NAME="Index1954"></A><A NAME="Index1955"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Does the method modify the
state of &#8220;critical&#8221; variables within the object? To discover whether
the variables are &#8220;critical&#8221; you must determine whether they will be
read or set by other threads in the program. (In this case, the reading or
setting is virtually always accomplished via <B>synchronized</B> methods, so you
can just examine those.) In the case of <B>paint(&#160;)</B>, no modification
takes place.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I67' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I68>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Does
the method depend on the state of these &#8220;critical&#8221; variables? If a
<B>synchronized</B> method modifies a variable that your method uses, then you
might very well want to make your method <B>synchronized</B> as well. Based on
this, you might observe that <B>cSize</B> is changed by <B>synchronized</B>
methods and therefore <B>paint(&#160;)</B> should be <B>synchronized</B>. Here,
however, you can ask &#8220;What&#8217;s the worst thing that will happen if
<B>cSize</B> is changed during a <B>paint(&#160;)</B>?&#8221; When you see that
it&#8217;s nothing too bad, and a transient effect at that, you can decide to
leave <B>paint(&#160;)</B> un-<B>synchronized</B> to prevent the extra overhead
from the <B>synchronized</B> method call.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I68' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I69>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
third clue is to notice whether the base-class version of <B>paint(&#160;)</B>
is <B>synchronized</B>, which it isn&#8217;t. This isn&#8217;t an airtight
argument, just a clue. In this case, for example, a field that <I>is</I> changed
via <B>synchronized</B> methods (that is <B>cSize</B>) has been mixed into the
<B>paint(&#160;)</B> formula and might have changed the situation. Notice,
however, that <B>synchronized</B> doesn&#8217;t inherit&#8212;that is, if a
method is <B>synchronized</B> in the base class then it <I>is not</I>
automatically <B>synchronized</B> in the derived class overridden version.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I69' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I70>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
test code in <B>TestBangBean2</B> has been modified from that in the previous
chapter to demonstrate the multicast ability of <B>BangBean2</B> by adding extra
listeners.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I70' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I71>
</FONT><A NAME="_Toc375545481"></A><A NAME="_Toc481064856"></A><BR></P></DIV>
<A NAME="Heading493"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Blocking
<BR><A NAME="Index1956"></A><A NAME="Index1957"></A><A NAME="Index1958"></A><A NAME="Index1959"></A><A NAME="Index1960"></A><A NAME="Index1961"></A><A NAME="Index1962"></A><A NAME="Index1963"></A><A NAME="Index1964"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A thread can be in any one of four
states: </FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana"><I>	</I></FONT><FONT FACE="Georgia"><I>New</I>: The
thread object has been created but it hasn&#8217;t been started yet so it cannot
run.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I71' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I72>
</FONT><LI><FONT FACE="Verdana"><I>	</I></FONT><FONT FACE="Georgia"><I>Runnable</I>:
This means that a thread <I>can</I> be run when the time-slicing mechanism has
CPU cycles available for the thread. Thus, the thread might or might not be
running, but there&#8217;s nothing to prevent it from being run if the scheduler
can arrange it; it&#8217;s not dead or blocked.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I72' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I73>
</FONT><LI><FONT FACE="Verdana"><I>	</I></FONT><FONT FACE="Georgia"><I>Dead</I>:
The normal way for a thread to die is by returning from its <B>run(&#160;)
</B>method. You can also call <B>stop(&#160;)</B>, but this throws an exception
that&#8217;s a subclass of <B>Error</B> (which means you aren&#8217;t forced to
put the call in a <B>try</B> block). Remember that throwing an exception should
be a special event and not part of normal program execution; thus the use of
<B>stop(&#160;)</B> is deprecated in Java 2. There&#8217;s also a
<B>destroy(&#160;)</B> method (which has never been implemented) that you should
never call if you can avoid it since it&#8217;s drastic and doesn&#8217;t
release object locks.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I73' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I74>
</FONT><LI><FONT FACE="Verdana"><I>	</I></FONT><FONT FACE="Georgia"><I>Blocked</I>:
The thread could be run but there&#8217;s something that prevents it. While a
thread is in the blocked state the scheduler will simply skip over it and not
give it any CPU time. Until a thread reenters the runnable state it won&#8217;t
perform any operations.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I74' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I75>
</FONT><A NAME="_Toc375545482"></A><A NAME="_Toc481064857"></A></OL><A NAME="Heading494"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Becoming blocked</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The blocked state is the most interesting
one, and is worth further examination. A thread can become blocked for five
reasons:
<A NAME="Index1965"></A><A NAME="Index1966"></A><A NAME="Index1967"></A><A NAME="Index1968"></A><A NAME="Index1969"></A><A NAME="Index1970"></A><A NAME="Index1971"></A><A NAME="Index1972"></A><A NAME="Index1973"></A><A NAME="Index1974"></A><A NAME="Index1975"></A><A NAME="Index1976"></A><A NAME="Index1977"></A><A NAME="Index1978"></A><A NAME="Index1979"></A><A NAME="Index1980"></A><A NAME="Index1981"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I75' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I76>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You&#8217;ve put the
thread to sleep by calling <B>sleep(milliseconds),</B> in which case it will not
be run for the specified time.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I76' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I77>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You&#8217;ve
suspended the execution of the thread with <B>suspend(&#160;)</B>. It will not
become runnable again until the thread gets the <B>resume(&#160;)</B> message
(these are deprecated in Java 2, and will be examined further).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I77' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I78>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">You&#8217;ve
suspended the execution of the thread with <B>wait(&#160;)</B>. It will not
become runnable again until the thread gets the <B>notify(&#160;)</B> or
<B>notifyAll(&#160;)</B> message. (Yes, this looks just like number 2, but
there&#8217;s a distinct difference that will be revealed.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I78' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I79>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
thread is waiting for some I/O to complete.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I79' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I80>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
thread is trying to call a <B>synchronized </B>method on another object, and
that object&#8217;s lock is not available.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I80' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I81>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You
can also call
<A NAME="Index1982"></A><A NAME="Index1983"></A><B>yield(&#160;)</B> (a method
of the <B>Thread </B>class) to voluntarily give up the CPU so that other threads
can run. However, the same thing happens if the scheduler decides that your
thread has had enough time and jumps to another thread. That is, nothing
prevents the scheduler from moving your thread and giving time to some other
thread. When a thread is blocked, there&#8217;s some reason that it cannot
continue running. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I81' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I82>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows all five ways
of becoming blocked. It all exists in a single file called <B>Blocking.java,</B>
but it will be examined here in discrete pieces. (You&#8217;ll notice the
&#8220;Continued&#8221; and &#8220;Continuing&#8221; tags that allow the code
extraction tool to piece everything together.) 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I82' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I83>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because this example demonstrates some
deprecated methods, you <I>will </I>get deprecation messages when it is
compiled. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I83' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I84>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, the basic
framework:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Blocking.java</font>
<font color=#009900>// Demonstrates the various ways a thread</font>
<font color=#009900>// can be blocked.</font>
<font color=#009900>// &lt;applet code=Blocking width=350 height=550&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#009900>//////////// The basic framework ///////////</font>
<font color=#0000ff>class</font> Blockable <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> Peeker peeker;
  <font color=#0000ff>protected</font> JTextField state = <font color=#0000ff>new</font> JTextField(30);
  <font color=#0000ff>protected</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> Blockable(Container c) {
    c.add(state);
    peeker = <font color=#0000ff>new</font> Peeker(<font color=#0000ff>this</font>, c);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>int</font> read() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>protected</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> update() {
    state.setText(getClass().getName()
      + <font color=#004488>" state: i = "</font> + i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> stopPeeker() { 
    <font color=#009900>// peeker.stop(); Deprecated in Java 1.2</font>
    peeker.terminate(); <font color=#009900>// The preferred approach</font>
  }
}

<font color=#0000ff>class</font> Peeker <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> Blockable b;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> session;
  <font color=#0000ff>private</font> JTextField status = <font color=#0000ff>new</font> JTextField(30);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> stop = <font color=#0000ff>false</font>;
  <font color=#0000ff>public</font> Peeker(Blockable b, Container c) {
    c.add(status);
    <font color=#0000ff>this</font>.b = b;
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> terminate() { stop = <font color=#0000ff>true</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font> (!stop) {
      status.setText(b.getClass().getName()
        + <font color=#004488>" Peeker "</font> + (++session)
        + <font color=#004488>"; value = "</font> + b.read());
       <font color=#0000ff>try</font> {
        sleep(100);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }
} <font color=#009900>///:Continued</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Blockable </B>class is meant to be
a base class for all the classes in this example that demonstrate blocking. A
<B>Blockable</B> object contains a<B> JTextField</B> called <B>state</B> that is
used to display information about the object. The method that displays this
information is <B>update(&#160;)</B>. You can see it uses
<B>getClass(&#160;).getName(&#160;)</B> to produce the name of the class instead
of just printing it out; this is because <B>update(&#160;)</B> cannot know the
exact name of the class it is called for, since it will be a class derived from
<B>Blockable</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I84' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I85>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The indicator of change in
<B>Blockable</B> is an <B>int i,</B> which will be incremented by the
<B>run(&#160;)</B> method of the derived class.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I85' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I86>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a thread of class
<B>Peeker</B> that is started for each <B>Blockable</B> object, and the
<B>Peeker</B>&#8217;s job is to watch its associated <B>Blockable</B> object to
see changes in <B>i </B>by calling <B>read(&#160;)</B> and reporting them in its
<B>status JTextField</B>. This is important: Note that <B>read(&#160;)</B> and
<B>update(&#160;)</B> are both <B>synchronized</B>, which means they require
that the object lock be free.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I86' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I87>
</FONT><BR></P></DIV>
<A NAME="Heading495"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Sleeping</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first test in this program is with
<A NAME="Index1984"></A><A NAME="Index1985"></A><B>sleep(&#160;):</B></FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///:Continuing</font>
<font color=#009900>///////////// Blocking via sleep() ///////////</font>
<font color=#0000ff>class</font> Sleeper1 <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>public</font> Sleeper1(Container c) { <font color=#0000ff>super</font>(c); }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      i++;
      update();
       <font color=#0000ff>try</font> {
        sleep(1000);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }
}
  
<font color=#0000ff>class</font> Sleeper2 <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>public</font> Sleeper2(Container c) { <font color=#0000ff>super</font>(c); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      change();
       <font color=#0000ff>try</font> {
        sleep(1000);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> change() {
      i++;
      update();
  }
} <font color=#009900>///:Continued</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Sleeper1</B> the entire
<B>run(&#160;)</B> method is <B>synchronized</B>. You&#8217;ll see that the
<B>Peeker</B> associated with this object will run along merrily <I>until</I>
you start the thread, and then the <B>Peeker</B> stops cold. This is one form of
blocking: since <B>Sleeper1.run(&#160;)</B> is <B>synchronized</B>, and once the
thread starts it&#8217;s always inside <B>run(&#160;)</B>, the method never
gives up the object lock and the <B>Peeker</B> is blocked.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I87' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I88>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sleeper2</B> provides a solution by
making <B>run(&#160;)</B> un-<B>synchronized</B>. Only the <B>change(&#160;)</B>
method is <B>synchronized</B>, which means that while <B>run(&#160;)</B> is in
<B>sleep(&#160;)</B>, the <B>Peeker</B> can access the <B>synchronized</B>
method it needs, namely <B>read(&#160;)</B>. Here you&#8217;ll see that the
<B>Peeker</B> continues running when you start the <B>Sleeper2</B> thread.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I88' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I89>
</FONT><BR></P></DIV>
<A NAME="Heading496"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Suspending and resuming</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next part of the example introduces
the concept of suspension. The <B>Thread</B> class has a method
<A NAME="Index1986"></A><A NAME="Index1987"></A><B>suspend(&#160;)</B> to
temporarily stop the thread and
<A NAME="Index1988"></A><A NAME="Index1989"></A><B>resume(&#160;)</B> that
restarts it at the point it was halted. <B>resume(&#160;)</B> must be called by
some thread outside the suspended one, and in this case there&#8217;s a separate
class called <B>Resumer</B> that does just that. Each of the classes
demonstrating suspend/resume has an associated resumer:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///:Continuing</font>
<font color=#009900>/////////// Blocking via suspend() ///////////</font>
<font color=#0000ff>class</font> SuspendResume <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>public</font> SuspendResume(Container c) {
    <font color=#0000ff>super</font>(c);    
    <font color=#0000ff>new</font> Resumer(<font color=#0000ff>this</font>); 
  }
}

<font color=#0000ff>class</font> SuspendResume1 <font color=#0000ff>extends</font> SuspendResume {
  <font color=#0000ff>public</font> SuspendResume1(Container c) { <font color=#0000ff>super</font>(c);}
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      i++;
      update();
      suspend(); <font color=#009900>// Deprecated in Java 1.2</font>
    }
  }
}

<font color=#0000ff>class</font> SuspendResume2 <font color=#0000ff>extends</font> SuspendResume {
  <font color=#0000ff>public</font> SuspendResume2(Container c) { <font color=#0000ff>super</font>(c);}
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      change();
      suspend(); <font color=#009900>// Deprecated in Java 1.2</font>
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> change() {
      i++;
      update();
  }
}

<font color=#0000ff>class</font> Resumer <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> SuspendResume sr;
  <font color=#0000ff>public</font> Resumer(SuspendResume sr) {
    <font color=#0000ff>this</font>.sr = sr;
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
       <font color=#0000ff>try</font> {
        sleep(1000);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
      sr.resume(); <font color=#009900>// Deprecated in Java 1.2</font>
    }
  }
} <font color=#009900>///:Continued</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SuspendResume1</B> also has a
<B>synchronized run(&#160;)</B> method. Again, when you start this thread
you&#8217;ll see that its associated <B>Peeker</B> gets blocked waiting for the
lock to become available, which never happens. This is fixed as before in
<B>SuspendResume2</B>, which does not <B>synchronize</B> the entire
<B>run(&#160;)</B> method but instead uses a separate <B>synchronized</B>
<B>change(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I89' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I90>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should be aware that Java 2
deprecates the use of <B>suspend(&#160;)</B> and <B>resume(&#160;)</B>, because
<B>suspend(&#160;)</B> holds the object&#8217;s lock and is thus
<A NAME="Index1990"></A><A NAME="Index1991"></A>deadlock-prone. That is, you can
easily get a number of locked objects waiting on each other, and this will cause
your program to freeze. Although you might see them used in older programs you
should not use <B>suspend(&#160;)</B> and <B>resume(&#160;)</B>. The proper
solution is described later in this chapter.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I90' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I91>
</FONT><BR></P></DIV>
<A NAME="Heading497"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Wait and notify</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the first two examples, it&#8217;s
important to understand that both <B>sleep(&#160;)</B> and
<B>suspend(&#160;)</B> <I>do not </I>release the lock as they are called. You
must be aware of this when working with locks. On the other hand, the method
<A NAME="Index1992"></A><A NAME="Index1993"></A><B>wait(&#160;)</B> <I>does</I>
release the lock when it is called, which means that other
<A NAME="Index1994"></A><B>synchronized</B> methods in the thread object could
be called during a <B>wait(&#160;)</B>. In the following two classes,
you&#8217;ll see that the <B>run(&#160;)</B> method is fully <B>synchronized</B>
in both cases, however, the <B>Peeker</B> still has full access to the
<B>synchronized</B> methods during a <B>wait(&#160;)</B>. This is because
<B>wait(&#160;)</B> releases the lock on the object as it suspends the method
it&#8217;s called within. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I91' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I92>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll also see that there are two
forms of <B>wait(&#160;)</B>. The first takes an argument in milliseconds that
has the same meaning as in <B>sleep(&#160;)</B>: pause for this period of time.
The difference is that in <B>wait(&#160;)</B>, the object lock is released
<I>and</I> you can come out of the <B>wait(&#160;)</B> because of a
<B>notify(&#160;)</B> as well as having the clock run out.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I92' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I93>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second form takes no arguments, and
means that the <B>wait(&#160;)</B> will continue until a <B>notify(&#160;)</B>
comes along and will not automatically terminate after a time.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I93' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I94>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1995"></A><FONT FACE="Georgia">One fairly unique
aspect of <B>wait(&#160;)</B> and <B>notify(&#160;)</B> is that both methods are
part of the base class <B>Object</B> and not part of <B>Thread</B> as are
<B>sleep(&#160;)</B>, <B>suspend(&#160;)</B>, and <B>resume(&#160;)</B>.
Although this seems a bit strange at first&#8212;to have something that&#8217;s
exclusively for threading as part of the universal base class&#8212;it&#8217;s
essential because they manipulate the lock that&#8217;s also part of every
object. As a result, you can put a <B>wait(&#160;)</B> inside any
<B>synchronized</B> method, regardless of whether there&#8217;s any threading
going on inside that particular class. In fact, the <I>only</I> place you can
call <B>wait(&#160;)</B> is within a <B>synchronized</B> method or block. If you
call <B>wait(&#160;)</B> or <B>notify(&#160;)</B> within a method that&#8217;s
not <B>synchronized,</B> the program will compile, but when you run it
you&#8217;ll get an <A NAME="Index1996"></A><B>IllegalMonitorStateException</B>
with the somewhat nonintuitive message &#8220;current thread not owner.&#8221;
Note that <B>sleep(&#160;)</B>, <B>suspend(&#160;),</B> and
<B>resume(&#160;)</B> can all be called within non-<B>synchronized</B> methods
since they don&#8217;t manipulate the lock.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I94' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I95>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can call <B>wait(&#160;)</B> or
<B>notify(&#160;)</B> only for your own lock. Again, you can compile code that
tries to use the wrong lock, but it will produce the same
<B>IllegalMonitorStateException</B> message as before. You can&#8217;t fool with
someone else&#8217;s lock, but you can ask another object to perform an
operation that manipulates its own lock. So one approach is to create a
<B>synchronized</B> method that calls <B>notify(&#160;)</B> for its own object.
However, in <B>Notifier</B> you&#8217;ll see the <B>notify(&#160;)</B> call
inside a <B>synchronized</B> block:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>synchronized</font>(wn2) {
  wn2.notify();
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">where <B>wn2</B> is the object of type
<B>WaitNotify2</B>. This method, which is not part of <B>WaitNotify2</B>,
acquires the lock on the <B>wn2</B> object, at which point it&#8217;s legal for
it to call <B>notify(&#160;)</B> for <B>wn2</B> and you won&#8217;t get the
<B>IllegalMonitorStateException</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I95' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I96>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///:Continuing</font>
<font color=#009900>/////////// Blocking via wait() ///////////</font>
<font color=#0000ff>class</font> WaitNotify1 <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>public</font> WaitNotify1(Container c) { <font color=#0000ff>super</font>(c); }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      i++;
      update();
       <font color=#0000ff>try</font> {
        wait(1000);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }
}

<font color=#0000ff>class</font> WaitNotify2 <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>public</font> WaitNotify2(Container c) {
    <font color=#0000ff>super</font>(c);
    <font color=#0000ff>new</font> Notifier(<font color=#0000ff>this</font>); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      i++;
      update();
       <font color=#0000ff>try</font> {
        wait();
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    }
  }
}

<font color=#0000ff>class</font> Notifier <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> WaitNotify2 wn2;
  <font color=#0000ff>public</font> Notifier(WaitNotify2 wn2) {
    <font color=#0000ff>this</font>.wn2 = wn2;
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
       <font color=#0000ff>try</font> {
        sleep(2000);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
      <font color=#0000ff>synchronized</font>(wn2) {
        wn2.notify();
      }
    }
  }
}  <font color=#009900>///:Continued</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>wait(&#160;)</B> is typically used
when you&#8217;ve gotten to the point where you&#8217;re waiting for some other
condition, under the control of forces outside your thread, to change and you
don&#8217;t want to idly wait by inside the thread. So <B>wait(&#160;)</B>
allows you to put the thread to sleep while waiting for the world to change, and
only when a <B>notify(&#160;)</B> or <B>notifyAll(&#160;) </B>occurs does the
thread wake up and check for changes. Thus, it provides a way to synchronize
between threads.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I96' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I97>
</FONT><A NAME="_Ref368085592"></A><BR></P></DIV>
<A NAME="Heading498"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Blocking on I/O<BR><A NAME="Index1997"></A><A NAME="Index1998"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a stream is waiting for some I/O
activity, it will automatically block. In the following portion of the example,
the two classes work with generic <A NAME="Index1999"></A><B>Reader</B> and
<A NAME="Index2000"></A><B>Writer</B> objects, but in the test framework a
<A NAME="Index2001"></A><A NAME="Index2002"></A>piped stream will be set up to
allow the two threads to safely pass data to each other (which is the purpose of
piped streams). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I97' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I98>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Sender</B> puts data into the
<B>Writer</B> and sleeps for a random amount of time. However, <B>Receiver</B>
has no <B>sleep(&#160;)</B>, <B>suspend(&#160;)</B>, or <B>wait(&#160;)</B>. But
when it does a <B>read(&#160;)</B> it automatically blocks when there is no more
data.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///:Continuing</font>
<font color=#0000ff>class</font> Sender <font color=#0000ff>extends</font> Blockable { <font color=#009900>// send</font>
  <font color=#0000ff>private</font> Writer out;
  <font color=#0000ff>public</font> Sender(Container c, Writer out) { 
    <font color=#0000ff>super</font>(c);
    <font color=#0000ff>this</font>.out = out; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>for</font>(<font color=#0000ff>char</font> c = 'A'; c &lt;= 'z'; c++) {
        <font color=#0000ff>try</font> {
          i++;
          out.write(c);
          state.setText(<font color=#004488>"Sender sent: "</font> 
            + (<font color=#0000ff>char</font>)c);
          sleep((<font color=#0000ff>int</font>)(3000 * Math.random()));
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        } <font color=#0000ff>catch</font>(IOException e) {
          System.err.println(<font color=#004488>"IO problem"</font>);
        }
      }
    }
  }
}

<font color=#0000ff>class</font> Receiver <font color=#0000ff>extends</font> Blockable {
  <font color=#0000ff>private</font> Reader in;
  <font color=#0000ff>public</font> Receiver(Container c, Reader in) { 
    <font color=#0000ff>super</font>(c);
    <font color=#0000ff>this</font>.in = in; 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
        i++; <font color=#009900>// Show peeker it's alive</font>
        <font color=#009900>// Blocks until characters are there:</font>
        state.setText(<font color=#004488>"Receiver read: "</font>
          + (<font color=#0000ff>char</font>)in.read());
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(<font color=#004488>"IO problem"</font>);
    }
  }
} <font color=#009900>///:Continued</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both classes also put information into
their <B>state</B> fields and change <B>i </B>so the <B>Peeker</B> can see that
the thread is running. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I98' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I99>
</FONT><BR></P></DIV>
<A NAME="Heading499"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Testing</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The main applet class is surprisingly
simple because most of the work has been put into the <B>Blockable</B>
framework. Basically, an array of <B>Blockable</B> objects is created, and since
each one is a thread, they perform their own activities when you press the
&#8220;start&#8221; button. There&#8217;s also a button and
<B>actionPerformed(&#160;)</B> clause to stop all of the <B>Peeker</B> objects,
which provides a demonstration of the alternative to the deprecated (in Java 2)
<B>stop(&#160;)</B> method of <B>Thread</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I99' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I100>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To set up a connection between the
<B>Sender</B> and <B>Receiver</B> objects, a <B>PipedWriter</B> and
<B>PipedReader</B> are created. Note that the <B>PipedReader</B> <B>in </B>must
be connected to the <B>PipedWriter</B> <B>out </B>via a constructor argument.
After that, anything that&#8217;s placed in <B>out</B> can later be extracted
from <B>in</B>, as if it passed through a pipe (hence the name). The <B>in</B>
and <B>out</B> objects are then passed to the <B>Receiver</B> and <B>Sender</B>
constructors, respectively, which treat them as <B>Reader</B> and <B>Writer
</B>objects of any type (that is, they are upcast).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I100' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I101>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The array of <B>Blockable</B> references
<B>b</B> is not initialized at its point of definition because the piped streams
cannot be set up before that definition takes place (the need for the <B>try</B>
block prevents this). </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>///:Continuing</font>
<font color=#009900>/////////// Testing Everything ///////////</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blocking <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> JButton 
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    stopPeekers = <font color=#0000ff>new</font> JButton(<font color=#004488>"Stop Peekers"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> started = <font color=#0000ff>false</font>;
  <font color=#0000ff>private</font> Blockable[] b;
  <font color=#0000ff>private</font> PipedWriter out;
  <font color=#0000ff>private</font> PipedReader in;
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(!started) {
        started = <font color=#0000ff>true</font>;
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
          b[i].start();
      }
    }
  }
  <font color=#0000ff>class</font> StopPeekersL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#009900>// Demonstration of the preferred </font>
      <font color=#009900>// alternative to Thread.stop():</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
        b[i].stopPeeker();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
     Container cp = getContentPane();
     cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
     out = <font color=#0000ff>new</font> PipedWriter();
    <font color=#0000ff>try</font> {
      in = <font color=#0000ff>new</font> PipedReader(out);
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(<font color=#004488>"PipedReader problem"</font>);
    }
    b = <font color=#0000ff>new</font> Blockable[] {
      <font color=#0000ff>new</font> Sleeper1(cp),
      <font color=#0000ff>new</font> Sleeper2(cp),
      <font color=#0000ff>new</font> SuspendResume1(cp),
      <font color=#0000ff>new</font> SuspendResume2(cp),
      <font color=#0000ff>new</font> WaitNotify1(cp),
      <font color=#0000ff>new</font> WaitNotify2(cp),
      <font color=#0000ff>new</font> Sender(cp, out),
      <font color=#0000ff>new</font> Receiver(cp, in)
    };
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    cp.add(start);
    stopPeekers.addActionListener(
      <font color=#0000ff>new</font> StopPeekersL());
    cp.add(stopPeekers);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Blocking(), 350, 550);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>init(&#160;)</B>, notice the loop
that moves through the entire array and adds the <B>state</B> and
<B>peeker.status</B> text fields to the page.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I101' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I102>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the <B>Blockable </B>threads are
initially created, each one automatically creates and starts its own
<B>Peeker</B>. So you&#8217;ll see the <B>Peeker</B>s running before the
<B>Blockable</B> threads are started. This is important, as some of the
<B>Peeker</B>s will get blocked and stop when the <B>Blockable</B> threads
start, and it&#8217;s essential to see this to understand that particular aspect
of blocking.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I102' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I103>
</FONT><A NAME="_Toc375545483"></A><A NAME="_Toc481064858"></A><BR></P></DIV>
<A NAME="Heading500"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Deadlock<BR><A NAME="Index2003"></A><A NAME="Index2004"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because threads can become blocked
<I>and</I> because objects can have <B>synchronized</B> methods that prevent
threads from accessing that object until the synchronization lock is released,
it&#8217;s possible for one thread to get stuck waiting for another thread,
which in turn waits for another thread, etc., until the chain leads back to a
thread waiting on the first one. You get a continuous loop of threads waiting on
each other and no one can move. This is called <I>deadlock</I>. The claim is
that it doesn&#8217;t happen that often, but when it happens to you it&#8217;s
frustrating to debug.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I103' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I104>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is no language support to help
prevent deadlock; it&#8217;s up to you to avoid it by careful design. These are
not comforting words to the person who&#8217;s trying to debug a deadlocking
program. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I104' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I105>
</FONT><BR></P></DIV>
<A NAME="Heading501"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The deprecation of stop(&#160;), suspend(&#160;), <BR>resume(&#160;), and
destroy(&#160;) in Java
2<BR><A NAME="Index2005"></A><A NAME="Index2006"></A><A NAME="Index2007"></A><A NAME="Index2008"></A><A NAME="Index2009"></A><A NAME="Index2010"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One change that has been made in Java 2
to reduce the possibility of deadlock is the deprecation of
<B>Thread</B>&#8217;s <B>stop(&#160;)</B>, <B>suspend(&#160;)</B>,
<B>resume(&#160;)</B>, and <B>destroy(&#160;)</B> methods. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I105' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I106>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index2011"></A><A NAME="Index2012"></A><FONT FACE="Georgia">The
reason that the <B>stop(&#160;)</B> method is deprecated is because it
doesn&#8217;t release the locks that the thread has acquired, and if the objects
are in an inconsistent state (&#8220;damaged&#8221;) other threads can view and
modify them in that state. The resulting problems can be subtle and difficult to
detect. Instead of using <B>stop(&#160;)</B>, you should follow the example in
<B>Blocking.java</B> and use a flag to tell the thread when to terminate itself
by exiting its <B>run(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I106' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I107>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are times when a thread
blocks&#8212;such as when it is waiting for input&#8212;and it cannot poll a
flag as it does in <B>Blocking.java</B>. In these cases, you still
shouldn&#8217;t use <B>stop(&#160;)</B>, but instead you can use the
<A NAME="Index2013"></A><A NAME="Index2014"></A><B>interrupt(&#160;)</B> method
in <A NAME="Index2015"></A><B>Thread</B> to break out of the blocked
code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Interrupt.java</font>
<font color=#009900>// The alternative approach to using </font>
<font color=#009900>// stop() when a thread is blocked.</font>
<font color=#009900>// &lt;applet code=Interrupt width=200 height=100&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>class</font> Blocked <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>try</font> {
      wait(); <font color=#009900>// Blocks</font>
    } <font color=#0000ff>catch</font>(InterruptedException e) {
      System.err.println(<font color=#004488>"Interrupted"</font>);
    }
    System.out.println(<font color=#004488>"Exiting run()"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Interrupt <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> JButton 
    interrupt = <font color=#0000ff>new</font> JButton(<font color=#004488>"Interrupt"</font>);
  <font color=#0000ff>private</font> Blocked blocked = <font color=#0000ff>new</font> Blocked();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    cp.add(interrupt);
    interrupt.addActionListener(
      <font color=#0000ff>new</font> ActionListener() {
        <font color=#0000ff>public</font> 
        <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
          System.out.println(<font color=#004488>"Button pressed"</font>);
          <font color=#0000ff>if</font>(blocked == <font color=#0000ff>null</font>) <font color=#0000ff>return</font>;
          Thread remove = blocked;
          blocked = <font color=#0000ff>null</font>; <font color=#009900>// to release it</font>
          remove.interrupt();
        }
      });
    blocked.start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Interrupt(), 200, 100);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>wait(&#160;)</B> inside
<B>Blocked.run(&#160;)</B> produces the blocked thread. When you press the
button, the <B>blocked</B> reference is set to <B>null</B> so the garbage
collector will clean it up, and then the object&#8217;s <B>interrupt(&#160;)</B>
method is called. The first time you press the button you&#8217;ll see that the
thread quits, but after that there&#8217;s no thread to kill so you just see
that the button has been pressed.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I107' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I108>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index2016"></A><FONT FACE="Georgia">The
<B>suspend(&#160;)</B> and <B>resume(&#160;)</B> methods turn out to be
inherently deadlock-prone. When you call <B>suspend(&#160;)</B>, the target
thread stops but it still holds any locks that it has acquired up to that point.
So no other thread can access the locked resources until the thread is resumed.
Any thread that wants to resume the target thread and also tries to use any of
the locked resources produces deadlock. You should not use
<B>suspend(&#160;)</B> and <B>resume(&#160;)</B>, but instead put a flag in your
<B>Thread</B> class to indicate whether the thread should be active or
suspended. If the flag indicates that the thread is
suspended,<A NAME="Index2017"></A><A NAME="Index2018"></A><A NAME="Index2019"></A><A NAME="Index2020"></A>
the thread goes into a wait using <B>wait(&#160;)</B>. When the flag indicates
that the thread should be resumed the thread is restarted with
<B>notify(&#160;)</B>. An example can be produced by modifying
<B>Counter2.java</B>. Although the effect is similar, you&#8217;ll notice that
the code organization is quite
different&#8212;<A NAME="Index2021"></A><A NAME="Index2022"></A><A NAME="Index2023"></A>anonymous
inner classes are used for all of the listeners and the <B>Thread</B> is an
inner class, which makes programming slightly more convenient since it
eliminates some of the extra bookkeeping necessary in <B>Counter2.java</B>:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I108' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I109>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Suspend.java</font>
<font color=#009900>// The alternative approach to using suspend()</font>
<font color=#009900>// and resume(), which are deprecated in Java 2.</font>
<font color=#009900>// &lt;applet code=Suspend width=300 height=100&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Suspend <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> JTextField t = <font color=#0000ff>new</font> JTextField(10);
  <font color=#0000ff>private</font> JButton 
    suspend = <font color=#0000ff>new</font> JButton(<font color=#004488>"Suspend"</font>),
    resume = <font color=#0000ff>new</font> JButton(<font color=#004488>"Resume"</font>);
  <font color=#0000ff>private</font> Suspendable ss = <font color=#0000ff>new</font> Suspendable();
  <font color=#0000ff>class</font> Suspendable <font color=#0000ff>extends</font> Thread {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> suspended = <font color=#0000ff>false</font>;
    <font color=#0000ff>public</font> Suspendable() { start(); }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> fauxSuspend() { 
      suspended = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>public</font> <font color=#0000ff>synchronized</font> <font color=#0000ff>void</font> fauxResume() {
      suspended = <font color=#0000ff>false</font>;
      notify();
    }
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
      <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
        <font color=#0000ff>try</font> {
          sleep(100);
          <font color=#0000ff>synchronized</font>(<font color=#0000ff>this</font>) {
            <font color=#0000ff>while</font>(suspended)
              wait();
          }
        } <font color=#0000ff>catch</font>(InterruptedException e) {
          System.err.println(<font color=#004488>"Interrupted"</font>);
        }
        t.setText(Integer.toString(count++));
      }
    }
  } 
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    cp.add(t);
    suspend.addActionListener(
      <font color=#0000ff>new</font> ActionListener() {
        <font color=#0000ff>public</font> 
        <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
          ss.fauxSuspend();
        }
      });
    cp.add(suspend);
    resume.addActionListener(
      <font color=#0000ff>new</font> ActionListener() {
        <font color=#0000ff>public</font> 
        <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
          ss.fauxResume();
        }
      });
    cp.add(resume);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Suspend(), 300, 100);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The flag <B>suspended</B> inside
<B>Suspendable</B> is used to turn suspension on and off. To suspend, the flag
is set to <B>true</B> by calling <B>fauxSuspend(&#160;) </B>and this is detected
inside <B>run(&#160;)</B>. The <B>wait(&#160;)</B>, as described earlier in this
chapter, must be <B>synchronized</B> so that it has the object lock. In
<B>fauxResume(&#160;)</B>, the <B>suspended</B> flag is set to <B>false</B> and
<B>notify(&#160;)</B> is called&#8212;since this wakes up <B>wait(&#160;)</B>
inside a <B>synchronized</B> clause the <B>fauxResume(&#160;)</B> method must
also be <B>synchronized</B> so that it acquires the lock before calling
<B>notify(&#160;)</B> (thus the lock is available for the <B>wait(&#160;)</B> to
wake up with). If you follow the style shown in this program you can avoid using
<B>suspend(&#160;)</B> and <B>resume(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I109' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I110>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2024"></A><A NAME="Index2025"></A><B>destroy(&#160;)</B> method of
<B>Thread </B>has never been implemented; it&#8217;s like a
<B>suspend(&#160;)</B> that cannot resume, so it has the same deadlock issues as
<B>suspend(&#160;)</B>. However, this is not a deprecated method and it might be
implemented in a future version of Java (after 2) for special situations in
which the risk of a deadlock is acceptable.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I110' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I111>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder why these methods, now
deprecated, were included in Java in the first place. It seems an admission of a
rather significant mistake to simply remove them outright (and pokes yet another
hole in the arguments for Java&#8217;s exceptional design and infallibility
touted by Sun marketing people). The heartening part about the change is that it
clearly indicates that the technical people and not the marketing people are
running the show&#8212;they discovered a problem and they are fixing it. I find
this much more promising and hopeful than leaving the problem in because
&#8220;fixing it would admit an error.&#8221; It means that Java will continue
to improve, even if it means a little discomfort on the part of Java
programmers. I&#8217;d rather deal with the discomfort than watch the language
stagnate.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I111' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I112>
</FONT><A NAME="_Toc375545484"></A><A NAME="_Toc481064859"></A><BR></P></DIV>
<A NAME="Heading502"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Priorities</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index2026"></A><A NAME="Index2027"></A><I>priority</I> of a thread
tells the scheduler how important this thread is. If there are a number of
threads blocked and waiting to be run, the scheduler will run the one with the
highest priority first. However, this doesn&#8217;t mean that threads with lower
priority don&#8217;t get run (that is, you can&#8217;t get deadlocked because of
priorities). Lower priority threads just tend to run less often.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I112' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I113>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although priorities are interesting to
know about and to play with, in practice you almost never need to set priorities
yourself. So feel free to skip the rest of this section if priorities
aren&#8217;t interesting to you.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I113' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I114>
</FONT><A NAME="_Toc481064860"></A><BR></P></DIV>
<A NAME="Heading503"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Reading and setting priorities</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can read the priority of a thread
with <A NAME="Index2028"></A><A NAME="Index2029"></A><B>getPriority(&#160;)
</B>and change it with
<A NAME="Index2030"></A><A NAME="Index2031"></A><B>setPriority(&#160;)</B>. The
form of the prior &#8220;counter&#8221; examples can be used to show the effect
of changing the priorities. In this applet you&#8217;ll see that the counters
slow down as the associated threads have their priorities
lowered:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:Counter5.java</font>
<font color=#009900>// Adjusting the priorities of threads.</font>
<font color=#009900>// &lt;applet code=Counter5 width=450 height=600&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>class</font> Ticker2 <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> JButton
    b = <font color=#0000ff>new</font> JButton(<font color=#004488>"Toggle"</font>),
    incPriority = <font color=#0000ff>new</font> JButton(<font color=#004488>"up"</font>),
    decPriority = <font color=#0000ff>new</font> JButton(<font color=#004488>"down"</font>);
  <font color=#0000ff>private</font> JTextField
    t = <font color=#0000ff>new</font> JTextField(10),
    pr = <font color=#0000ff>new</font> JTextField(3); <font color=#009900>// Display priority</font>
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> count = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> runFlag = <font color=#0000ff>true</font>;
  <font color=#0000ff>public</font> Ticker2(Container c) {
    b.addActionListener(<font color=#0000ff>new</font> ToggleL());
    incPriority.addActionListener(<font color=#0000ff>new</font> UpL());
    decPriority.addActionListener(<font color=#0000ff>new</font> DownL());
    JPanel p = <font color=#0000ff>new</font> JPanel();
    p.add(t);
    p.add(pr);
    p.add(b);
    p.add(incPriority);
    p.add(decPriority);
    c.add(p);
  }
  <font color=#0000ff>class</font> ToggleL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      runFlag = !runFlag;
    }
  }
  <font color=#0000ff>class</font> UpL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>int</font> newPriority = getPriority() + 1;
      <font color=#0000ff>if</font>(newPriority &gt; Thread.MAX_PRIORITY)
        newPriority = Thread.MAX_PRIORITY;
      setPriority(newPriority);
    }
  }
  <font color=#0000ff>class</font> DownL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>int</font> newPriority = getPriority() - 1;
      <font color=#0000ff>if</font>(newPriority &lt; Thread.MIN_PRIORITY)
        newPriority = Thread.MIN_PRIORITY;
      setPriority(newPriority);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font> (<font color=#0000ff>true</font>) {
      <font color=#0000ff>if</font>(runFlag) {
        t.setText(Integer.toString(count++));
        pr.setText(
          Integer.toString(getPriority()));
      }
      yield();
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Counter5 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> JButton
    start = <font color=#0000ff>new</font> JButton(<font color=#004488>"Start"</font>),
    upMax = <font color=#0000ff>new</font> JButton(<font color=#004488>"Inc Max Priority"</font>),
    downMax = <font color=#0000ff>new</font> JButton(<font color=#004488>"Dec Max Priority"</font>);
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> started = <font color=#0000ff>false</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SIZE = 10;
  <font color=#0000ff>private</font> Ticker2[] s = <font color=#0000ff>new</font> Ticker2[SIZE];
  <font color=#0000ff>private</font> JTextField mp = <font color=#0000ff>new</font> JTextField(3);
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> FlowLayout());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
      s[i] = <font color=#0000ff>new</font> Ticker2(cp);
    cp.add(<font color=#0000ff>new</font> JLabel(
      <font color=#004488>"MAX_PRIORITY = "</font> + Thread.MAX_PRIORITY));
    cp.add(<font color=#0000ff>new</font> JLabel(<font color=#004488>"MIN_PRIORITY = "</font>
      + Thread.MIN_PRIORITY));
    cp.add(<font color=#0000ff>new</font> JLabel(<font color=#004488>"Group Max Priority = "</font>));
    cp.add(mp);
    cp.add(start);
    cp.add(upMax);
    cp.add(downMax);
    start.addActionListener(<font color=#0000ff>new</font> StartL());
    upMax.addActionListener(<font color=#0000ff>new</font> UpMaxL());
    downMax.addActionListener(<font color=#0000ff>new</font> DownMaxL());
    showMaxPriority();
    <font color=#009900>// Recursively display parent thread groups:</font>
    ThreadGroup parent =
      s[0].getThreadGroup().getParent();
    <font color=#0000ff>while</font>(parent != <font color=#0000ff>null</font>) {
      cp.add(<font color=#0000ff>new</font> Label(
        <font color=#004488>"Parent threadgroup max priority = "</font>
        + parent.getMaxPriority()));
      parent = parent.getParent();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> showMaxPriority() {
    mp.setText(Integer.toString(
      s[0].getThreadGroup().getMaxPriority()));
  }
  <font color=#0000ff>class</font> StartL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>if</font>(!started) {
        started = <font color=#0000ff>true</font>;
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; s.length; i++)
          s[i].start();
      }
    }
  }
  <font color=#0000ff>class</font> UpMaxL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>int</font> maxp =
        s[0].getThreadGroup().getMaxPriority();
      <font color=#0000ff>if</font>(++maxp &gt; Thread.MAX_PRIORITY)
        maxp = Thread.MAX_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  <font color=#0000ff>class</font> DownMaxL <font color=#0000ff>implements</font> ActionListener {
    <font color=#0000ff>public</font> <font color=#0000ff>void</font> actionPerformed(ActionEvent e) {
      <font color=#0000ff>int</font> maxp =
        s[0].getThreadGroup().getMaxPriority();
      <font color=#0000ff>if</font>(--maxp &lt; Thread.MIN_PRIORITY)
        maxp = Thread.MIN_PRIORITY;
      s[0].getThreadGroup().setMaxPriority(maxp);
      showMaxPriority();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Console.run(<font color=#0000ff>new</font> Counter5(), 450, 600);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Ticker2</B> follows the form
established earlier in this chapter, but there&#8217;s an extra<B>
JTextField</B> for displaying the priority of the thread and two more buttons
for incrementing and decrementing the priority.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I114' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I115>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Also notice the use of
<B>yield(&#160;)</B>, which voluntarily hands control back to the scheduler.
Without this the multithreading mechanism still works, but you&#8217;ll notice
it runs slowly (try removing the call to <B>yield(&#160;) </B>to see this). You
could also call <B>sleep(&#160;)</B>, but then the rate of counting would be
controlled by the <B>sleep(&#160;)</B> duration instead of the priority.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I115' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I116>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>init(&#160;)</B> in
<B>Counter5</B> creates an array of ten <B>Ticker2</B>s; their buttons and
fields are placed on the form by the <B>Ticker2</B> constructor. <B>Counter5
</B>adds buttons to start everything up as well as increment and decrement the
maximum priority of the thread group. In addition, there are labels that display
the maximum and minimum priorities possible for a thread and a<B> JTextField</B>
to show the thread group&#8217;s maximum priority. (The next section will
describe thread groups.) Finally, the priorities of the parent thread groups are
also displayed as labels.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I116' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I117>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you press an &#8220;up&#8221; or
&#8220;down&#8221; button, that <B>Ticker2</B>&#8217;s priority is fetched and
incremented or decremented accordingly. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I117' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I118>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program, you&#8217;ll
notice several things. First of all, the thread group&#8217;s
<A NAME="Index2032"></A><A NAME="Index2033"></A>default priority is five. Even
if you decrement the maximum priority below five before starting the threads (or
before creating the threads, which requires a code change), each thread will
have a default priority of five.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I118' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I119>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The simple test is to take one counter
and decrement its priority to one, and observe that it counts much slower. But
now try to increment it again. You can get it back up to the thread
group&#8217;s priority, but no higher. Now decrement the thread group&#8217;s
priority a couple of times. The thread priorities are unchanged, but if you try
to modify them either up or down you&#8217;ll see that they&#8217;ll
automatically pop to the priority of the thread group. Also, new threads will
still be given a default priority, even if that&#8217;s higher than the group
priority. (Thus the group priority is not a way to prevent new threads from
having higher priorities than existing ones.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I119' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I120>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, try to increment the group
maximum priority. It can&#8217;t be done. You can only reduce thread group
maximum priorities, not increase them.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I120' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I121>
</FONT><A NAME="_Toc375545485"></A><A NAME="_Toc481064861"></A><BR></P></DIV>
<A NAME="Heading504"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Thread groups</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All threads belong to a
<A NAME="Index2034"></A>thread group. This can be either the default thread
group or a group you explicitly specify when you create the thread. At creation,
the thread is bound to a group and cannot change to a different group. Each
application has at least one thread that belongs to the system thread group. If
you create more threads without specifying a group, they will also belong to the
system thread group.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I121' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I122>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thread groups must also belong to other
thread groups. The thread group that a new one belongs to must be specified in
the constructor. If you create a thread group without specifying a thread group
for it to belong to, it will be placed under the system thread group. Thus, all
thread groups in your application will ultimately have the system thread group
as the parent. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I122' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I123>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason for the existence of thread
groups is hard to determine from the literature, which tends to be confusing on
this subject. It&#8217;s often cited as &#8220;security reasons.&#8221;
According to Arnold &amp;
Gosling,</FONT><A NAME="fnB71" HREF="#fn71">[71]</A><FONT FACE="Georgia">
&#8220;Threads within a thread group can modify the other threads in the group,
including any farther down the hierarchy. A thread cannot modify threads outside
of its own group or contained groups.&#8221; It&#8217;s hard to know what
&#8220;modify&#8221; is supposed to mean here. The following example shows a
thread in a &#8220;leaf&#8221; subgroup modifying the priorities of all the
threads in its tree of thread groups as well as calling a method for all the
threads in its tree.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:TestAccess.java</font>
<font color=#009900>// How threads can access other threads</font>
<font color=#009900>// in a parent thread group.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestAccess {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ThreadGroup 
      x = <font color=#0000ff>new</font> ThreadGroup(<font color=#004488>"x"</font>),
      y = <font color=#0000ff>new</font> ThreadGroup(x, <font color=#004488>"y"</font>),
      z = <font color=#0000ff>new</font> ThreadGroup(y, <font color=#004488>"z"</font>);
    Thread
      one = <font color=#0000ff>new</font> TestThread1(x, <font color=#004488>"one"</font>),
      two = <font color=#0000ff>new</font> TestThread2(z, <font color=#004488>"two"</font>);
  }
}

<font color=#0000ff>class</font> TestThread1 <font color=#0000ff>extends</font> Thread {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  TestThread1(ThreadGroup g, String name) {
    <font color=#0000ff>super</font>(g, name);
  }
  <font color=#0000ff>void</font> f() {
    i++; <font color=#009900>// modify this thread</font>
    System.out.println(getName() + <font color=#004488>" f()"</font>);
  }
}

<font color=#0000ff>class</font> TestThread2 <font color=#0000ff>extends</font> TestThread1 {
  TestThread2(ThreadGroup g, String name) {
    <font color=#0000ff>super</font>(g, name);
    start();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    ThreadGroup g =
      getThreadGroup().getParent().getParent();
    g.list();
    Thread[] gAll = <font color=#0000ff>new</font> Thread[g.activeCount()];
    g.enumerate(gAll);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; gAll.length; i++) {
      gAll[i].setPriority(Thread.MIN_PRIORITY);
      ((TestThread1)gAll[i]).f();
    }
    g.list();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, several
<B>ThreadGroup</B>s are created, leafing off from each other: <B>x</B> has no
argument but its name (a <B>String</B>), so it is automatically placed in the
&#8220;system&#8221; thread group, while <B>y</B> is under <B>x</B> and <B>z</B>
is under <B>y</B>. Note that initialization happens in textual order so this
code is legal. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I123' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I124>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two threads are created and placed in
different thread groups. <B>TestThread1</B> doesn&#8217;t have a
<B>run(&#160;)</B> method but it does have an <B>f(&#160;)</B> that modifies the
thread and prints something so you can see it was called. <B>TestThread2</B> is
a subclass of <B>TestThread1</B> and its <B>run(&#160;)</B> is fairly elaborate.
It first gets the thread group of the current thread, then moves up the heritage
tree by two levels using <B>getParent(&#160;)</B>. (This is contrived since I
purposely place the <B>TestThread2</B> object two levels down in the hierarchy.)
At this point, an array of references to <B>Thread</B>s is created using the
method <B>activeCount(&#160;)</B> to ask how many threads are in this thread
group and all the child thread groups. The <B>enumerate(&#160;)</B> method
places references to all of these threads in the array <B>gAll</B>, then I
simply move through the entire array calling the <B>f(&#160;)</B> method for
each thread, as well as modifying the priority. Thus, a thread in a
&#8220;leaf&#8221; thread group modifies threads in parent thread groups.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I124' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I125>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The debugging method <B>list(&#160;)</B>
prints all the information about a thread group to standard output and is
helpful when investigating thread group behavior. Here&#8217;s the output of the
program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,5,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,5,z]
one f()
two f()
java.lang.ThreadGroup[name=x,maxpri=10]
    Thread[one,1,x]
    java.lang.ThreadGroup[name=y,maxpri=10]
        java.lang.ThreadGroup[name=z,maxpri=10]
            Thread[two,1,z]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Not only does <B>list(&#160;)</B> print
the class name of <B>ThreadGroup</B> or <B>Thread</B>, but it also prints the
thread group name and its maximum priority. For threads, the thread name is
printed, followed by the thread priority and the group that it belongs to. Note
that <B>list(&#160;)</B> indents the threads and thread groups to indicate that
they are children of the unindented thread group.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I125' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I126>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that <B>f(&#160;)</B> is
called by the <B>TestThread2</B> <B>run(&#160;)</B> method, so it&#8217;s
obvious that all threads in a group are vulnerable. However, you can access only
the threads that branch off from your own <B>system</B> thread group tree, and
perhaps this is what is meant by &#8220;safety.&#8221; You cannot access anyone
else&#8217;s system thread group tree.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I126' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I127>
</FONT><BR></P></DIV>
<A NAME="Heading505"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Controlling thread groups</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Putting aside the safety issue, one thing
thread groups seem to be useful for is control: you can perform certain
operations on an entire thread group with a single command. The following
example demonstrates this, and the restrictions on priorities within thread
groups. The commented numbers in parentheses provide a reference to compare to
the output.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:ThreadGroup1.java</font>
<font color=#009900>// How thread groups control priorities</font>
<font color=#009900>// of the threads inside them.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThreadGroup1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Get the system thread &amp; print its Info:</font>
    ThreadGroup sys = 
      Thread.currentThread().getThreadGroup();
    sys.list(); <font color=#009900>// (1)</font>
    <font color=#009900>// Reduce the system thread group priority:</font>
    sys.setMaxPriority(Thread.MAX_PRIORITY - 1);
    <font color=#009900>// Increase the main thread priority:</font>
    Thread curr = Thread.currentThread();
    curr.setPriority(curr.getPriority() + 1);
    sys.list(); <font color=#009900>// (2)</font>
    <font color=#009900>// Attempt to set a new group to the max:</font>
    ThreadGroup g1 = <font color=#0000ff>new</font> ThreadGroup(<font color=#004488>"g1"</font>);
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    <font color=#009900>// Attempt to set a new thread to the max:</font>
    Thread t = <font color=#0000ff>new</font> Thread(g1, <font color=#004488>"A"</font>);
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); <font color=#009900>// (3)</font>
    <font color=#009900>// Reduce g1's max priority, then attempt</font>
    <font color=#009900>// to increase it:</font>
    g1.setMaxPriority(Thread.MAX_PRIORITY - 2);
    g1.setMaxPriority(Thread.MAX_PRIORITY);
    g1.list(); <font color=#009900>// (4)</font>
    <font color=#009900>// Attempt to set a new thread to the max:</font>
    t = <font color=#0000ff>new</font> Thread(g1, <font color=#004488>"B"</font>);
    t.setPriority(Thread.MAX_PRIORITY);
    g1.list(); <font color=#009900>// (5)</font>
    <font color=#009900>// Lower the max priority below the default</font>
    <font color=#009900>// thread priority:</font>
    g1.setMaxPriority(Thread.MIN_PRIORITY + 2);
    <font color=#009900>// Look at a new thread's priority before</font>
    <font color=#009900>// and after changing it:</font>
    t = <font color=#0000ff>new</font> Thread(g1, <font color=#004488>"C"</font>);
    g1.list(); <font color=#009900>// (6)</font>
    t.setPriority(t.getPriority() -1);
    g1.list(); <font color=#009900>// (7)</font>
    <font color=#009900>// Make g2 a child Threadgroup of g1 and</font>
    <font color=#009900>// try to increase its priority:</font>
    ThreadGroup g2 = <font color=#0000ff>new</font> ThreadGroup(g1, <font color=#004488>"g2"</font>);
    g2.list(); <font color=#009900>// (8)</font>
    g2.setMaxPriority(Thread.MAX_PRIORITY);
    g2.list(); <font color=#009900>// (9)</font>
    <font color=#009900>// Add a bunch of new threads to g2:</font>
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      <font color=#0000ff>new</font> Thread(g2, Integer.toString(i));
    <font color=#009900>// Show information about all threadgroups</font>
    <font color=#009900>// and threads:</font>
    sys.list(); <font color=#009900>// (10)</font>
    System.out.println(<font color=#004488>"Starting all threads:"</font>);
    Thread[] all = <font color=#0000ff>new</font> Thread[sys.activeCount()];
    sys.enumerate(all);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; all.length; i++)
      <font color=#0000ff>if</font>(!all[i].isAlive())
        all[i].start();
    <font color=#009900>// Suspends &amp; Stops all threads in </font>
    <font color=#009900>// this group and its subgroups:</font>
    System.out.println(<font color=#004488>"All threads started"</font>);
    sys.suspend(); <font color=#009900>// Deprecated in Java 2</font>
    <font color=#009900>// Never gets here...</font>
    System.out.println(<font color=#004488>"All threads suspended"</font>);
    sys.stop(); <font color=#009900>// Deprecated in Java 2</font>
    System.out.println(<font color=#004488>"All threads stopped"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output that follows has been edited
to allow it to fit on the page (the <B>java.lang.</B> has been removed) and to
add numbers to correspond to the commented numbers in the listing above.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I127' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I128>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]
(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]
(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]
(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]
(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]
(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]
(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]
Starting all threads:
All threads started</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All programs have at least one thread
running, and the first action in <B>main(&#160;)</B> is to call the
<B>static</B> method of <B>Thread</B> called <B>currentThread(&#160;)</B>. From
this thread, the thread group is produced and <B>list(&#160;)</B> is called for
the result. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(1) ThreadGroup[name=system,maxpri=10]
      Thread[main,5,system]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the name of the main
thread group is <B>system</B>, and the name of the main thread is <B>main</B>,
and it belongs to the <B>system</B> thread group.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I128' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I129>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second exercise shows that the
<B>system</B> group&#8217;s maximum priority can be reduced and the <B>main</B>
thread can have its priority increased:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(2) ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The third exercise creates a new thread
group, <B>g1</B>, which automatically belongs to the <B>system</B> thread group
since it isn&#8217;t otherwise specified. A new thread <B>A </B>is placed in
<B>g1</B>. After attempting to set this group&#8217;s maximum priority to the
highest level and <B>A</B>&#8217;s priority to the highest level, the result
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(3) ThreadGroup[name=g1,maxpri=9]
      Thread[A,9,g1]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, it&#8217;s not possible to change
the thread group&#8217;s maximum priority to be higher than its parent thread
group. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I129' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I130>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fourth exercise reduces
<B>g1</B>&#8217;s maximum priority by two and then tries to increase it up to
<B>Thread.MAX_PRIORITY</B>. The result is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(4) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the increase in maximum
priority didn&#8217;t work. You can only decrease a thread group&#8217;s maximum
priority, not increase it. Also, notice that thread <B>A</B>&#8217;s priority
didn&#8217;t change, and now it is higher than the thread group&#8217;s maximum
priority. Changing a thread group&#8217;s maximum priority doesn&#8217;t affect
existing threads. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I130' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I131>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fifth exercise attempts to set a new
thread to maximum priority:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(5) ThreadGroup[name=g1,maxpri=8]
      Thread[A,9,g1]
      Thread[B,8,g1]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The new thread cannot be changed to
anything higher than the maximum thread group priority.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I131' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I132>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default thread priority for this
program is six; that&#8217;s the priority a new thread will be created at and
where it will stay if you don&#8217;t manipulate the priority. Exercise 6 lowers
the maximum thread group priority below the default thread priority to see what
happens when you create a new thread under this condition:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(6) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,6,g1]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though the maximum priority of the
thread group is three, the new thread is still created using the default
priority of six. Thus, maximum thread group priority does not affect default
priority. (In fact, there appears to be no way to set the default priority for
new threads.) 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I132' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I133>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After changing the priority, attempting
to decrement it by one, the result is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(7) ThreadGroup[name=g1,maxpri=3]
      Thread[A,9,g1]
      Thread[B,8,g1]
      Thread[C,3,g1]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Only when you attempt to change the
priority is the thread group&#8217;s maximum priority enforced.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I133' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I134>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A similar experiment is performed in (8)
and (9), in which a new thread group <B>g2 </B>is created as a child of
<B>g1</B> and its maximum priority is changed. You can see that it&#8217;s
impossible for <B>g2</B>&#8217;s maximum to go higher than
<B>g1</B>&#8217;s:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(8) ThreadGroup[name=g2,maxpri=3]
(9) ThreadGroup[name=g2,maxpri=3]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Also notice that <B>g2</B> is
automatically set to the thread group maximum priority of <B>g1</B> as <B>g2</B>
is created. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I134' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I135>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After all of these experiments, the
entire system of thread groups and threads is printed:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(10)ThreadGroup[name=system,maxpri=9]
      Thread[main,6,system]
      ThreadGroup[name=g1,maxpri=3]
        Thread[A,9,g1]
        Thread[B,8,g1]
        Thread[C,3,g1]
        ThreadGroup[name=g2,maxpri=3]
          Thread[0,6,g2]
          Thread[1,6,g2]
          Thread[2,6,g2]
          Thread[3,6,g2]
          Thread[4,6,g2]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So because of the rules of thread groups,
a child group must always have a maximum priority that&#8217;s less than or
equal to its parent&#8217;s maximum priority.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I135' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I136>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last part of this program
demonstrates methods for an entire group of threads. First the program moves
through the entire tree of threads and starts each one that hasn&#8217;t been
started. For drama, the <B>system</B> group is then suspended and finally
stopped. (Although it&#8217;s interesting to see that <B>suspend(&#160;)</B> and
<B>stop(&#160;)</B> work on entire thread groups, you should keep in mind that
these methods are deprecated in Java 2.) But when you suspend the <B>system</B>
group you also suspend the <B>main</B> thread and the whole program shuts down,
so it never gets to the point where the threads are stopped. Actually, if you do
stop the <B>main</B> thread it throws a <B>ThreadDeath</B> exception, so this is
not a typical thing to do. Since <B>ThreadGroup</B> is inherited from
<B>Object,</B> which contains the <B>wait(&#160;)</B> method, you can also
choose to suspend the program for any number of seconds by calling
<B>wait(seconds * 1000)</B>. This must acquire the lock inside a synchronized
block, of course. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I136' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I137>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>ThreadGroup</B> class also has
<B>suspend(&#160;)</B> and <B>resume(&#160;)</B> methods so you can stop and
start an entire thread group and all of its threads and subgroups with a single
command. (Again, <B>suspend(&#160;)</B> and <B>resume(&#160;)</B> are deprecated
in Java 2.) 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I137' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I138>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thread groups can seem a bit mysterious
at first, but keep in mind that you probably won&#8217;t be using them directly
very often.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I138' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I139>
</FONT><A NAME="_Toc375545486"></A><A NAME="_Toc481064862"></A><BR></P></DIV>
<A NAME="Heading506"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Runnable revisited</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Earlier in this chapter, I suggested that
you think carefully before making an applet or main <B>Frame</B> as an
implementation of
<A NAME="Index2035"></A><A NAME="Index2036"></A><A NAME="Index2037"></A><B>Runnable</B>.
Of course, if you must inherit from a class <I>and</I> you want to add threading
behavior to the class, <B>Runnable</B> is the correct solution. The final
example in this chapter exploits this by making a <B>Runnable</B> <B>JPanel</B>
class that paints different colors on itself. This application is set up to take
values from the command line to determine how big the grid of colors is and how
long to <B>sleep(&#160;)</B> between color changes. By playing with these values
you&#8217;ll discover some interesting and possibly inexplicable features of
threads:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:ColorBoxes.java</font>
<font color=#009900>// Using the Runnable interface.</font>
<font color=#009900>// &lt;applet code=ColorBoxes width=500 height=400&gt;</font>
<font color=#009900>// &lt;param name=grid value="12"&gt;</font>
<font color=#009900>// &lt;param name=pause value="50"&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>class</font> CBox <font color=#0000ff>extends</font> JPanel <font color=#0000ff>implements</font> Runnable {
  <font color=#0000ff>private</font> Thread t;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> pause;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Color[] colors = { 
    Color.black, Color.blue, Color.cyan, 
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta, 
    Color.orange, Color.pink, Color.red, 
    Color.white, Color.yellow 
  };
  <font color=#0000ff>private</font> Color cColor = newColor();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Color newColor() {
    <font color=#0000ff>return</font> colors[
      (<font color=#0000ff>int</font>)(Math.random() * colors.length)
    ];
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paintComponent(Graphics  g) {
    <font color=#0000ff>super</font>.paintComponent(g);
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
  <font color=#0000ff>public</font> CBox(<font color=#0000ff>int</font> pause) {
    <font color=#0000ff>this</font>.pause = pause;
    t = <font color=#0000ff>new</font> Thread(<font color=#0000ff>this</font>);
    t.start(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      cColor = newColor();
      repaint();
      <font color=#0000ff>try</font> {
        t.sleep(pause);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    } 
  }
} 

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ColorBoxes <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isApplet = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> grid = 12;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> pause = 50;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    <font color=#009900>// Get parameters from Web page:</font>
    <font color=#0000ff>if</font> (isApplet) {
      String gsize = getParameter(<font color=#004488>"grid"</font>);
      <font color=#0000ff>if</font>(gsize != <font color=#0000ff>null</font>)
        grid = Integer.parseInt(gsize);
      String pse = getParameter(<font color=#004488>"pause"</font>);
      <font color=#0000ff>if</font>(pse != <font color=#0000ff>null</font>)
        pause = Integer.parseInt(pse);
    }
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> GridLayout(grid, grid));
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; grid * grid; i++)
      cp.add(<font color=#0000ff>new</font> CBox(pause));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ColorBoxes applet = <font color=#0000ff>new</font> ColorBoxes();
    applet.isApplet = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args.length &gt; 0)
      applet.grid = Integer.parseInt(args[0]);
    <font color=#0000ff>if</font>(args.length &gt; 1) 
      applet.pause = Integer.parseInt(args[1]);
    Console.run(applet, 500, 400);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ColorBoxes</B> is the usual
applet/application with an <B>init(&#160;) </B>that sets up the GUI. This sets
up the <A NAME="Index2038"></A><B>GridLayout</B> so that it has <B>grid</B>
cells in each dimension. Then it adds the appropriate number of <B>CBox</B>
objects to fill the grid, passing the <B>pause</B> value to each one. In
<B>main(&#160;)</B> you can see how <B>pause</B> and <B>grid</B> have default
values that can be changed if you pass in command-line arguments, or by using
applet parameters. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I139' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I140>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CBox </B>is where all the work takes
place. This is inherited from <A NAME="Index2039"></A><B>JPanel</B> and it
implements the <B>Runnable</B> interface so each <B>JPanel</B> can also be a
<B>Thread</B>. Remember that when you implement <B>Runnable</B>, you don&#8217;t
make a <B>Thread</B> object, just a class that has a <B>run(&#160;)</B> method.
Thus, you must explicitly create a <B>Thread</B> object and hand the
<B>Runnable</B> object to the constructor, then call <B>start(&#160;)</B> (this
happens in the constructor). In <B>CBox</B> this thread is called <B>t</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I140' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I141>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice the array <B>colors</B>, which is
an enumeration of all the colors in class <B>Color</B>. This is used in
<B>newColor(&#160;)</B> to produce a randomly selected color. The current cell
color is <B>cColor</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I141' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I142>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>paintComponent(&#160;)</B> is quite
simple&#8212;it just sets the color to <B>cColor</B> and fills the entire
<B>JPanel</B> with that color.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I142' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I143>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>run(&#160;)</B>, you see the
infinite loop that sets the <B>cColor</B> to a new random color and then calls
<B>repaint(&#160;)</B> to show it. Then the thread goes to <B>sleep(&#160;)</B>
for the amount of time specified on the command line.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I143' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I144>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Precisely because this design is flexible
and threading is tied to each <B>JPanel</B> element, you can experiment by
making as many threads as you want. (In reality, there is a restriction imposed
by the number of threads your JVM can comfortably handle.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I144' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I145>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program also makes an interesting
benchmark, since it can show dramatic performance differences between one JVM
threading implementation and another.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I145' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I146>
</FONT><A NAME="_Toc375545487"></A><A NAME="_Toc481064863"></A><BR></P></DIV>
<A NAME="Heading507"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Too many threads</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At some point, you&#8217;ll find that
<B>ColorBoxes</B> bogs down. On my machine, this occurred somewhere after a 10 x
10 grid. Why does this happen? You&#8217;re naturally suspicious that Swing
might have something to do with it, so here&#8217;s an example that tests that
premise by making fewer threads. The following code is reorganized so that an
<B>ArrayList</B> <B>implements Runnable</B> and that <B>ArrayList</B> holds a
number of color blocks and randomly chooses ones to update. Then a number of
these <B>ArrayList</B> objects are created, depending roughly on the grid
dimension you choose. As a result, you have far fewer threads than color blocks,
so if there&#8217;s a speedup we&#8217;ll know it was because there were too
many threads in the previous example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c14:ColorBoxes2.java</font>
<font color=#009900>// Balancing thread use.</font>
<font color=#009900>// &lt;applet code=ColorBoxes2 width=600 height=500&gt;</font>
<font color=#009900>// &lt;param name=grid value="12"&gt;</font>
<font color=#009900>// &lt;param name=pause value="50"&gt;</font>
<font color=#009900>// &lt;/applet&gt;</font>
<font color=#0000ff>import</font> javax.swing.*;
<font color=#0000ff>import</font> java.awt.*;
<font color=#0000ff>import</font> java.awt.event.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.swing.*;

<font color=#0000ff>class</font> CBox2 <font color=#0000ff>extends</font> JPanel {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Color[] colors = { 
    Color.black, Color.blue, Color.cyan, 
    Color.darkGray, Color.gray, Color.green,
    Color.lightGray, Color.magenta, 
    Color.orange, Color.pink, Color.red, 
    Color.white, Color.yellow 
  };
  <font color=#0000ff>private</font> Color cColor = newColor();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> Color newColor() {
    <font color=#0000ff>return</font> colors[
      (<font color=#0000ff>int</font>)(Math.random() * colors.length)
    ];
  }
  <font color=#0000ff>void</font> nextColor() {
    cColor = newColor();
    repaint();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> paintComponent(Graphics g) {
    <font color=#0000ff>super</font>.paintComponent(g);
    g.setColor(cColor);
    Dimension s = getSize();
    g.fillRect(0, 0, s.width, s.height);
  }
}

<font color=#0000ff>class</font> CBoxList 
  <font color=#0000ff>extends</font> ArrayList <font color=#0000ff>implements</font> Runnable {
  <font color=#0000ff>private</font> Thread t;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> pause;
  <font color=#0000ff>public</font> CBoxList(<font color=#0000ff>int</font> pause) {
    <font color=#0000ff>this</font>.pause = pause;
    t = <font color=#0000ff>new</font> Thread(<font color=#0000ff>this</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> go() { t.start(); }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> run() {
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>int</font> i = (<font color=#0000ff>int</font>)(Math.random() * size());
      ((CBox2)get(i)).nextColor();
      <font color=#0000ff>try</font> {
        t.sleep(pause);
      } <font color=#0000ff>catch</font>(InterruptedException e) {
        System.err.println(<font color=#004488>"Interrupted"</font>);
      }
    } 
  }
  <font color=#0000ff>public</font> Object last() { <font color=#0000ff>return</font> get(size() - 1);}
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ColorBoxes2 <font color=#0000ff>extends</font> JApplet {
  <font color=#0000ff>private</font> <font color=#0000ff>boolean</font> isApplet = <font color=#0000ff>true</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> grid = 12;
  <font color=#009900>// Shorter default pause than ColorBoxes:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> pause = 50;
  <font color=#0000ff>private</font> CBoxList[] v;
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> init() {
    <font color=#009900>// Get parameters from Web page:</font>
    <font color=#0000ff>if</font> (isApplet) {
      String gsize = getParameter(<font color=#004488>"grid"</font>);
      <font color=#0000ff>if</font>(gsize != <font color=#0000ff>null</font>)
        grid = Integer.parseInt(gsize);
      String pse = getParameter(<font color=#004488>"pause"</font>);
      <font color=#0000ff>if</font>(pse != <font color=#0000ff>null</font>)
        pause = Integer.parseInt(pse);
    }
    Container cp = getContentPane();
    cp.setLayout(<font color=#0000ff>new</font> GridLayout(grid, grid));
    v = <font color=#0000ff>new</font> CBoxList[grid];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; grid; i++)
      v[i] = <font color=#0000ff>new</font> CBoxList(pause);
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; grid * grid; i++) {
      v[i % grid].add(<font color=#0000ff>new</font> CBox2());
      cp.add((CBox2)v[i % grid].last());
    }
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; grid; i++)
      v[i].go();
  }   
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ColorBoxes2 applet = <font color=#0000ff>new</font> ColorBoxes2();
    applet.isApplet = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args.length &gt; 0)
      applet.grid = Integer.parseInt(args[0]);
    <font color=#0000ff>if</font>(args.length &gt; 1) 
      applet.pause = Integer.parseInt(args[1]);
    Console.run(applet, 500, 400);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>ColorBoxes2</B> an array of
<B>CBoxList</B> is created and initialized to hold <B>grid</B> <B>CBoxList</B>s,
each of which knows how long to sleep. An equal number of <B>CBox2</B> objects
is then added to each <B>CBoxList</B>, and each list is told to
<B>go(&#160;)</B>, which starts its thread.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I146' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I147>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CBox2</B> is similar to <B>CBox</B>:
it paints itself with a randomly chosen color. But that&#8217;s <I>all</I> a
<B>CBox2</B> does. All of the threading has been moved into <B>CBoxList</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I147' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I148>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>CBoxList</B> could also have
inherited <B>Thread</B> and had a member object of type <B>ArrayList</B>. That
design has the advantage that the <B>add(&#160;)</B> and <B>get(&#160;)</B>
methods could then be given specific argument and return value types instead of
generic <B>Object</B>s. (Their names could also be changed to something
shorter.) However, the design used here seemed at first glance to require less
code. In addition, it automatically retains all the other behaviors of an
<B>ArrayList</B>. With all the casting and parentheses necessary for
<B>get(&#160;)</B>, this might not be the case as your body of code grows.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I148' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I149>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As before, when you implement
<B>Runnable</B> you don&#8217;t get all of the equipment that comes with
<B>Thread</B>, so you have to create a new <B>Thread</B> and hand yourself to
its constructor in order to have something to <B>start(&#160;)</B>, as you can
see in the <B>CBoxList</B> constructor and in <B>go(&#160;)</B>. The
<B>run(&#160;)</B> method simply chooses a random element number within the list
and calls <B>nextColor(&#160;)</B> for that element to cause it to choose a new
randomly selected color. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I149' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I150>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Upon running this program, you see that
it does indeed run faster and respond more quickly (for instance, when you
interrupt it, it stops more quickly), and it doesn&#8217;t seem to bog down as
much at higher grid sizes. Thus, a new factor is added into the threading
equation: you must watch to see that you don&#8217;t have &#8220;too many
threads&#8221; (whatever that turns out to mean for your particular program and
platform&#8212;here, the slowdown in <B>ColorBoxes</B> appears to be caused by
the fact that there&#8217;s only one thread that is responsible for all
painting, and it gets bogged down by too many requests). If you have too many
threads, you must try to use techniques like the one above to
&#8220;balance&#8221; the number of threads in your program. If you see
performance problems in a multithreaded program you now have a number of issues
to examine: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I150' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I151>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Do you have enough calls
to <B>sleep(&#160;)</B>, <B>yield(&#160;),</B> and/or
<B>wait(&#160;)</B>?</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Are
calls to <B>sleep(&#160;)</B> long
enough?</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Are you
running too many
threads?</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Have you
tried different platforms and
JVMs?</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Issues like this are one
reason that multithreaded programming is often considered an art.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I151' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I152>
</FONT><A NAME="_Toc375545489"></A><A NAME="_Toc481064864"></A><BR></P></DIV>
<A NAME="Heading508"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is vital to learn when to use
<A NAME="Index2040"></A><A NAME="Index2041"></A>multithreading and when to avoid
it. The main reason to use it is to manage a number of tasks whose intermingling
will make more efficient use of the computer (including the ability to
transparently distribute the tasks across multiple CPUs) or be more convenient
for the user. The classic example of resource balancing is using the CPU during
I/O waits. The classic example of user convenience is monitoring a
&#8220;stop&#8221; button during long downloads.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I152' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I153>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The main drawbacks to multithreading are:
<A NAME="Index2042"></A><A NAME="Index2043"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Slowdown while waiting for
shared
resources</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Additional
CPU overhead required to manage
threads</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Unrewarded
complexity, such as the silly idea of having a separate thread to update each
element of an
array</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Pathologies
including starving, racing, and
deadlock</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An additional
advantage to threads is that they substitute &#8220;light&#8221; execution
context switches (of the order of 100 instructions) for &#8220;heavy&#8221;
process context switches (of the order of 1000s of instructions). Since all
threads in a given process share the same memory space, a light context switch
changes only program execution and local variables. On the other hand, a process
change&#8212;the heavy context switch&#8212;must exchange the full memory space.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I153' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I154>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Threading is like stepping into an
entirely new world and learning a whole new programming language, or at least a
new set of language concepts. With the appearance of thread support in most
microcomputer operating systems, extensions for threads have also been appearing
in programming languages or libraries. In all cases, thread programming (1)
seems mysterious and requires a shift in the way you think about programming;
and (2) looks similar to thread support in other languages, so when you
understand threads, you understand a common tongue. And although support for
threads can make Java seem like a more complicated language, don&#8217;t blame
Java. Threads are tricky.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I154' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I155>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the biggest difficulties with
threads occurs because more than one thread might be sharing a
resource&#8212;such as the memory in an object&#8212;and you must make sure that
multiple threads don&#8217;t try to read and change that resource at the same
time. This requires judicious use of the <B>synchronized</B> keyword, which is a
helpful tool but must be understood thoroughly because it can quietly introduce
deadlock situations. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I155' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I156>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, there&#8217;s a certain art
to the application of threads. Java is designed to allow you to create as many
objects as you need to solve your problem&#8212;at least in theory. (Creating
millions of objects for an engineering finite-element analysis, for example,
might not be practical in Java.) However, it seems that there is an upper bound
to the number of threads you&#8217;ll want to create, because at some point a
large number of threads seems to become unwieldy. This critical point is not in
the many thousands as it might be with objects, but rather in the low hundreds,
sometimes less than 100. As you often create only a handful of threads to solve
a problem, this is typically not much of a limit, yet in a more general design
it becomes a constraint. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I156' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I157>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A significant nonintuitive issue in
threading is that, because of thread scheduling, you can typically make your
applications run <I>faster</I> by inserting calls to <B>sleep(&#160;)</B> inside
<B>run(&#160;)</B>&#8217;s main loop. This definitely makes it feel like an art,
in particular when the longer delays seem to speed up performance. Of course,
the reason this happens is that shorter delays can cause the
end-of-<B>sleep(&#160;)</B> scheduler interrupt to happen before the running
thread is ready to go to sleep, forcing the scheduler to stop it and restart it
later so it can finish what it was doing and then go to sleep. It takes extra
thought to realize how messy things can get.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I157' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I158>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing you might notice missing in
this chapter is an animation example, which is one of the most popular things to
do with applets. However, a complete solution (with sound) to this problem comes
with the Java JDK (available at <I>java.sun.com</I>) in the demo section. In
addition, we can expect better animation support to become part of future
versions of Java, while completely different non-Java, non-programming solutions
to animation for the Web are appearing that will probably be superior to
traditional approaches. For explanations about how Java animation works, see
<I>Core Java 2</I> by Horstmann &amp; Cornell, Prentice-Hall, 1997. For more
advanced discussions of threading, see <I>Concurrent Programming in Java</I> by
Doug Lea, Addison-Wesley, 1997, or <I>Java Threads</I> by Oaks &amp; Wong,
O&#8217;Reilly, 1997.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I158' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I159>
</FONT><A NAME="_Toc375545490"></A><A NAME="_Toc481064865"></A><BR></P></DIV>
<A NAME="Heading509"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=2>Solutions to selected exercises
can be found in the electronic document <I>The Thinking in Java Annotated
Solution Guide</I>, available for a small fee from
<I>www.BruceEckel.com</I>.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Inherit a class from
<B>Thread</B> and override the <B>run(&#160;)</B> method. Inside
<B>run(&#160;)</B>, print a message, and then call <B>sleep(&#160;)</B>. Repeat
this three times, then return from <B>run(&#160;)</B>. Put a start-up message in
the constructor and override <B>finalize(&#160;)</B> to print a shut-down
message. Make a separate thread class that calls <B>System.gc(&#160;)</B> and
<B>System.runFinalization(&#160;) </B>inside <B>run(&#160;)</B>, printing a
message as it does so. Make several thread objects of both types and run them to
see what happens.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I159' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I160>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Sharing2.java</B> to add a <B>synchronized</B> block inside the
<B>run(&#160;)</B> method of <B>TwoCounter</B> instead of synchronizing the
entire <B>run(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I160' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I161>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
two <B>Thread</B> subclasses, one with a <B>run(&#160;)</B> that starts up,
captures the reference of the second <B>Thread</B> object and then calls
<B>wait(&#160;)</B>. The other class&#8217; <B>run(&#160;)</B> should call
<B>notifyAll(&#160;)</B> for the first thread after some number of seconds have
passed, so the first thread can print a message.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I161' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I162>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
<B>Counter5.java</B> inside <B>Ticker2</B>, remove the <B>yield(&#160;)</B> and
explain the results. Replace the <B>yield(&#160;)</B> with a
<B>sleep(&#160;)</B> and explain the results.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I162' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I163>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
<B>ThreadGroup1.java</B>, replace the call to <B>sys.suspend(&#160;)</B> with a
call to <B>wait(&#160;)</B> for the thread group, causing it to wait for two
seconds. For this to work correctly you must acquire the lock for <B>sys
</B>inside a <B>synchronized</B> block.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I163' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I164>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Change
<B>Daemons.java</B> so that <B>main(&#160;)</B> has a <B>sleep(&#160;)</B>
instead of a <B>readLine(&#160;)</B>. Experiment with different sleep times to
see what happens.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I164' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I165>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
Chapter 8, locate the <B>GreenhouseControls.java</B> example, which consists of
three files. In <B>Event.java</B>, the class <B>Event</B> is based on watching
the time. Change <B>Event</B> so that it is a <B>Thread</B>, and change the rest
of the design so that it works with this new <B>Thread</B>-based <B>Event</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I165' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I166>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 7 so that the <B>java.util.Timer</B> class found in JDK 1.3 is used to
run the system.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I166' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I167>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Starting
with <B>SineWave.java</B> from Chapter 13, create a program (an
applet/application using the <B>Console </B>class) that draws an animated sine
wave that appears to scrolls past the viewing window like an oscilloscope,
driving the animation with a <B>Thread</B>. The speed of the animation should be
controlled with a <B>java.swing.JSlider</B> control.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I167' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I168>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 9 so that multiple sine wave panels are created within the application.
The number of sine wave panels should be controlled by HTML tags or command-line
parameters.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I168' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I169>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 9 so that the <B>java.swing.Timer</B> class is used to drive the
animation. Note the difference between this and <B>java.util.Timer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I169' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER14_I170>
</FONT><LI><FONT FACE="Verdana"><U>	</U></FONT><FONT FACE="Georgia"><U>Modify
<B>SimpleThread.java</B> so that all the threads are daemon threads, and verify
that the program ends as soon as <B>main( )</B> is able to exit.</U>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER14_I170' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn70" HREF="#fnB70">[70]</A><FONT FACE="Georgia" SIZE=2>
<B>Runnable</B> was in Java 1.0, while inner classes were not introduced until
Java 1.1, which may partially account for the existence of <B>Runnable</B>.
Also, traditional multithreading architectures focused on a function to be run
rather than an object. My preference is always to inherit from <B>Thread</B> if
I can; it seems cleaner and more flexible to me.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn71" HREF="#fnB71">[71]</A><FONT FACE="Georgia" SIZE=2>
<I>The Java Programming Language</I>, by Ken Arnold and James Gosling,
Addison-Wesley 1996 pp 179.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap13.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap15.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:05/21/2001</P></DIV>

</BODY>

</HTML>
