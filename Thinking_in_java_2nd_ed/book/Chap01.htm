<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/21/2001
Translation Time:10:39:02
Translation Platform:Win32
Number of Output files:23
This File:Chap01.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>1: Introduction  to Objects</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevHist.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 12</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Intro.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap02.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc375545187"></A><A NAME="_Toc477690721"></A><A NAME="_Toc481064466"></A><A NAME="Heading21"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
1: Introduction <BR>to Objects</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=4><backtalk:display ID=TIJ3_CHAPTER1_I0>
The
genesis of the computer revolution was in a machine. The genesis of our
programming languages thus tends to look like that machine.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But computers are not so much machines as
they are mind amplification tools (&#8220;bicycles for the mind,&#8221; as Steve
Jobs is fond of saying) and a different kind of expressive medium. As a result,
the tools are beginning to look less like machines and more like parts of our
minds, and also like other forms of expression such as writing, painting,
sculpture, animation, and filmmaking. Object-oriented programming (OOP) is part
of this movement toward using the computer as an expressive
medium.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I0' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I1>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter will introduce you to the
<A NAME="Index20"></A><A NAME="Index21"></A><A NAME="Index22"></A><A NAME="Index23"></A>basic
concepts of OOP, including an overview of development methods. This chapter, and
this <A NAME="Index24"></A>book, assume that you have had experience in a
procedural programming language, although not necessarily C. If you think you
need more preparation in programming and the syntax of C before tackling this
book, you should work through the <I>Thinking in C: Foundations for C++ and
Java</I> training CD ROM, bound in with this book and also available at
<I>www.BruceEckel.com</I>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I1' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I2>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter is background and
supplementary material. Many people do not feel comfortable wading into
object-oriented programming without understanding the big picture first. Thus,
there are many concepts that are introduced here to give you a solid overview of
OOP. However, many other people don&#8217;t get the big picture concepts until
they&#8217;ve seen some of the mechanics first; these people may become bogged
down and lost without some code to get their hands on. If you&#8217;re part of
this latter group and are eager to get to the specifics of the language, feel
free to jump past this chapter&#8212;skipping it at this point will not prevent
you from writing programs or learning the language. However, you will want to
come back here eventually to fill in your knowledge so you can understand why
objects are important and how to design with
them.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I2' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I3>
</FONT><A NAME="_Toc375545188"></A><A NAME="_Toc408018385"></A><A NAME="_Toc472654682"></A><A NAME="_Toc481064467"></A><BR></P></DIV>
<A NAME="Heading22"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The progress of abstraction<A NAME="mark"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All programming languages provide
abstractions. It can be argued that the complexity of the problems you&#8217;re
able to solve is directly related to the kind and quality of
<A NAME="Index25"></A>abstraction. By &#8220;kind&#8221; I mean, &#8220;What is
it that you are abstracting?&#8221; Assembly language is a small abstraction of
the underlying machine. Many so-called &#8220;imperative&#8221; languages that
followed (such as Fortran, BASIC, and C) were abstractions of assembly language.
These languages are big improvements over assembly language, but their primary
abstraction still requires you to think in terms of the structure of the
computer rather than the structure of the problem you are trying to solve. The
programmer must establish the association between the machine model (in the
&#8220;<A NAME="Index26"></A><A NAME="Index27"></A>solution space,&#8221; which
is the place where you&#8217;re modeling that problem, such as a computer) and
the model of the problem that is actually being solved (in the
&#8220;<A NAME="Index28"></A><A NAME="Index29"></A>problem space,&#8221; which
is the place where the problem exists). The effort required to perform this
mapping, and the fact that it is extrinsic to the programming language, produces
programs that are difficult to write and expensive to maintain, and as a side
effect created the entire &#8220;programming methods&#8221;
industry.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I3' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I4>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The alternative to modeling the machine
is to model the problem you&#8217;re trying to solve. Early languages such as
LISP and APL chose particular views of the world (&#8220;All problems are
ultimately lists&#8221; or &#8220;All problems are algorithmic,&#8221;
respectively). PROLOG casts all problems into chains of decisions. Languages
have been created for constraint-based programming and for programming
exclusively by manipulating graphical symbols. (The latter proved to be too
restrictive.) Each of these approaches is a good solution to the particular
class of problem they&#8217;re designed to solve, but when you step outside of
that domain they become awkward.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I4' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I5>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The object-oriented approach goes a step
further by providing tools for the programmer to represent elements in the
problem space. This representation is general enough that the programmer is not
constrained to any particular type of problem. We refer to the elements in the
problem space and their representations in the solution space
as<A NAME="Index30"></A> &#8220;objects.&#8221; (Of course, you will also need
other objects that don&#8217;t have problem-space analogs.) The idea is that the
program is allowed to adapt itself to the lingo of the problem by adding new
types of objects, so when you read the code describing the solution,
you&#8217;re reading words that also express the problem. This is a more
flexible and powerful language abstraction than what we&#8217;ve had before.
Thus, OOP allows you to describe the problem in terms of the problem, rather
than in terms of the computer where the solution will run. There&#8217;s still a
connection back to the computer, though. Each object looks quite a bit like a
little computer; it has a state, and it has operations that you can ask it to
perform. However, this doesn&#8217;t seem like such a bad analogy to objects in
the real world&#8212;they all have characteristics and behaviors.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I5' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I6>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some language designers have decided that
object-oriented programming by itself is not adequate to easily solve all
programming problems, and advocate the combination of various approaches into
<I>multiparadigm</I> programming
languages.</FONT><A NAME="fnB2" HREF="#fn2">[2]</A><A NAME="Index31"></A><A NAME="Index32"></A><FONT FACE="Georgia">
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I6' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I7>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Alan Kay summarized five
<A NAME="Index33"></A>basic characteristics of <A NAME="Index34"></A>Smalltalk,
the first successful object-oriented language and one of the languages upon
which Java is based. These characteristics represent a pure approach to
object-oriented
programming<A NAME="Index35"></A><A NAME="Index36"></A><A NAME="Index37"></A><A NAME="Index38"></A>:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I7' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I8>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana"><B>	Everything is an
object.</B></FONT><FONT FACE="Georgia"> Think of an object as a fancy variable;
it stores data, but you can &#8220;make requests&#8221; to that object, asking
it to perform operations on itself. In theory, you can take any conceptual
component in the problem you&#8217;re trying to solve (dogs, buildings,
services, etc.) and represent it as an object in your program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I8' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I9>
</FONT><LI><FONT FACE="Verdana"><B>	A program
is a bunch of objects telling each other what to do by sending
messages</B></FONT><FONT FACE="Georgia">. To make a request of an object, you
&#8220;send a message&#8221; to that object. More concretely, you can think of a
message as a request to call a function that belongs to a particular object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I9' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I10>
</FONT><LI><FONT FACE="Verdana"><B>	Each
object has its own memory made up of other
objects</B></FONT><FONT FACE="Georgia">. Put another way, you create a new kind
of object by making a package containing existing objects. Thus, you can build
complexity in a program while hiding it behind the simplicity of objects.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I10' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I11>
</FONT><LI><FONT FACE="Verdana"><B>	Every
object has a type</B></FONT><FONT FACE="Georgia">. Using the parlance, each
object is an <I>instance</I> of a <I>class</I>, in which &#8220;class&#8221; is
synonymous with &#8220;type.&#8221; The most important distinguishing
characteristic of a class is &#8220;What messages can you send to it?&#8221;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I11' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I12>
</FONT><LI><FONT FACE="Verdana"><B>	All
objects of a particular type can receive the same
messages</B></FONT><FONT FACE="Georgia">. This is actually a loaded statement,
as you will see later. Because an object of type &#8220;circle&#8221; is also an
object of type &#8220;shape,&#8221; a circle is guaranteed to accept shape
messages. This means you can write code that talks to shapes and automatically
handle anything that fits the description of a shape. This
<I>substitutability</I> is one of the most powerful concepts in OOP.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I12' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I13>
</FONT><A NAME="_Toc375545189"></A><A NAME="_Toc408018386"></A><A NAME="_Toc472654683"></A><A NAME="_Toc481064468"></A></OL><A NAME="Heading23"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
An object has an interface<BR><A NAME="Index39"></A><A NAME="Index40"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Aristotle was probably the first to begin
a careful study of the concept of <I>type;</I> he spoke of &#8220;the class of
fishes and the class of birds.&#8221; The idea that all objects, while being
unique, are also part of a class of objects that have characteristics and
behaviors in common was used directly in the first object-oriented language,
Simula-67, with its fundamental keyword <B>class</B> that introduces a new type
into a program.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I13' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I14>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index41"></A><A NAME="Index42"></A><FONT FACE="Georgia">Simula,
as its name implies, was created for developing simulations such as the classic
&#8220;bank teller problem.&#8221; In this, you have a bunch of tellers,
customers, accounts, transactions, and units of money&#8212;a lot of
&#8220;objects.&#8221; Objects that are identical except for their state during
a program&#8217;s execution are grouped together into &#8220;classes of
objects&#8221; and that&#8217;s where the
<A NAME="Index43"></A><A NAME="Index44"></A>keyword <B>class</B> came from.
Creating abstract data types (classes) is a fundamental concept in
object-oriented programming. Abstract data types work almost exactly like
built-in types: You can create variables of a type (called <I>objects </I>or
<I>instances</I> in object-oriented parlance) and manipulate those variables
(called <A NAME="Index45"></A><A NAME="Index46"></A><I>sending messages</I> or
<A NAME="Index47"></A><I>requests;</I> you send a message and the object figures
out what to do with it). The members (elements) of each class share some
commonality: every account has a balance, every teller can accept a deposit,
etc. At the same time, each member has its own state, each account has a
different balance, each teller has a name. Thus, the tellers, customers,
accounts, transactions, etc., can each be represented with a unique entity in
the computer program. This entity is the object, and each object belongs to a
particular class that defines its characteristics and
behaviors.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I14' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I15>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So, although what we really do in
object-oriented programming is create new data types, virtually all
object-oriented programming languages use the &#8220;class&#8221; keyword. When
you see the word &#8220;type&#8221; think &#8220;class&#8221; and vice
versa</FONT><A NAME="fnB3" HREF="#fn3">[3]</A><FONT FACE="Georgia">.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I15' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I16>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since a class describes a set of objects
that have identical characteristics (data elements) and behaviors
(functionality), a class is really a
<A NAME="Index48"></A><A NAME="Index49"></A>data type because a floating point
number, for example, also has a set of characteristics and behaviors. The
difference is that a programmer defines a class to fit a problem rather than
being forced to use an existing data type that was designed to represent a unit
of storage in a machine. You extend the programming language by adding new data
types specific to your needs. The programming system welcomes the new classes
and gives them all the care and type-checking that it gives to built-in
types.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I16' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I17>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The object-oriented approach is not
limited to building simulations. Whether or not you agree that any program is a
simulation of the system you&#8217;re designing, the use of OOP techniques can
easily reduce a large set of problems to a simple
solution.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I17' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I18>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a class is established, you can make
as many objects of that class as you like, and then manipulate those objects as
if they are the elements that exist in the problem you are trying to solve.
Indeed, one of the challenges of object-oriented programming is to create a
one-to-one mapping between the elements in the problem space and objects in the
solution space.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I18' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I19>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But how do you get an object to do useful
work for you? There must be a way to make a request of the object so that it
will do something, such as complete a transaction, draw something on the screen,
or turn on a switch. And each object can satisfy only certain requests. The
requests you can make of an object are defined by its <I>interface,</I> and the
type is what determines the interface. A simple example might be a
representation of a light bulb:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I19' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I20>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ203.gif"></FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Light lt = <font color=#0000ff>new</font> Light();
lt.on();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The interface establishes <I>what</I>
requests you can make for a particular object. However, there must be code
somewhere to satisfy that request. This, along with the hidden data, comprises
the <A NAME="Index50"></A><I>implementation</I>. From a procedural programming
standpoint, it&#8217;s not that complicated. A type has a function associated
with each possible request, and when you make a particular request to an object,
that function is called. This process is usually summarized by saying that you
&#8220;send a message&#8221; (make a request) to an object, and the object
figures out what to do with that message (it executes
code).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I20' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I21>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the name of the type/class is
<B>Light</B>, the name of this particular <B>Light </B>object is <B>lt</B>,<B>
</B>and the requests that you can make of a <B>Light</B> object are to turn it
on, turn it off, make it brighter, or make it dimmer. You create a <B>Light
</B>object by defining a &#8220;reference&#8221; (<B>lt</B>) for that object and
calling <B>new</B> to request a new object of that type. To send a message to
the object, you state the name of the object and connect it to the message
request with a period (dot). From the standpoint of the user of a predefined
class, that&#8217;s pretty much all there is to programming with
objects.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I21' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I22>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The diagram shown above follows the
format of the <A NAME="Index51"></A><A NAME="Index52"></A><I>Unified Modeling
Language</I> (UML). Each class is represented by a box, with the type name in
the top portion of the box, any data members that you care to describe in the
middle portion of the box, and the
<A NAME="Index53"></A><A NAME="Index54"></A><I>member functions</I> (the
functions that belong to this object, which receive any messages you send to
that object) in the bottom portion of the box. Often, only the name of the class
and the public member functions are shown in UML design diagrams, and so the
middle portion is not shown. If you&#8217;re interested only in the class name,
then the bottom portion doesn&#8217;t need to be shown,
either.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I22' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I23>
</FONT><A NAME="_Toc375545190"></A><A NAME="_Toc408018387"></A><A NAME="_Toc472654684"></A><A NAME="_Toc481064469"></A><BR></P></DIV>
<A NAME="Heading24"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The hidden implementation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is helpful to break up the playing
field into <A NAME="Index55"></A><I>class creators</I> (those who create new
data types) and <A NAME="Index56"></A><A NAME="Index57"></A><I>client
programmers</I></FONT><A NAME="fnB4" HREF="#fn4">[4]</A><A NAME="Index58"></A><FONT FACE="Georgia">
(the class consumers who use the data types in their applications). The goal of
the client programmer is to collect a toolbox full of classes to use for rapid
application development. The goal of the class creator is to build a class that
exposes only what&#8217;s necessary to the client programmer and keeps
everything else hidden. Why? Because if it&#8217;s hidden, the client programmer
can&#8217;t use it, which means that the class creator can change the hidden
portion at will without worrying about the impact to anyone else. The hidden
portion usually represents the tender insides of an object that could easily be
corrupted by a careless or uninformed client programmer, so hiding the
implementation reduces program bugs. The concept of
<A NAME="Index59"></A><A NAME="Index60"></A>implementation hiding cannot be
overemphasized.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I23' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I24>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In any relationship it&#8217;s important
to have boundaries that are respected by all parties involved. When you create a
library, you establish a relationship with the client<I> </I>programmer, who is
also a programmer, but one who is putting together an application by using your
library, possibly to build a bigger
library.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I24' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I25>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If all the members of a class are
available to everyone, then the client programmer can do anything with that
class and there&#8217;s no way to enforce rules. Even though you might really
prefer that the client programmer not directly manipulate some of the members of
your class, without access control there&#8217;s no way to prevent it.
Everything&#8217;s naked to the
world.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I25' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I26>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the first reason for access control is
to keep client programmers&#8217; hands off portions they shouldn&#8217;t
touch&#8212;parts that are necessary for the internal machinations of the data
type but not part of the interface that users need in order to solve their
particular problems. This is actually a service to users because they can easily
see what&#8217;s important to them and what they can
ignore.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I26' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I27>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second reason for access control is
to allow the library designer to change the internal workings of the class
without worrying about how it will affect the client programmer. For example,
you might implement a particular class in a simple fashion to ease development,
and then later discover that you need to rewrite it in order to make it run
faster. If the interface and implementation are clearly separated and protected,
you can accomplish this
easily.<A NAME="Index61"></A><A NAME="Index62"></A><A NAME="Index63"></A>
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I27' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I28>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java uses three explicit keywords to set
the boundaries in a class: <B>public</B>, <B>private</B>, and <B>protected</B>.
Their use and meaning are quite straightforward. These <I>access specifiers</I>
<A NAME="Index64"></A><A NAME="Index65"></A><A NAME="Index66"></A>determine who
can use the definitions that follow. <B>public</B> <A NAME="Index67"></A>means
the following definitions are available to everyone. The <B>private</B>
<A NAME="Index68"></A>keyword, on the other hand, means that no one can access
those definitions except you, the creator of the type, inside member functions
of that type. <B>private</B> is a brick wall between you and the client
programmer. If someone tries to access a <B>private</B> member, they&#8217;ll
get a compile-time error. <A NAME="Index69"></A><B>protected</B> acts like
<B>private</B>, with the exception that an inheriting class has access to
<B>protected</B> members, but not <B>private</B> members. Inheritance will be
introduced shortly.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I28' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I29>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java also has a &#8220;default&#8221;
access, which comes into play if you don&#8217;t use one of the aforementioned
specifiers. This is sometimes called &#8220;friendly&#8221; access because
classes can access the friendly members of other classes in the same package,
but outside of the package those same friendly members appear to be
<B>private</B>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I29' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I30>
</FONT><A NAME="_Toc375545191"></A><A NAME="_Toc408018388"></A><A NAME="_Toc472654685"></A><A NAME="_Toc481064470"></A><BR></P></DIV>
<A NAME="Heading25"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Reusing the implementation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a class has been created and tested,
it should (ideally) represent a useful unit of code. It turns out that this
<A NAME="Index70"></A>reusability is not nearly so easy to achieve as many would
hope; it takes experience and insight to produce a good design. But once you
have such a design, it begs to be reused. Code reuse is one of the greatest
advantages that object-oriented programming languages
provide.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I30' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I31>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The simplest way to reuse a class is to
just use an object of that class directly, but you can also place an object of
that class inside a new class. We call this &#8220;creating a
<A NAME="Index71"></A><A NAME="Index72"></A>member object.&#8221; Your new class
can be made up of any number and type of other objects, in any combination that
you need to achieve the functionality desired in your new class. Because you are
composing a new class from existing classes, this concept is called
<A NAME="Index73"></A><I>composition</I> (or more generally,
<A NAME="Index74"></A><I>aggregation</I>). Composition is often referred to as a
&#8220;<A NAME="Index75"></A>has-a&#8221; relationship, as in &#8220;a car has
an engine.&#8221;
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I31' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I32>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ204.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(The above <A NAME="Index76"></A>UML
diagram indicates composition with the filled diamond, which states there is one
car. I will typically use a simpler form: just a line, without the diamond, to
indicate an
association.</FONT><A NAME="fnB5" HREF="#fn5">[5]</A><FONT FACE="Georgia">)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I32' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I33>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Composition comes with a great deal of
flexibility. The member objects of your new class are usually private, making
them inaccessible to the client programmers who are using the class. This allows
you to change those members without disturbing existing client code. You can
also change the member objects at run-time, to dynamically change the behavior
of your program. Inheritance, which is described next, does not have this
flexibility since the compiler must place compile-time restrictions on classes
created with inheritance.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I33' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I34>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because inheritance is so important in
object-oriented programming it is often highly emphasized, and the new
programmer can get the idea that inheritance should be used everywhere. This can
result in awkward and overly complicated designs. Instead, you should first look
to composition when creating new classes, since it is simpler and more flexible.
If you take this approach, your designs will be cleaner. Once you&#8217;ve had
some experience, it will be reasonably obvious when you need
inheritance.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I34' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I35>
</FONT><A NAME="_Toc375545192"></A><A NAME="_Toc408018389"></A><A NAME="_Toc472654686"></A><A NAME="_Toc481064471"></A><BR></P></DIV>
<A NAME="Heading26"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Inheritance:<BR>reusing the interface</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By itself, the idea of an object is a
convenient tool. It allows you to package data and functionality together by
<I>concept</I>, so you can represent an appropriate problem-space idea rather
than being forced to use the idioms of the underlying machine. These concepts
are expressed as fundamental units in the programming language by using the
<A NAME="Index77"></A><A NAME="Index78"></A><B>class</B>
keyword.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I35' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I36>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It seems a pity, however, to go to all
the trouble to create a class and then be forced to create a brand new one that
might have similar functionality. It&#8217;s nicer if we can take the existing
class, clone it, and then make additions and modifications to the clone. This is
effectively what you get with <A NAME="Index79"></A><I>inheritance</I>, with the
exception that if the original class (called the <I>base</I> or <I>super</I> or
<I>parent</I> class) is changed, the modified &#8220;clone&#8221; (called the
<I>derived </I>or <I>inherited</I> or <I>sub</I> or <I>child</I><B> </B>class)
also reflects those
changes.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I36' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I37>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ205.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(The arrow in the above UML diagram
points from the derived class to the base class. As you will see, there can be
more than one derived
class.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I37' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I38>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A type does more than describe the
constraints on a set of objects; it also has a relationship with other types.
Two types can have characteristics and behaviors in common, but one type may
contain more characteristics than another and may also handle more messages (or
handle them differently). Inheritance expresses this similarity between types
using the concept of <A NAME="Index80"></A><A NAME="Index81"></A>base types and
<A NAME="Index82"></A><A NAME="Index83"></A>derived types. A base type contains
all of the characteristics and behaviors that are shared among the types derived
from it. You create a base type to represent the core of your ideas about some
objects in your system. From the base type, you derive other types to express
the different ways that this core can be
realized.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I38' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I39>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, a trash-recycling machine
sorts pieces of trash. The base type is &#8220;trash,&#8221; and each piece of
trash has a weight, a value, and so on, and can be shredded, melted, or
decomposed. From this, more specific types of trash are derived that may have
additional characteristics (a bottle has a color) or behaviors (an aluminum can
may be crushed, a steel can is magnetic). In addition, some behaviors may be
different (the value of paper depends on its type and condition). Using
inheritance, you can build a type hierarchy that expresses the problem
you&#8217;re trying to solve in terms of its
types.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I39' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I40>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A second example is the classic
&#8220;<A NAME="Index84"></A>shape&#8221; example, perhaps used in a
computer-aided design system or game simulation. The base type is
&#8220;shape,&#8221; and each shape has a size, a color, a position, and so on.
Each shape can be drawn, erased, moved, colored, etc. From this, specific types
of shapes are derived (inherited): circle, square, triangle, and so on, each of
which may have additional characteristics and behaviors. Certain shapes can be
flipped, for example. Some behaviors may be different, such as when you want to
calculate the area of a shape. The type hierarchy embodies both the similarities
and differences between the
shapes.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I40' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I41>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ206.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Casting the solution in the same terms as
the problem is tremendously beneficial because you don&#8217;t need a lot of
intermediate models to get from a description of the problem to a description of
the solution. With objects, the type hierarchy is the primary model, so you go
directly from the description of the system in the real world to the description
of the system in code. Indeed, one of the difficulties people have with
object-oriented design is that it&#8217;s too simple to get from the beginning
to the end. A mind trained to look for complex solutions is often stumped by
this simplicity at first.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I41' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I42>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you inherit from an existing type,
you create a new type. This new type contains not only all the members of the
existing type (although the <B>private</B> ones are hidden away and
inaccessible), but more important, it duplicates the interface of the base
class. That is, all the messages you can send to objects of the base class you
can also send to objects of the derived class. Since we know the type of a class
by the messages we can send to it, this means that the derived class <I>is the
same type as the base class</I>. In the previous example, &#8220;a circle is a
shape.&#8221; This type equivalence via inheritance is one of the fundamental
gateways in understanding the meaning of object-oriented
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I42' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I43>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since both the base class and derived
class have the same interface, there must be some implementation to go along
with that interface. That is, there must be some code to execute when an object
receives a particular message. If you simply inherit a class and don&#8217;t do
anything else, the methods from the base-class interface come right along into
the derived class. That means objects of the derived class have not only the
same type, they also have the same behavior, which isn&#8217;t particularly
interesting.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I43' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I44>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You have two ways to differentiate your
new derived class from the original base class. The first is quite
straightforward: You simply add brand new functions to the derived class. These
new functions are not part of the base class interface. This means that the base
class simply didn&#8217;t do as much as you wanted it to, so you added more
functions. This simple and primitive use for
<A NAME="Index85"></A><A NAME="Index86"></A>inheritance is, at times, the
perfect solution to your problem. However, you should look closely for the
possibility that your base class might also need these additional functions.
This process of discovery and iteration of your design happens regularly in
object-oriented
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I44' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I45>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ207.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although inheritance may sometimes imply
(especially in Java, where the keyword that indicates inheritance is
<B>extends</B>)<B> </B>that you are going to add new functions to the interface,
that&#8217;s not necessarily true. The second and more important way to
differentiate your new class is to <I>change</I> the behavior of an existing
base-class function. This is referred to as
<A NAME="Index87"></A><A NAME="Index88"></A><I>overriding</I> that
function.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I45' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I46>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ208.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To override a function, you simply create
a new definition for the function in the derived class. You&#8217;re saying,
&#8220;I&#8217;m using the same interface function here, but I want it to do
something different for my new
type.&#8221;
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I46' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I47>
</FONT><A NAME="_Toc375545194"></A><A NAME="_Toc408018391"></A><A NAME="_Toc472654687"></A><A NAME="_Toc481064472"></A><BR></P></DIV>
<A NAME="Heading27"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Is-a vs. is-like-a relationships<BR><A NAME="Index89"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a certain debate that can
occur about inheritance: Should inheritance override <I>only</I> base-class
functions (and not add new member functions that aren&#8217;t in the base
class)? This would mean that the derived type is <I>exactly</I> the same type as
the base class since it has exactly the same interface. As a result, you can
exactly substitute an object of the derived class for an object of the base
class. This can be thought of as <A NAME="Index90"></A><I>pure substitution</I>,
and it&#8217;s often referred to as the <A NAME="Index91"></A><I>substitution
principle</I>. In a sense, this is the ideal way to treat inheritance. We often
refer to the relationship between the base class and derived classes in this
case as an <I>is-a</I> relationship, because you can say &#8220;a circle <I>is
a</I> shape.&#8221; A test for inheritance is to determine whether you can state
the is-a relationship about the classes and have it make
sense.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I47' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I48>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are times when you must add new
interface elements to a derived type, thus extending the interface and creating
a new type. The new type can still be substituted for the base type, but the
substitution isn&#8217;t perfect because your new functions are not accessible
from the base type. This can be described as an
<I>is-like-a</I></FONT><A NAME="fnB6" HREF="#fn6">[6]</A><FONT FACE="Georgia">
relationship; the new type has the interface of the old type but it also
contains other functions, so you can&#8217;t really say it&#8217;s exactly the
same. For example, consider an air conditioner. Suppose your house is wired with
all the controls for cooling; that is, it has an interface that allows you to
control cooling. Imagine that the air conditioner breaks down and you replace it
with a heat pump, which can both heat and cool. The heat pump <I>is-like-an</I>
air conditioner, but it can do more. Because the control system of your house is
designed only to control cooling, it is restricted to communication with the
cooling part of the new object. The interface of the new object has been
extended, and the existing system doesn&#8217;t know about anything except the
original interface.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I48' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I49>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ209.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, once you see this design it
becomes clear that the base class &#8220;cooling system&#8221; is not general
enough, and should be renamed to &#8220;temperature control system&#8221; so
that it can also include heating&#8212;at which point the substitution principle
will work. However, the diagram above is an example of what can happen in design
and in the real world. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I49' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I50>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you see the substitution principle
it&#8217;s easy to feel like this approach (pure substitution) is the only way
to do things, and in fact it <I>is</I> nice if your design works out that way.
But you&#8217;ll find that there are times when it&#8217;s equally clear that
you must add new functions to the interface of a derived class. With inspection
both cases should be reasonably
obvious.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I50' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I51>
</FONT><A NAME="_Toc375545195"></A><A NAME="_Toc408018392"></A><A NAME="_Toc472654688"></A><A NAME="_Toc481064473"></A><BR></P></DIV>
<A NAME="Heading28"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Interchangeable objects <BR>with polymorphism<BR><A NAME="Index92"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When dealing with type hierarchies, you
often want to treat an object not as the specific type that it is, but instead
as its base type. This allows you to write code that doesn&#8217;t depend on
specific types. In the shape example, functions manipulate generic shapes
without respect to whether they&#8217;re circles, squares, triangles, or some
shape that hasn&#8217;t even been defined yet. All shapes can be drawn, erased,
and moved, so these functions simply send a message to a shape object; they
don&#8217;t worry about how the object copes with the
message.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I51' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I52>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Such code is unaffected by the addition
of new types, and adding new types is the most common way to extend an
object-oriented program to handle new situations. For example, you can derive a
new subtype of shape called pentagon<I> </I>without modifying the functions that
deal only with generic shapes. This ability to extend a program easily by
deriving new subtypes is important because it greatly improves designs while
reducing the cost of software
maintenance.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I52' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I53>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s a problem, however, with
attempting to treat derived-type objects as their generic base types (circles as
shapes, bicycles as vehicles, cormorants as birds, etc.). If a function is going
to tell a generic shape to draw itself, or a generic vehicle to steer, or a
generic bird to move, the compiler cannot know at compile-time precisely what
piece of code will be executed. That&#8217;s the whole point&#8212;when the
message is sent, the programmer doesn&#8217;t <I>want</I> to know what piece of
code will be executed; the draw function can be applied equally to a circle, a
square, or a triangle, and the object will execute the proper code depending on
its specific type. If you don&#8217;t have to know what piece of code will be
executed, then when you add a new subtype, the code it executes can be different
without requiring changes to the function call. Therefore, the compiler cannot
know precisely what piece of code is executed, so what does it do? For example,
in the following diagram the <B>BirdController</B> object just works with
generic <B>Bird</B> objects, and does not know what exact type they are. This is
convenient from <B>BirdController</B>&#8217;s perspective because it
doesn&#8217;t have to write special code to determine the exact type of
<B>Bird</B> it&#8217;s working with, or that <B>Bird</B>&#8217;s behavior. So
how does it happen that, when <B>move(&#160;)</B> is called while ignoring the
specific type of <B>Bird</B>, the right behavior will occur (a <B>Goose
</B>runs, flies, or swims, and a <B>Penguin</B> runs or
swims)?
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I53' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I54>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ210.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The answer is the primary twist in
object-oriented programming: the compiler cannot make a function call in the
traditional sense. The function call generated by a non-OOP compiler causes what
is called <A NAME="Index93"></A><A NAME="Index94"></A><I>early binding</I>, a
term you may not have heard before because you&#8217;ve never thought about it
any other way. It means the compiler generates a call to a specific function
name, and the linker resolves this call to the absolute address of the code to
be executed. In OOP, the program cannot determine the address of the code until
run-time, so some other scheme is necessary when a message is sent to a generic
object.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I54' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I55>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve the problem, object-oriented
languages use the concept of <A NAME="Index95"></A><A NAME="Index96"></A><I>late
binding</I>. When you send a message to an object, the code being called
isn&#8217;t determined until run-time. The compiler does ensure that the
function exists and performs type checking on the arguments and return value (a
language in which this isn&#8217;t true is called
<A NAME="Index97"></A><A NAME="Index98"></A><I>weakly typed</I>), but it
doesn&#8217;t know the exact code to
execute.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I55' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I56>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To perform late binding, Java uses a
special bit of code in lieu of the absolute call. This code calculates the
address of the function body, using information stored in the object (this
process is covered in great detail in Chapter 7). Thus, each object can behave
differently according to the contents of that special bit of code. When you send
a message to an object, the object actually does figure out what to do with that
message.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I56' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I57>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In some languages (C++, in particular)
you must explicitly state that you want a function to have the flexibility of
late-binding properties. In these languages, by default, member functions are
<I>not</I> dynamically bound. This caused problems, so in Java dynamic binding
is the default and you don&#8217;t need to remember to add any extra keywords in
order to get polymorphism.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I57' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I58>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider the shape example. The family of
classes (all based on the same uniform interface) was diagrammed earlier in this
chapter. To demonstrate polymorphism, we want to write a single piece of code
that ignores the specific details of type and talks only to the base class. That
code is <A NAME="Index99"></A><I>decoupled</I> from type-specific information,
and thus is simpler to write and easier to understand. And, if a new
type&#8212;a <B>Hexagon</B>, for example&#8212;is added through inheritance, the
code you write will work just as well for the new type of <B>Shape</B> as it did
on the existing types. Thus, the program is
<I>extensible</I>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I58' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I59>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you write a method in Java (as you
will soon learn how to do):
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I59' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I60>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> doStuff(Shape s) {
  s.erase();
  <font color=#009900>// ...</font>
  s.draw();
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This function speaks to any <B>Shape</B>,
so it is independent of the specific type of object that it&#8217;s drawing and
erasing. If in some other part of the program we use the <B>doStuff(&#160;)</B>
function:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I60' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I61>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Circle c = <font color=#0000ff>new</font> Circle();
Triangle t = <font color=#0000ff>new</font> Triangle();
Line l = <font color=#0000ff>new</font> Line();
doStuff(c);
doStuff(t);
doStuff(l);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The calls to <B>doStuff(&#160;)
</B>automatically work correctly, regardless of the exact type of the object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I61' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I62>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is actually a pretty amazing trick.
Consider the line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>doStuff(c);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s happening here is that a
<B>Circle</B> is being passed into a function that&#8217;s expecting a
<B>Shape</B>. Since a <B>Circle</B> <I>is</I> a <B>Shape</B> it can be treated
as one by <B>doStuff(&#160;)</B>. That is, any message that
<B>doStuff(&#160;)</B> can send to a <B>Shape</B>, a <B>Circle</B> can accept.
So it is a completely safe and logical thing to
do.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I62' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I63>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We call this process of treating a
derived type as though it were its base type
<A NAME="Index100"></A><I>upcasting</I>. The name <A NAME="Index101"></A><I>cast
</I>is used in the sense of casting into a mold and the <I>up</I> comes from the
way the <A NAME="Index102"></A><A NAME="Index103"></A>inheritance diagram is
typically arranged, with the base type at the top and the derived classes
fanning out downward. Thus, casting to a base type is moving up the inheritance
diagram:
&#8220;upcasting.&#8221;
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I63' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I64>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ211.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An object-oriented program contains some
upcasting somewhere, because that&#8217;s how you decouple yourself from knowing
about the exact type you&#8217;re working with. Look at the code in
<B>doStuff(&#160;)</B>:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I64' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I65>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>  s.erase();
  <font color=#009900>// ...</font>
  s.draw();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that it doesn&#8217;t say
&#8220;If you&#8217;re a <B>Circle</B>, do this, if you&#8217;re a
<B>Square</B>, do that, etc.&#8221; If you write that kind of code, which checks
for all the possible types that a <B>Shape</B> can actually be, it&#8217;s messy
and you need to change it every time you add a new kind of <B>Shape</B>. Here,
you just say &#8220;You&#8217;re a shape, I know you can <B>erase(&#160;)
</B>and <B>draw(&#160;) </B>yourself, do it, and take care of the details
correctly.&#8221; 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I65' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I66>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s impressive about the code in
<B>doStuff(&#160;)</B> is that, somehow, the right thing happens. Calling
<B>draw(&#160;)</B> for <B>Circle</B> causes different code to be executed than
when calling <B>draw(&#160;) </B>for a <B>Square</B> or a <B>Line</B>, but when
the <B>draw(&#160;)</B> message is sent to an anonymous <B>Shape</B>, the
correct behavior occurs based on the actual type of the <B>Shape</B>. This is
amazing because, as mentioned earlier, when the Java compiler is compiling the
code for <B>doStuff(&#160;)</B>, it cannot know exactly what types it is dealing
with. So ordinarily, you&#8217;d expect it to end up calling the version of
<B>erase(&#160;)</B> and <B>draw(&#160;) </B>for the base class <B>Shape</B>,
and not for the specific <B>Circle</B>, <B>Square</B>, or <B>Line</B>. And yet
the right thing happens because of polymorphism. The compiler and run-time
system handle the details; all you need to know is that it happens, and more
important how to design with it. When you send a message to an object, the
object will do the right thing, even when upcasting is
involved.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I66' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I67>
</FONT><A NAME="_Toc375545197"></A><A NAME="_Toc473421287"></A><A NAME="_Toc481064474"></A><BR></P></DIV>
<A NAME="Heading29"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Abstract base classes and interfaces</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often in a design, you want the base
class to present <I>only</I> an interface for its derived classes. That is, you
don&#8217;t want anyone to actually create an object of the base class, only to
upcast to it so that its interface can be used. This is accomplished by making
that class <I>abstract </I>using the <B>abstract</B> keyword. If anyone tries to
make an object of an <B>abstract</B> class, the compiler prevents them. This is
a tool to enforce a particular
design.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I67' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I68>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also use the <B>abstract</B>
keyword to describe a method that hasn&#8217;t been implemented yet&#8212;as a
stub indicating &#8220;here is an interface function for all types inherited
from this class, but at this point I don&#8217;t have any implementation for
it.&#8221; An <B>abstract </B>method may be created only inside an <B>abstract
</B>class. When the class is inherited, that method must be implemented, or the
inheriting class becomes <B>abstract</B> as well. Creating an <B>abstract</B>
method allows you to put a method in an interface without being forced to
provide a possibly meaningless body of code for that
method.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I68' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I69>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>interface</B> keyword takes the
concept of an <B>abstract</B> class one step further by preventing any function
definitions at all. The <B>interface</B> is a very handy and commonly used tool,
as it provides the perfect separation of interface and implementation. In
addition, you can combine many interfaces together, if you wish, whereas
inheriting from multiple regular classes or abstract classes is not
possible.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I69' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I70>
</FONT><A NAME="_Toc375545198"></A><A NAME="_Toc408018395"></A><A NAME="_Toc408018408"></A><A NAME="_Toc312373795"></A><A NAME="_Toc481064475"></A><BR></P></DIV>
<A NAME="Heading30"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Object landscapes and lifetimes</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Technically, OOP is just about abstract
data typing, inheritance, and polymorphism, but other issues can be at least as
important. The remainder of this section will cover these
issues.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I70' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I71>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most important factors is the
way objects are created and destroyed. Where is the data for an object and how
is the lifetime of the object controlled? There are different philosophies at
work here. C++ takes the approach that control of efficiency is the most
important issue, so it gives the programmer a choice. For maximum run-time
speed, the storage and lifetime can be determined while the program is being
written, by placing the objects on the stack (these are sometimes called
<I>automatic</I> or <I>scoped</I> variables) or in the static storage area. This
places a priority on the speed of storage allocation and release, and control of
these can be very valuable in some situations. However, you sacrifice
flexibility because you must know the exact quantity, lifetime, and type of
objects while you're writing the program. If you are trying to solve a more
general problem such as computer-aided design, warehouse management, or
air-traffic control, this is too
restrictive.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I71' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I72>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second approach is to create objects
dynamically in a pool of memory called the heap. In this approach, you don't
know until run-time how many objects you need, what their lifetime is, or what
their exact type is. Those are determined at the spur of the moment while the
program is running. If you need a new object, you simply make it on the heap at
the point that you need it. Because the storage is managed dynamically, at
run-time, the amount of time required to allocate storage on the heap is
significantly longer than the time to create storage on the stack. (Creating
storage on the stack is often a single assembly instruction to move the stack
pointer down, and another to move it back up.) The dynamic approach makes the
generally logical assumption that objects tend to be complicated, so the extra
overhead of finding storage and releasing that storage will not have an
important impact on the creation of an object. In addition, the greater
flexibility is essential to solve the general programming
problem.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I72' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I73>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java uses the second approach,
exclusively</FONT><A NAME="fnB7" HREF="#fn7">[7]</A><FONT FACE="Georgia">. Every
time you want to create an object, you use the <B>new</B> keyword to build a
dynamic instance of that
object.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I73' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I74>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There's another issue, however, and
that's the lifetime of an object. With languages that allow objects to be
created on the stack, the compiler determines how long the object lasts and can
automatically destroy it. However, if you create it on the heap the compiler has
no knowledge of its lifetime. In a language like C++, you must determine
programmatically when to destroy the object, which can lead to memory leaks if
you don&#8217;t do it correctly (and this is a common problem in C++ programs).
Java provides a feature called a garbage collector that automatically discovers
when an object is no longer in use and destroys it. A garbage collector is much
more convenient because it reduces the number of issues that you must track and
the code you must write. More important, the garbage collector provides a much
higher level of insurance against the insidious problem of memory leaks (which
has brought many a C++ project to its
knees).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I74' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I75>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of this section looks at
additional factors concerning object lifetimes and
landscapes.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I75' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I76>
</FONT><A NAME="_Toc481064476"></A><BR></P></DIV>
<A NAME="Heading31"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Collections and iterators</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you don&#8217;t know how many objects
you&#8217;re going to need to solve a particular problem, or how long they will
last, you also don&#8217;t know how to store those objects. How can you know how
much space to create for those objects? You can&#8217;t, since that information
isn&#8217;t known until
run-time.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I76' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I77>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution to most problems in
object-oriented design seems flippant: you create another type of object. The
new type of object that solves this particular problem holds references to other
objects. Of course, you can do the same thing with an array, which is available
in most languages. But there&#8217;s more. This new object, generally called a
<I>container</I> (also called a <I>collection</I>, but the Java library uses
that term in a different sense so this book will use &#8220;container&#8221;),
will expand itself whenever necessary to accommodate everything you place inside
it. So you don&#8217;t need to know how many objects you&#8217;re going to hold
in a container. Just create a container object and let it take care of the
details.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I77' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I78>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Fortunately, a good OOP language comes
with a set of containers as part of the package. In C++, it&#8217;s part of the
Standard C++ Library and is sometimes called the Standard Template Library
(STL). Object Pascal has containers in its Visual Component Library (VCL).
Smalltalk has a very complete set of containers. Java also has containers in its
standard library. In some libraries, a generic container is considered good
enough for all needs, and in others (Java, for example) the library has
different types of containers for different needs: a vector (called an
<B>ArrayList </B>in Java) for consistent access to all elements, and a linked
list for consistent insertion at all elements, for example, so you can choose
the particular type that fits your needs. Container libraries may also include
sets, queues, hash tables, trees, stacks,
etc.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I78' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I79>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All containers have some way to put
things in and get things out; there are usually functions to add elements to a
container, and others to fetch those elements back out. But fetching elements
can be more problematic, because a single-selection function is restrictive.
What if you want to manipulate or compare a set of elements in the container
instead of just one?
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I79' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I80>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is an iterator, which is an
object whose job is to select the elements within a container and present them
to the user of the iterator. As a class, it also provides a level of
abstraction. This abstraction can be used to separate the details of the
container from the code that&#8217;s accessing that container. The container,
via the iterator, is abstracted to be simply a sequence. The iterator allows you
to traverse that sequence without worrying about the underlying
structure&#8212;that is, whether it&#8217;s an <B>ArrayList</B>, a
<B>LinkedList</B>, a <B>Stack</B>, or something else. This gives you the
flexibility to easily change the underlying data structure without disturbing
the code in your program. Java began (in version 1.0 and 1.1) with a standard
iterator, called <B>Enumeration</B>, for all of its container classes. Java 2
has added a much more complete container library that contains an iterator
called <B>Iterator</B> that does more than the older
<B>Enumeration</B>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I80' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I81>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From a design standpoint, all you really
want is a sequence that can be manipulated to solve your problem. If a single
type of sequence satisfied all of your needs, there&#8217;d be no reason to have
different kinds. There are two reasons that you need a choice of containers.
First, containers provide different types of interfaces and external behavior. A
stack has a different interface and behavior than that of a queue, which is
different from that of a set or a list. One of these might provide a more
flexible solution to your problem than the other. Second, different containers
have different efficiencies for certain operations. The best example is an
<B>ArrayList</B> and a <B>LinkedList</B>. Both are simple sequences that can
have identical interfaces and external behaviors. But certain operations can
have radically different costs. Randomly accessing elements in an
<B>ArrayList</B> is a constant-time operation; it takes the same amount of time
regardless of the element you select. However, in a <B>LinkedList</B> it is
expensive to move through the list to randomly select an element, and it takes
longer to find an element that is further down the list. On the other hand, if
you want to insert an element in the middle of a sequence, it&#8217;s much
cheaper in a <B>LinkedList </B>than in an <B>ArrayList</B>. These and other
operations have different efficiencies depending on the underlying structure of
the sequence. In the design phase, you might start with a <B>LinkedList</B> and,
when tuning for performance, change to an <B>ArrayList</B>. Because of the
abstraction via iterators, you can change from one to the other with minimal
impact on your code.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I81' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I82>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the end, remember that a container is
only a storage cabinet to put objects in. If that cabinet solves all of your
needs, it doesn&#8217;t really matter how it is implemented (a basic concept
with most types of objects). If you&#8217;re working in a programming
environment that has built-in overhead due to other factors, then the cost
difference between an <B>ArrayList</B> and a <B>LinkedList</B> might not matter.
You might need only one type of sequence. You can even imagine the
&#8220;perfect&#8221; container abstraction, which can automatically change its
underlying implementation according to the way it is
used.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I82' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I83>
</FONT><A NAME="_Toc481064477"></A><BR></P></DIV>
<A NAME="Heading32"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The singly rooted hierarchy</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the issues in OOP that has become
especially prominent since the introduction of C++ is whether all classes should
ultimately be inherited from a single base class. In Java (as with virtually all
other OOP languages) the answer is &#8220;yes&#8221; and the name of this
ultimate base class is simply <B>Object</B>. It turns out that the benefits of
the singly rooted hierarchy are
many.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I83' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I84>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All objects in a singly rooted hierarchy
have an interface in common, so they are all ultimately the same type. The
alternative (provided by C++) is that you don&#8217;t know that everything is
the same fundamental type. From a backward-compatibility standpoint this fits
the model of C better and can be thought of as less restrictive, but when you
want to do full-on object-oriented programming you must then build your own
hierarchy to provide the same convenience that&#8217;s built into other OOP
languages. And in any new class library you acquire, some other incompatible
interface will be used. It requires effort (and possibly multiple inheritance)
to work the new interface into your design. Is the extra
&#8220;flexibility&#8221; of C++ worth it? If you need it&#8212;if you have a
large investment in C&#8212;it&#8217;s quite valuable. If you&#8217;re starting
from scratch, other alternatives such as Java can often be more
productive.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I84' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I85>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All objects in a singly rooted hierarchy
(such as Java provides) can be guaranteed to have certain functionality. You
know you can perform certain basic operations on every object in your system. A
singly rooted hierarchy, along with creating all objects on the heap, greatly
simplifies argument passing (one of the more complex topics in
C++).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I85' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I86>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A singly rooted hierarchy makes it much
easier to implement a garbage collector (which is conveniently built into Java).
The necessary support can be installed in the base class, and the garbage
collector can thus send the appropriate messages to every object in the system.
Without a singly rooted hierarchy and a system to manipulate an object via a
reference, it is difficult to implement a garbage
collector.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I86' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I87>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since run-time type information is
guaranteed to be in all objects, you&#8217;ll never end up with an object whose
type you cannot determine. This is especially important with system level
operations, such as exception handling, and to allow greater flexibility in
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I87' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I88>
</FONT><A NAME="_Toc481064478"></A><BR></P></DIV>
<A NAME="Heading33"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Collection libraries and support for easy collection use</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because a container is a tool that
you&#8217;ll use frequently, it makes sense to have a library of containers that
are built in a reusable fashion, so you can take one off the shelf and plug it
into your program. Java provides such a library, which should satisfy most
needs.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I88' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I89>
</FONT><BR></P></DIV>
<A NAME="Heading34"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Downcasting vs. templates/generics</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make these containers reusable, they
hold the one universal type in Java that was previously mentioned:
<B>Object</B>. The singly rooted hierarchy means that everything is an
<B>Object</B>, so a container that holds <B>Object</B>s can hold anything. This
makes containers easy to
reuse.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I89' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I90>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To use such a container, you simply add
object references to it, and later ask for them back. But, since the container
holds only <B>Object</B>s, when you add your object reference into the container
it is upcast to <B>Object</B>, thus losing its identity. When you fetch it back,
you get an <B>Object</B> reference, and not a reference to the type that you put
in. So how do you turn it back into something that has the useful interface of
the object that you put into the
container?
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I90' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I91>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the cast is used again, but this
time you&#8217;re not casting up the inheritance hierarchy to a more general
type, you cast down the hierarchy to a more specific type. This manner of
casting is called downcasting. With upcasting, you know, for example, that a
<B>Circle</B> is a type of <B>Shape</B> so it&#8217;s safe to upcast, but you
don&#8217;t know that an <B>Object</B> is necessarily a <B>Circle</B> or a
<B>Shape</B> so it&#8217;s hardly safe to downcast unless you know that&#8217;s
what you&#8217;re dealing
with.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I91' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I92>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s not completely dangerous,
however, because if you downcast to the wrong thing you&#8217;ll get a run-time
error called an <I>exception,</I> which will be described shortly. When you
fetch object references from a container, though, you must have some way to
remember exactly what they are so you can perform a proper
downcast.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I92' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I93>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Downcasting and the run-time checks
require extra time for the running program, and extra effort from the
programmer. Wouldn&#8217;t it make sense to somehow create the container so that
it knows the types that it holds, eliminating the need for the downcast and a
possible mistake? The solution is parameterized types, which are classes that
the compiler can automatically customize to work with particular types. For
example, with a parameterized container, the compiler could customize that
container so that it would accept only Shapes and fetch only
Shapes.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I93' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I94>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Parameterized types are an important part
of C++, partly because C++ has no singly rooted hierarchy. In C++, the keyword
that implements parameterized types is &#8220;template.&#8221; Java currently
has no parameterized types since it is possible for it to get by&#8212;however
awkwardly&#8212;using the singly rooted hierarchy. However, a current proposal
for parameterized types uses a syntax that is strikingly similar to C++
templates.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I94' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I95>
</FONT><A NAME="_Toc481064479"></A><BR></P></DIV>
<A NAME="Heading35"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The housekeeping dilemma: who should clean up?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each object requires resources in order
to exist, most notably memory. When an object is no longer needed it must be
cleaned up so that these resources are released for reuse. In simple programming
situations the question of how an object is cleaned up doesn&#8217;t seem too
challenging: you create the object, use it for as long as it&#8217;s needed, and
then it should be destroyed. It&#8217;s not hard, however, to encounter
situations in which the situation is more
complex.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I95' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I96>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose, for example, you are designing a
system to manage air traffic for an airport. (The same model might also work for
managing crates in a warehouse, or a video rental system, or a kennel for
boarding pets.) At first it seems simple: make a container to hold airplanes,
then create a new airplane and place it in the container for each airplane that
enters the air-traffic-control zone. For cleanup, simply delete the appropriate
airplane object when a plane leaves the
zone.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I96' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I97>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But perhaps you have some other system to
record data about the planes; perhaps data that doesn&#8217;t require such
immediate attention as the main controller function. Maybe it&#8217;s a record
of the flight plans of all the small planes that leave the airport. So you have
a second container of small planes, and whenever you create a plane object you
also put it in this second container if it&#8217;s a small plane. Then some
background process performs operations on the objects in this container during
idle moments.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I97' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I98>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now the problem is more difficult: how
can you possibly know when to destroy the objects? When you&#8217;re done with
the object, some other part of the system might not be. This same problem can
arise in a number of other situations, and in programming systems (such as C++)
in which you must explicitly delete an object when you&#8217;re done with it
this can become quite
complex.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I98' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I99>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With Java, the garbage collector is
designed to take care of the problem of releasing the memory (although this
doesn&#8217;t include other aspects of cleaning up an object). The garbage
collector &#8220;knows&#8221; when an object is no longer in use, and it then
automatically releases the memory for that object. This (combined with the fact
that all objects are inherited from the single root class <B>Object</B> and that
you can create objects only one way, on the heap) makes the process of
programming in Java much simpler than programming in C++. You have far fewer
decisions to make and hurdles to
overcome.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I99' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I100>
</FONT><BR></P></DIV>
<A NAME="Heading36"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Garbage collectors vs. efficiency and flexibility</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If all this is such a good idea, why
didn&#8217;t they do the same thing in C++? Well of course there&#8217;s a price
you pay for all this programming convenience, and that price is run-time
overhead. As mentioned before, in C++ you can create objects on the stack, and
in this case they&#8217;re automatically cleaned up (but you don&#8217;t have
the flexibility of creating as many as you want at run-time). Creating objects
on the stack is the most efficient way to allocate storage for objects and to
free that storage. Creating objects on the heap can be much more expensive.
Always inheriting from a base class and making all function calls polymorphic
also exacts a small toll. But the garbage collector is a particular problem
because you never quite know when it&#8217;s going to start up or how long it
will take. This means that there&#8217;s an inconsistency in the rate of
execution of a Java program, so you can&#8217;t use it in certain situations,
such as when the rate of execution of a program is uniformly critical. (These
are generally called real time programs, although not all real time programming
problems are this
stringent.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I100' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I101>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The designers of the C++ language, trying
to woo C programmers (and most successfully, at that), did not want to add any
features to the language that would impact the speed or the use of C++ in any
situation where programmers might otherwise choose C. This goal was realized,
but at the price of greater complexity when programming in C++. Java is simpler
than C++, but the trade-off is in efficiency and sometimes applicability. For a
significant portion of programming problems, however, Java is the superior
choice.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I101' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I102>
</FONT><A NAME="_Toc481064480"></A><BR></P></DIV>
<A NAME="Heading37"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exception handling: dealing with errors</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ever since the beginning of programming
languages, error handling has been one of the most difficult issues. Because
it&#8217;s so hard to design a good error handling scheme, many languages simply
ignore the issue, passing the problem on to library designers who come up with
halfway measures that can work in many situations but can easily be
circumvented, generally by just ignoring them. A major problem with most error
handling schemes is that they rely on programmer vigilance in following an
agreed-upon convention that is not enforced by the language. If the programmer
is not vigilant&#8212;often the case if they are in a hurry&#8212;these schemes
can easily be forgotten.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I102' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I103>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Exception handling wires error handling
directly into the programming language and sometimes even the operating system.
An exception is an object that is &#8220;thrown&#8221; from the site of the
error and can be &#8220;caught&#8221; by an appropriate exception handler
designed to handle that particular type of error. It&#8217;s as if exception
handling is a different, parallel path of execution that can be taken when
things go wrong. And because it uses a separate execution path, it doesn&#8217;t
need to interfere with your normally executing code. This makes that code
simpler to write since you aren&#8217;t constantly forced to check for errors.
In addition, a thrown exception is unlike an error value that&#8217;s returned
from a function or a flag that&#8217;s set by a function in order to indicate an
error condition&#8212;these can be ignored. An exception cannot be ignored, so
it&#8217;s guaranteed to be dealt with at some point. Finally, exceptions
provide a way to reliably recover from a bad situation. Instead of just exiting
you are often able to set things right and restore the execution of a program,
which produces much more robust
programs.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I103' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I104>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java&#8217;s exception handling stands
out among programming languages, because in Java, exception handling was wired
in from the beginning and you&#8217;re forced to use it. If you don&#8217;t
write your code to properly handle exceptions, you&#8217;ll get a compile-time
error message. This guaranteed consistency makes error handling much
easier.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I104' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I105>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s worth noting that exception
handling isn&#8217;t an object-oriented feature, although in object-oriented
languages the exception is normally represented with an object. Exception
handling existed before object-oriented
languages.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I105' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I106>
</FONT><A NAME="_Toc481064481"></A><BR></P></DIV>
<A NAME="Heading38"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Multithreading</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A fundamental concept in computer
programming is the idea of handling more than one task at a time. Many
programming problems require that the program be able to stop what it&#8217;s
doing, deal with some other problem, and then return to the main process. The
solution has been approached in many ways. Initially, programmers with low-level
knowledge of the machine wrote interrupt service routines and the suspension of
the main process was initiated through a hardware interrupt. Although this
worked well, it was difficult and nonportable, so it made moving a program to a
new type of machine slow and expensive.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I106' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I107>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes interrupts are necessary for
handling time-critical tasks, but there&#8217;s a large class of problems in
which you&#8217;re simply trying to partition the problem into separately
running pieces so that the whole program can be more responsive. Within a
program, these separately running pieces are called threads, and the general
concept is called <I>multithreading.</I> A common example of multithreading is
the user interface. By using threads, a user can press a button and get a quick
response rather than being forced to wait until the program finishes its current
task.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I107' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I108>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ordinarily, threads are just a way to
allocate the time of a single processor. But if the operating system supports
multiple processors, each thread can be assigned to a different processor and
they can truly run in parallel. One of the convenient features of multithreading
at the language level is that the programmer doesn&#8217;t need to worry about
whether there are many processors or just one. The program is logically divided
into threads and if the machine has more than one processor then the program
runs faster, without any special
adjustments.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I108' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I109>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All this makes threading sound pretty
simple. There is a catch: shared resources. If you have more than one thread
running that&#8217;s expecting to access the same resource you have a problem.
For example, two processes can&#8217;t simultaneously send information to a
printer. To solve the problem, resources that can be shared, such as the
printer, must be locked while they are being used. So a thread locks a resource,
completes its task, and then releases the lock so that someone else can use the
resource.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I109' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I110>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java&#8217;s threading is built into the
language, which makes a complicated subject much simpler. The threading is
supported on an object level, so one thread of execution is represented by one
object. Java also provides limited resource locking. It can lock the memory of
any object (which is, after all, one kind of shared resource) so that only one
thread can use it at a time. This is accomplished with the
<A NAME="Index104"></A><B>synchronized</B> keyword. Other types of resources
must be locked explicitly by the programmer, typically by creating an object to
represent the lock that all threads must check before accessing that
resource.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I110' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I111>
</FONT><A NAME="_Toc481064482"></A><BR></P></DIV>
<A NAME="Heading39"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Persistence</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you create an object, it exists for
as long as you need it, but under no circumstances does it exist when the
program terminates. While this makes sense at first, there are situations in
which it would be incredibly useful if an object could exist and hold its
information even while the program wasn&#8217;t running. Then the next time you
started the program, the object would be there and it would have the same
information it had the previous time the program was running. Of course, you can
get a similar effect by writing the information to a file or to a database, but
in the spirit of making everything an object it would be quite convenient to be
able to declare an object persistent and have all the details taken care of for
you.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I111' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I112>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java provides support for
&#8220;lightweight persistence,&#8221; which means that you can easily store
objects on disk and later retrieve them. The reason it&#8217;s
&#8220;lightweight&#8221; is that you&#8217;re still forced to make explicit
calls to do the storage and retrieval. In addition, JavaSpaces (described in
Chapter 15) provide for a kind of persistent storage of objects. In some future
release more complete support for persistence might
appear.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I112' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I113>
</FONT><A NAME="_Toc481064483"></A><BR></P></DIV>
<A NAME="Heading40"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java and the Internet</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If Java is, in fact, yet another computer
programming language, you may question why it is so important and why it is
being promoted as a revolutionary step in computer programming. The answer
isn&#8217;t immediately obvious if you&#8217;re coming from a traditional
programming perspective. Although Java is very useful for solving traditional
stand-alone programming problems, it is also important because it will solve
programming problems on the World Wide
Web.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I113' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I114>
</FONT><A NAME="_Toc481064484"></A><BR></P></DIV>
<A NAME="Heading41"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
What is the Web?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Web can seem a bit of a mystery at
first, with all this talk of &#8220;surfing,&#8221; &#8220;presence,&#8221; and
&#8220;home pages.&#8221; There has even been a growing reaction against
&#8220;Internet-mania,&#8221; questioning the economic value and outcome of such
a sweeping movement. It&#8217;s helpful to step back and see what it really is,
but to do this you must understand client/server systems, another aspect of
computing that&#8217;s full of confusing
issues.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I114' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I115>
</FONT><BR></P></DIV>
<A NAME="Heading42"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Client/Server computing</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The primary idea of a client/server
system is that you have a central repository of information&#8212;some kind of
data, often in a database&#8212;that you want to distribute on demand to some
set of people or machines. A key to the client/server concept is that the
repository of information is centrally located so that it can be changed and so
that those changes will propagate out to the information consumers. Taken
together, the information repository, the software that distributes the
information, and the machine(s) where the information and software reside is
called the server. The software that resides on the remote machine, communicates
with the server, fetches the information, processes it, and then displays it on
the remote machine is called the
<I>client.</I>
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I115' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I116>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic concept of client/server
computing, then, is not so complicated. The problems arise because you have a
single server trying to serve many clients at once. Generally, a database
management system is involved so the designer &#8220;balances&#8221; the layout
of data into tables for optimal use. In addition, systems often allow a client
to insert new information into a server. This means you must ensure that one
client&#8217;s new data doesn&#8217;t walk over another client&#8217;s new data,
or that data isn&#8217;t lost in the process of adding it to the database. (This
is called transaction processing.) As client software changes, it must be built,
debugged, and installed on the client machines, which turns out to be more
complicated and expensive than you might think. It&#8217;s especially
problematic to support multiple types of computers and operating systems.
Finally, there&#8217;s the all-important performance issue: you might have
hundreds of clients making requests of your server at any one time, and so any
small delay is crucial. To minimize latency, programmers work hard to offload
processing tasks, often to the client machine, but sometimes to other machines
at the server site, using so-called <I>middleware.</I> (Middleware is also used
to improve
maintainability.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I116' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I117>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The simple idea of distributing
information to people has so many layers of complexity in implementing it that
the whole problem can seem hopelessly enigmatic. And yet it&#8217;s crucial:
client/server computing accounts for roughly half of all programming activities.
It&#8217;s responsible for everything from taking orders and credit-card
transactions to the distribution of any kind of data&#8212;stock market,
scientific, government, you name it. What we&#8217;ve come up with in the past
is individual solutions to individual problems, inventing a new solution each
time. These were hard to create and hard to use, and the user had to learn a new
interface for each one. The entire client/server problem needs to be solved in a
big way.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I117' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I118>
</FONT><BR></P></DIV>
<A NAME="Heading43"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The Web as a giant server</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Web is actually one giant
client/server system. It&#8217;s a bit worse than that, since you have all the
servers and clients coexisting on a single network at once. You don&#8217;t need
to know that, since all you care about is connecting to and interacting with one
server at a time (even though you might be hopping around the world in your
search for the correct
server).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I118' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I119>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initially it was a simple one-way
process. You made a request of a server and it handed you a file, which your
machine&#8217;s browser software (i.e., the client) would interpret by
formatting onto your local machine. But in short order people began wanting to
do more than just deliver pages from a server. They wanted full client/server
capability so that the client could feed information back to the server, for
example, to do database lookups on the server, to add new information to the
server, or to place an order (which required more security than the original
systems offered). These are the changes we&#8217;ve been seeing in the
development of the Web.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I119' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I120>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Web browser was a big step forward:
the concept that one piece of information could be displayed on any type of
computer without change. However, browsers were still rather primitive and
rapidly bogged down by the demands placed on them. They weren&#8217;t
particularly interactive, and tended to clog up both the server and the Internet
because any time you needed to do something that required programming you had to
send information back to the server to be processed. It could take many seconds
or minutes to find out you had misspelled something in your request. Since the
browser was just a viewer it couldn&#8217;t perform even the simplest computing
tasks. (On the other hand, it was safe, since it couldn&#8217;t execute any
programs on your local machine that might contain bugs or
viruses.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I120' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I121>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve this problem, different
approaches have been taken. To begin with, graphics standards have been enhanced
to allow better animation and video within browsers. The remainder of the
problem can be solved only by incorporating the ability to run programs on the
client end, under the browser. This is called client-side
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I121' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I122>
</FONT><A NAME="_Toc481064485"></A><BR></P></DIV>
<A NAME="Heading44"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Client-side programming</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Web&#8217;s initial server-browser
design provided for interactive content, but the interactivity was completely
provided by the server. The server produced static pages for the client browser,
which would simply interpret and display them. Basic HTML contains simple
mechanisms for data gathering: text-entry boxes, check boxes, radio boxes, lists
and drop-down lists, as well as a button that can only be programmed to reset
the data on the form or &#8220;submit&#8221; the data on the form back to the
server. This submission passes through the Common Gateway Interface (CGI)
provided on all Web servers. The text within the submission tells CGI what to do
with it. The most common action is to run a program located on the server in a
directory that&#8217;s typically called &#8220;cgi-bin.&#8221; (If you watch the
address window at the top of your browser when you push a button on a Web page,
you can sometimes see &#8220;cgi-bin&#8221; within all the gobbledygook there.)
These programs can be written in most languages. Perl is a common choice because
it is designed for text manipulation and is interpreted, so it can be installed
on any server regardless of processor or operating
system.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I122' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I123>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many powerful Web sites today are built
strictly on CGI, and you can in fact do nearly anything with it. However, Web
sites built on CGI programs can rapidly become overly complicated to maintain,
and there is also the problem of response time. The response of a CGI program
depends on how much data must be sent, as well as the load on both the server
and the Internet. (On top of this, starting a CGI program tends to be slow.) The
initial designers of the Web did not foresee how rapidly this bandwidth would be
exhausted for the kinds of applications people developed. For example, any sort
of dynamic graphing is nearly impossible to perform with consistency because a
GIF file must be created and moved from the server to the client for each
version of the graph. And you&#8217;ve no doubt had direct experience with
something as simple as validating the data on an input form. You press the
submit button on a page; the data is shipped back to the server; the server
starts a CGI program that discovers an error, formats an HTML page informing you
of the error, and then sends the page back to you; you must then back up a page
and try again. Not only is this slow, it&#8217;s
inelegant.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I123' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I124>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution is client-side programming.
Most machines that run Web browsers are powerful engines capable of doing vast
work, and with the original static HTML approach they are sitting there, just
idly waiting for the server to dish up the next page. Client-side programming
means that the Web browser is harnessed to do whatever work it can, and the
result for the user is a much speedier and more interactive experience at your
Web site.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I124' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I125>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The problem with discussions of
client-side programming is that they aren&#8217;t very different from
discussions of programming in general. The parameters are almost the same, but
the platform is different: a Web browser is like a limited operating system. In
the end, you must still program, and this accounts for the dizzying array of
problems and solutions produced by client-side programming. The rest of this
section provides an overview of the issues and approaches in client-side
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I125' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I126>
</FONT><BR></P></DIV>
<A NAME="Heading45"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Plug-ins</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the most significant steps forward
in client-side programming is the development of the plug-in. This is a way for
a programmer to add new functionality to the browser by downloading a piece of
code that plugs itself into the appropriate spot in the browser. It tells the
browser &#8220;from now on you can perform this new activity.&#8221; (You need
to download the plug-in only once.) Some fast and powerful behavior is added to
browsers via plug-ins, but writing a plug-in is not a trivial task, and
isn&#8217;t something you&#8217;d want to do as part of the process of building
a particular site. The value of the plug-in for client-side programming is that
it allows an expert programmer to develop a new language and add that language
to a browser without the permission of the browser manufacturer. Thus, plug-ins
provide a &#8220;back door&#8221; that allows the creation of new client-side
programming languages (although not all languages are implemented as
plug-ins).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I126' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I127>
</FONT><BR></P></DIV>
<A NAME="Heading46"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Scripting languages</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Plug-ins resulted in an explosion of
scripting languages. With a scripting language you embed the source code for
your client-side program directly into the HTML page, and the plug-in that
interprets that language is automatically activated while the HTML page is being
displayed. Scripting languages tend to be reasonably easy to understand and,
because they are simply text that is part of an HTML page, they load very
quickly as part of the single server hit required to procure that page. The
trade-off is that your code is exposed for everyone to see (and steal).
Generally, however, you aren&#8217;t doing amazingly sophisticated things with
scripting languages so this is not too much of a
hardship.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I127' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I128>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This points out that the scripting
languages used inside Web browsers are really intended to solve specific types
of problems, primarily the creation of richer and more interactive graphical
user interfaces (GUIs). However, a scripting language might solve 80 percent of
the problems encountered in client-side programming. Your problems might very
well fit completely within that 80 percent, and since scripting languages can
allow easier and faster development, you should probably consider a scripting
language before looking at a more involved solution such as Java or ActiveX
programming.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I128' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I129>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most commonly discussed browser
scripting languages are JavaScript (which has nothing to do with Java;
it&#8217;s named that way just to grab some of Java&#8217;s marketing momentum),
VBScript (which looks like Visual Basic), and Tcl/Tk, which comes from the
popular cross-platform GUI-building language. There are others out there, and no
doubt more in development.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I129' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I130>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JavaScript is probably the most commonly
supported. It comes built into both Netscape Navigator and the Microsoft
Internet Explorer (IE). In addition, there are probably more JavaScript books
available than there are for the other browser languages, and some tools
automatically create pages using JavaScript. However, if you&#8217;re already
fluent in Visual Basic or Tcl/Tk, you&#8217;ll be more productive using those
scripting languages rather than learning a new one. (You&#8217;ll have your
hands full dealing with the Web issues already.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I130' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I131>
</FONT><BR></P></DIV>
<A NAME="Heading47"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Java</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a scripting language can solve 80
percent of the client-side programming problems, what about the other 20
percent&#8212;the &#8220;really hard stuff?&#8221; The most popular solution
today is Java. Not only is it a powerful programming language built to be
secure, cross-platform, and international, but Java is being continually
extended to provide language features and libraries that elegantly handle
problems that are difficult in traditional programming languages, such as
multithreading, database access, network programming, and distributed computing.
Java allows client-side programming via the
<I>applet</I>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I131' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I132>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An applet is a mini-program that will run
only under a Web browser. The applet is downloaded automatically as part of a
Web page (just as, for example, a graphic is automatically downloaded). When the
applet is activated it executes a program. This is part of its beauty&#8212;it
provides you with a way to automatically distribute the client software from the
server at the time the user needs the client software, and no sooner. The user
gets the latest version of the client software without fail and without
difficult reinstallation. Because of the way Java is designed, the programmer
needs to create only a single program, and that program automatically works with
all computers that have browsers with built-in Java interpreters. (This safely
includes the vast majority of machines.) Since Java is a full-fledged
programming language, you can do as much work as possible on the client before
and after making requests of the server. For example, you won&#8217;t need to
send a request form across the Internet to discover that you&#8217;ve gotten a
date or some other parameter wrong, and your client computer can quickly do the
work of plotting data instead of waiting for the server to make a plot and ship
a graphic image back to you. Not only do you get the immediate win of speed and
responsiveness, but the general network traffic and load on servers can be
reduced, preventing the entire Internet from slowing
down.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I132' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I133>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One advantage a Java applet has over a
scripted program is that it&#8217;s in compiled form, so the source code
isn&#8217;t available to the client. On the other hand, a Java applet can be
decompiled without too much trouble, but hiding your code is often not an
important issue. Two other factors can be important. As you will see later in
this book, a compiled Java applet can comprise many modules and take multiple
server &#8220;hits&#8221; (accesses) to download. (In Java 1.1 and higher this
is minimized by Java archives, called JAR files, that allow all the required
modules to be packaged together and compressed for a single download.) A
scripted program will just be integrated into the Web page as part of its text
(and will generally be smaller and reduce server hits). This could be important
to the responsiveness of your Web site. Another factor is the all-important
learning curve. Regardless of what you&#8217;ve heard, Java is not a trivial
language to learn. If you&#8217;re a Visual Basic programmer, moving to VBScript
will be your fastest solution, and since it will probably solve most typical
client/server problems you might be hard pressed to justify learning Java. If
you&#8217;re experienced with a scripting language you will certainly benefit
from looking at JavaScript or VBScript before committing to Java, since they
might fit your needs handily and you&#8217;ll be more productive
sooner.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I133' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I134>
</FONT><BR></P></DIV>
<A NAME="Heading48"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
ActiveX</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To some degree, the competitor to Java is
Microsoft&#8217;s ActiveX, although it takes a completely different approach.
ActiveX was originally a Windows-only solution, although it is now being
developed via an independent consortium to become cross-platform. Effectively,
ActiveX says &#8220;if your program connects to its environment just so, it can
be dropped into a Web page and run under a browser that supports ActiveX.&#8221;
(IE directly supports ActiveX and Netscape does so using a plug-in.) Thus,
ActiveX does not constrain you to a particular language. If, for example,
you&#8217;re already an experienced Windows programmer using a language such as
C++, Visual Basic, or Borland&#8217;s Delphi, you can create ActiveX components
with almost no changes to your programming knowledge. ActiveX also provides a
path for the use of legacy code in your Web
pages.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I134' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I135>
</FONT><BR></P></DIV>
<A NAME="Heading49"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Security</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Automatically downloading and running
programs across the Internet can sound like a virus-builder&#8217;s dream.
ActiveX especially brings up the thorny issue of security in client-side
programming. If you click on a Web site, you might automatically download any
number of things along with the HTML page: GIF files, script code, compiled Java
code, and ActiveX components. Some of these are benign; GIF files can&#8217;t do
any harm, and scripting languages are generally limited in what they can do.
Java was also designed to run its applets within a &#8220;sandbox&#8221; of
safety, which prevents it from writing to disk or accessing memory outside the
sandbox. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I135' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I136>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">ActiveX is at the opposite end of the
spectrum. Programming with ActiveX is like programming Windows&#8212;you can do
anything you want. So if you click on a page that downloads an ActiveX
component, that component might cause damage to the files on your disk. Of
course, programs that you load onto your computer that are not restricted to
running inside a Web browser can do the same thing. Viruses downloaded from
Bulletin-Board Systems (BBSs) have long been a problem, but the speed of the
Internet amplifies the
difficulty.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I136' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I137>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution seems to be &#8220;digital
signatures,&#8221; whereby code is verified to show who the author is. This is
based on the idea that a virus works because its creator can be anonymous, so if
you remove the anonymity individuals will be forced to be responsible for their
actions. This seems like a good plan because it allows programs to be much more
functional, and I suspect it will eliminate malicious mischief. If, however, a
program has an unintentional destructive bug it will still cause
problems.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I137' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I138>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java approach is to prevent these
problems from occurring, via the sandbox. The Java interpreter that lives on
your local Web browser examines the applet for any untoward instructions as the
applet is being loaded. In particular, the applet cannot write files to disk or
erase files (one of the mainstays of viruses). Applets are generally considered
to be safe, and since this is essential for reliable client/server systems, any
bugs in the Java language that allow viruses are rapidly repaired. (It&#8217;s
worth noting that the browser software actually enforces these security
restrictions, and some browsers allow you to select different security levels to
provide varying degrees of access to your
system.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I138' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I139>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might be skeptical of this rather
draconian restriction against writing files to your local disk. For example, you
may want to build a local database or save data for later use offline. The
initial vision seemed to be that eventually everyone would get online to do
anything important, but that was soon seen to be impractical (although low-cost
&#8220;Internet appliances&#8221; might someday satisfy the needs of a
significant segment of users). The solution is the &#8220;signed applet&#8221;
that uses public-key encryption to verify that an applet does indeed come from
where it claims it does. A signed applet can still trash your disk, but the
theory is that since you can now hold the applet creator accountable they
won&#8217;t do vicious things. Java provides a framework for digital signatures
so that you will eventually be able to allow an applet to step outside the
sandbox if necessary.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I139' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I140>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Digital signatures have missed an
important issue, which is the speed that people move around on the Internet. If
you download a buggy program and it does something untoward, how long will it be
before you discover the damage? It could be days or even weeks. By then, how
will you track down the program that&#8217;s done it? And what good will it do
you at that point?
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I140' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I141>
</FONT><BR></P></DIV>
<A NAME="Heading50"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Internet vs. intranet</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Web is the most general solution to
the client/server problem, so it makes sense that you can use the same
technology to solve a subset of the problem, in particular the classic
client/server problem <I>within</I> a company. With traditional client/server
approaches you have the problem of multiple types of client computers, as well
as the difficulty of installing new client software, both of which are handily
solved with Web browsers and client-side programming. When Web technology is
used for an information network that is restricted to a particular company, it
is referred to as an intranet. Intranets provide much greater security than the
Internet, since you can physically control access to the servers within your
company. In terms of training, it seems that once people understand the general
concept of a browser it&#8217;s much easier for them to deal with differences in
the way pages and applets look, so the learning curve for new kinds of systems
seems to be reduced.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I141' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I142>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The security problem brings us to one of
the divisions that seems to be automatically forming in the world of client-side
programming. If your program is running on the Internet, you don&#8217;t know
what platform it will be working under, and you want to be extra careful that
you don&#8217;t disseminate buggy code. You need something cross-platform and
secure, like a scripting language or Java.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I142' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I143>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re running on an intranet,
you might have a different set of constraints. It&#8217;s not uncommon that your
machines could all be Intel/Windows platforms. On an intranet, you&#8217;re
responsible for the quality of your own code and can repair bugs when
they&#8217;re discovered. In addition, you might already have a body of legacy
code that you&#8217;ve been using in a more traditional client/server approach,
whereby you must physically install client programs every time you do an
upgrade. The time wasted in installing upgrades is the most compelling reason to
move to browsers, because upgrades are invisible and automatic. If you are
involved in such an intranet, the most sensible approach to take is the shortest
path that allows you to use your existing code base, rather than trying to
recode your programs in a new
language.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I143' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I144>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When faced with this bewildering array of
solutions to the client-side programming problem, the best plan of attack is a
cost-benefit analysis. Consider the constraints of your problem and what would
be the shortest path to your solution. Since client-side programming is still
programming, it&#8217;s always a good idea to take the fastest development
approach for your particular situation. This is an aggressive stance to prepare
for inevitable encounters with the problems of program
development.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I144' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I145>
</FONT><A NAME="_Toc481064486"></A><BR></P></DIV>
<A NAME="Heading51"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Server-side programming</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This whole discussion has ignored the
issue of server-side programming. What happens when you make a request of a
server? Most of the time the request is simply &#8220;send me this file.&#8221;
Your browser then interprets the file in some appropriate fashion: as an HTML
page, a graphic image, a Java applet, a script program, etc. A more complicated
request to a server generally involves a database transaction. A common scenario
involves a request for a complex database search, which the server then formats
into an HTML page and sends to you as the result. (Of course, if the client has
more intelligence via Java or a scripting language, the raw data can be sent and
formatted at the client end, which will be faster and less load on the server.)
Or you might want to register your name in a database when you join a group or
place an order, which will involve changes to that database. These database
requests must be processed via some code on the server side, which is generally
referred to as server-side programming. Traditionally, server-side programming
has been performed using Perl and CGI scripts, but more sophisticated systems
have been appearing. These include Java-based Web servers that allow you to
perform all your server-side programming in Java by writing what are called
servlets. Servlets and their offspring, JSPs, are two of the most compelling
reasons that companies who develop Web sites are moving to Java, especially
because they eliminate the problems of dealing with differently abled browsers.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I145' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I146>
</FONT><A NAME="_Toc481064487"></A><BR></P></DIV>
<A NAME="Heading52"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A separate arena: applications</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Much of the brouhaha over Java has been
over applets. Java is actually a general-purpose programming language that can
solve any type of problem&#8212;at least in theory. And as pointed out
previously, there might be more effective ways to solve most client/server
problems. When you move out of the applet arena (and simultaneously release the
restrictions, such as the one against writing to disk) you enter the world of
general-purpose applications that run standalone, without a Web browser, just
like any ordinary program does. Here, Java&#8217;s strength is not only in its
portability, but also its programmability. As you&#8217;ll see throughout this
book, Java has many features that allow you to create robust programs in a
shorter period than with previous programming
languages.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I146' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I147>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Be aware that this is a mixed blessing.
You pay for the improvements through slower execution speed (although there is
significant work going on in this area&#8212;JDK 1.3, in particular, introduces
the so-called &#8220;hotspot&#8221; performance improvements). Like any
language, Java has built-in limitations that might make it inappropriate to
solve certain types of programming problems. Java is a rapidly evolving
language, however, and as each new release comes out it becomes more and more
attractive for solving larger sets of
problems.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I147' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I148>
</FONT><A NAME="_Toc472654691"></A><A NAME="_Toc481064488"></A><BR></P></DIV>
<A NAME="Heading53"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Analysis and
design<BR><A NAME="Index105"></A><A NAME="Index106"></A><A NAME="Index107"></A><A NAME="Index108"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The object-oriented paradigm is a new and
different way of thinking about programming. Many folks have trouble at first
knowing how to approach an OOP project. Once you know that everything is
supposed to be an object, and as you learn to think more in an object-oriented
style, you can begin to create &#8220;good&#8221; designs that take advantage of
all the benefits that OOP has to
offer.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I148' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I149>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index109"></A><FONT FACE="Georgia">A <I>method</I>
(often called a <I>methodology</I>)<I> </I>is a set of processes and heuristics
used to break down the complexity of a programming problem. Many OOP methods
have been formulated since the dawn of object-oriented programming. This section
will give you a feel for what you&#8217;re trying to accomplish when using a
method.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I149' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I150>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Especially in OOP, methodology is a field
of many experiments, so it is important to understand what problem the method is
trying to solve before you consider adopting one. This is particularly true with
Java, in which the programming language is intended to reduce the complexity
(compared to C) involved in expressing a program. This may in fact alleviate the
need for ever-more-complex methodologies. Instead, simple methodologies may
suffice in Java for a much larger class of problems than you could handle using
simple methodologies with procedural
languages.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I150' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I151>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s also important to realize that
the term &#8220;methodology&#8221; is often too grand and promises too much.
Whatever you do now when you design and write a program is a method. It may be
your own method, and you may not be conscious of doing it, but it is a process
you go through as you create. If it is an effective process, it may need only a
small tune-up to work with Java. If you are not satisfied with your productivity
and the way your programs turn out, you may want to consider adopting a formal
method, or choosing pieces from among the many formal
methods.<I>
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I151' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I152>
</I></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While you&#8217;re going through the
development process, the most important issue is this: Don&#8217;t get lost.
It&#8217;s easy to do. Most of the analysis and design
<A NAME="Index110"></A>methods are intended to solve the largest of problems.
Remember that most projects don&#8217;t fit into that category, so you can
usually have successful analysis and design with a relatively small subset of
what a method
recommends</FONT><A NAME="fnB8" HREF="#fn8">[8]</A><A NAME="Index111"></A><FONT FACE="Georgia">.
But some sort of process, no matter how limited, will generally get you on your
way in a much better fashion than simply beginning to
code.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I152' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I153>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s also easy to get stuck, to
fall into &#8220;<A NAME="Index112"></A><A NAME="Index113"></A>analysis
paralysis,&#8221; where you feel like you can&#8217;t move forward because you
haven&#8217;t nailed down every little detail at the current stage. Remember, no
matter how much analysis you do, there are some things about a system that
won&#8217;t reveal themselves until design time, and more things that
won&#8217;t reveal themselves until you&#8217;re coding, or not even until a
program is up and running. Because of this, it&#8217;s crucial to move fairly
quickly through analysis and design, and to implement a test of the proposed
system.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I153' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I154>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This point is worth emphasizing. Because
of the history we&#8217;ve had with procedural languages, it is commendable that
a team will want to proceed carefully and understand every minute detail before
moving to design and implementation. Certainly, when creating a DBMS, it pays to
understand a customer&#8217;s needs thoroughly. But a DBMS is in a class of
problems that is very well-posed and well-understood; in many such programs, the
database structure <I>is</I> the problem to be tackled. The class of programming
problem discussed in this chapter is of the &#8220;wild-card&#8221; (my term)
variety, in which the solution isn&#8217;t simply re-forming a well-known
solution, but instead involves one or more
&#8220;wild-card<A NAME="Index114"></A> factors&#8221;&#8212;elements for which
there is no well-understood previous solution, and for which research is
necessary</FONT><A NAME="fnB9" HREF="#fn9">[9]</A><FONT FACE="Georgia">.
Attempting to thoroughly analyze a wild-card problem before moving into design
and implementation results in analysis paralysis because you don&#8217;t have
enough information to solve this kind of problem during the analysis phase.
Solving such a problem requires iteration through the whole cycle, and that
requires risk-taking behavior (which makes sense, because you&#8217;re trying to
do something new and the potential rewards are higher). It may seem like the
risk is compounded by &#8220;rushing&#8221; into a preliminary implementation,
but it can instead reduce the risk in a wild-card project because you&#8217;re
finding out early whether a particular approach to the problem is viable.
Product development is risk
management.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I154' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I155>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s often proposed that you
&#8220;build one to throw away.&#8221; With OOP, you may still throw <I>part</I>
of it away, but because code is encapsulated into classes, during the first pass
you will inevitably produce some useful class designs and develop some
worthwhile ideas about the system design that do not need to be thrown away.
Thus, the first rapid pass at a problem not only produces critical information
for the next analysis, design, and implementation pass, it also creates a code
foundation.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I155' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I156>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That said, if you&#8217;re looking at a
methodology that contains tremendous detail and suggests many steps and
documents, it&#8217;s still difficult to know when to stop. Keep in mind what
you&#8217;re trying to
discover:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I156' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I157>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">What are the objects? (How
do you partition your project into its component
parts?)</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">What are
their interfaces? (What messages do you need to send to each
object?)</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you come up with
nothing more than the objects and their interfaces, then you can write a
program. For various reasons you might need more descriptions and documents than
this, but you can&#8217;t get away with any
less.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I157' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I158>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The process can be undertaken in five
phases, and a Phase 0 that is just the initial commitment to using some kind of
structure.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I158' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I159>
</FONT><A NAME="_Toc408018410"></A><A NAME="_Toc472654692"></A><A NAME="_Toc481064489"></A><BR></P></DIV>
<A NAME="Heading54"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 0: Make a plan</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You must first decide what steps
you&#8217;re going to have in your process. It sounds simple (in fact,
<I>all</I> of this sounds simple), and yet people often don&#8217;t make this
decision before they start coding. If your plan is &#8220;let&#8217;s jump in
and start coding,&#8221; fine. (Sometimes that&#8217;s appropriate when you have
a well-understood problem.) At least agree that this is the
<A NAME="Index115"></A>plan.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I159' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I160>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might also decide at this phase that
some additional process structure is necessary, but not the whole nine yards.
Understandably, some programmers like to work in &#8220;vacation mode,&#8221; in
which no structure is imposed on the process of developing their work; &#8220;It
will be done when it&#8217;s done.&#8221; This can be appealing for a while, but
I&#8217;ve found that having a few milestones along the way helps to focus and
galvanize your efforts around those milestones instead of being stuck with the
single goal of &#8220;finish the project.&#8221; In addition, it divides the
project into more bite-sized pieces and makes it seem less threatening (plus the
milestones offer more opportunities for
celebration).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I160' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I161>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When I began to study story structure (so
that I will someday write a novel) I was initially resistant to the idea of
structure, feeling that I wrote best when I simply let it flow onto the page.
But I later realized that when I write about computers the structure is clear
enough to me that I don&#8217;t have to think about it very much. But I still
structure my work, albeit only semi-consciously in my head. Even if you think
that your plan is to just start coding, you still somehow go through the
subsequent phases while asking and answering certain
questions.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I161' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I162>
</FONT><A NAME="_Toc408018411"></A><BR></P></DIV>
<A NAME="Heading55"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The mission statement<BR><A NAME="Index116"></A><A NAME="Index117"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any system you build, no matter how
complicated, has a fundamental purpose; the business that it&#8217;s in, the
basic need that it satisfies. If you can look past the user interface, the
hardware- or system-specific details, the coding algorithms and the efficiency
problems, you will eventually find the core of its being&#8212;simple and
straightforward. Like the so-called
<A NAME="Index118"></A><A NAME="Index119"></A><I>high concept</I> from a
Hollywood movie, you can describe it in one or two sentences. This pure
description is the starting
point.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I162' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I163>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The high concept is quite important
because it sets the tone for your project; it&#8217;s a mission statement. You
won&#8217;t necessarily get it right the first time (you may be in a later phase
of the project before it becomes completely clear), but keep trying until it
feels right. For example, in an air-traffic control system you may start out
with a high concept focused on the system that you&#8217;re building: &#8220;The
tower program keeps track of the aircraft.&#8221; But consider what happens when
you shrink the system to a very small airfield; perhaps there&#8217;s only a
human controller, or none at all. A more useful model won&#8217;t concern the
solution you&#8217;re creating as much as it describes the problem:
&#8220;Aircraft arrive, unload, service and reload, then
depart.&#8221;
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I163' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I164>
</FONT><A NAME="_Toc472654693"></A><A NAME="_Toc481064490"></A><BR></P></DIV>
<A NAME="Heading56"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 1: What are we making?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the previous generation of program
design (called <I>procedural design</I>), this is called &#8220;creating the
<A NAME="Index120"></A><A NAME="Index121"></A><I>requirements analysis</I> and
<A NAME="Index122"></A><A NAME="Index123"></A><I>system
specification</I>.&#8221; These, of course, were places to get lost;
intimidatingly named documents that could become big projects in their own
right. Their intention was good, however. The requirements analysis says
&#8220;Make a list of the guidelines we will use to know when the job is done
and the customer is satisfied.&#8221; The system specification says
&#8220;Here&#8217;s a description of <I>what</I> the program will do (not
<I>how</I>) to satisfy the requirements.&#8221; The requirements analysis is
really a contract between you and the customer (even if the customer works
within your company, or is some other object or system). The system
specification is a top-level exploration into the problem and in some sense a
discovery of whether it can be done and how long it will take. Since both of
these will require consensus among people (and because they will usually change
over time), I think it&#8217;s best to keep them as bare as
possible&#8212;ideally, to lists and basic diagrams&#8212;to save time. You
might have other constraints that require you to expand them into bigger
documents, but by keeping the initial document small and concise, it can be
created in a few sessions of group brainstorming with a leader who dynamically
creates the description. This not only solicits input from everyone, it also
fosters initial buy-in and agreement by everyone on the team. Perhaps most
importantly, it can kick off a project with a lot of
enthusiasm.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I164' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I165>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s necessary to stay focused on
the heart of what you&#8217;re trying to accomplish in this phase: determine
what the system is supposed to do. The most valuable tool for this is a
collection of what are called &#8220;<A NAME="Index124"></A>use cases.&#8221;
Use cases identify key features in the system that will reveal some of the
fundamental classes you&#8217;ll be using. These are essentially descriptive
answers to questions
like</FONT><A NAME="fnB10" HREF="#fn10">[10]</A><FONT FACE="Georgia">:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I165' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I166>
</FONT><BR></P></DIV>
<UL>
<LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">&#8220;Who will use this
system?&#8221;
</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">&#8220;What can
those actors do with the system?&#8221; 
</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">&#8220;How does
<I>this</I> actor do <I>that</I> with this
system?&#8221;</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">&#8220;How
else might this work if someone else were doing this, or if the same actor had a
different objective?&#8221; (to reveal
variations)</FONT><LI><FONT FACE="Symbol">	</FONT><FONT FACE="Georgia">&#8220;What
problems might happen while doing this with the system?&#8221; (to reveal
exceptions)</FONT></UL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are
designing an auto-teller, for example, the use case for a particular aspect of
the functionality of the system is able to describe what the auto-teller does in
every possible situation. Each of these &#8220;situations&#8221; is referred to
as a <A NAME="Index125"></A><I>scenario</I>, and a use case can be considered a
collection of scenarios. You can think of a scenario as a question that starts
with: &#8220;What does the system do if...?&#8221; For example, &#8220;What does
the auto-teller do if a customer has just deposited a check within the last 24
hours, and there&#8217;s not enough in the account without the check having
cleared to provide a desired withdrawal?&#8221;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I166' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I167>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index126"></A><FONT FACE="Georgia">Use case diagrams
are intentionally simple to prevent you from getting bogged down in system
implementation details prematurely:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ212.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each stick person represents an
&#8220;<A NAME="Index127"></A>actor,&#8221; which is typically a human or some
other kind of free agent. (These can even be other computer systems, as is the
case with &#8220;ATM.&#8221;) The box represents the boundary of your system.
The ellipses represent the use cases, which are descriptions of valuable work
that can be performed with the system. The lines between the actors and the use
cases represent the
interactions.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I167' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I168>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It doesn&#8217;t matter how the system is
actually implemented, as long as it looks like this to the
user.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I168' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I169>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A use case does not need to be terribly
complex, even if the underlying system is complex. It is only intended to show
the system as it appears to the user. For
example:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I169' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I170>
</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ213.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use cases produce the requirements
specifications by determining all the interactions that the user may have with
the system. You try to discover a full set of use cases for your system, and
once you&#8217;ve done that you have the core of what the system is supposed to
do. The nice thing about focusing on use cases is that they always bring you
back to the essentials and keep you from drifting off into issues that
aren&#8217;t critical for getting the job done. That is, if you have a full set
of use cases, you can describe your system and move onto the next phase. You
probably won&#8217;t get it all figured out perfectly on the first try, but
that&#8217;s OK. Everything will reveal itself in time, and if you demand a
perfect system specification at this point you&#8217;ll get
stuck.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I170' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I171>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you do get stuck, you can kick-start
this phase by using a rough approximation tool: describe the system in a few
paragraphs and then look for nouns and verbs. The nouns can suggest actors,
context of the use case (e.g., &#8220;lobby&#8221;), or artifacts manipulated in
the use case. Verbs can suggest interactions between actors and use cases, and
specify steps within the use case. You&#8217;ll also discover that nouns and
verbs produce objects and messages during the design phase (and note that use
cases describe interactions between subsystems, so the &#8220;noun and
verb&#8221; technique can be used only as a brainstorming tool as it does not
generate use cases)</FONT><SUP><FONT FACE="Georgia" SIZE=2><B>
</B></FONT></SUP><A NAME="fnB11" HREF="#fn11">[11]</A><FONT FACE="Georgia">.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I171' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I172>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The boundary between a use case and an
actor can point out the existence of a
<A NAME="Index128"></A><A NAME="Index129"></A>user interface, but it does not
define such a user interface. For a process of defining and creating user
interfaces, see <I>Software for Use</I> by Larry Constantine and Lucy Lockwood,
(Addison-Wesley Longman, 1999) or go to
<I>www.ForUse.com</I>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I172' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I173>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although it&#8217;s a black art, at this
point some kind of basic <A NAME="Index130"></A>scheduling is important. You now
have an overview of what you&#8217;re building, so you&#8217;ll probably be able
to get some idea of how long it will take. A lot of factors come into play here.
If you estimate a long schedule then the company might decide not to build it
(and thus use their resources on something more reasonable&#8212;that&#8217;s a
<I>good</I> thing). Or a manager might have already decided how long the project
should take and will try to influence your estimate. But it&#8217;s best to have
an honest schedule from the beginning and deal with the tough decisions early.
There have been a lot of attempts to come up with accurate scheduling techniques
(much like techniques to predict the stock market), but probably the best
approach is to rely on your experience and intuition. Get a gut feeling for how
long it will really take, then double that and add 10 percent. Your gut feeling
is probably correct; you <I>can</I> get something working in that time. The
&#8220;doubling&#8221; will turn that into something decent, and the 10 percent
will deal with the final polishing and
details</FONT><A NAME="fnB12" HREF="#fn12">[12]</A><FONT FACE="Georgia">.
However you want to explain it, and regardless of the moans and manipulations
that happen when you reveal such a schedule, it just seems to work out that
way.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I173' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I174>
</FONT><A NAME="_Toc408018412"></A><A NAME="_Toc472654694"></A><A NAME="_Toc481064491"></A><BR></P></DIV>
<A NAME="Heading57"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 2: How will we build it?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this phase you must come up with a
design that describes what the classes look like and how they will interact. An
excellent technique in determining classes and interactions is the
<A NAME="Index131"></A><A NAME="Index132"></A><I>Class-Responsibility-Collaboration</I>
(CRC) card. Part of the value of this tool is that it&#8217;s so low-tech: you
start out with a set of blank 3 x 5 cards, and you write on them. Each card
represents a single class, and on the card you
write:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I174' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I175>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The name of the class.
It&#8217;s important that this name capture the essence of what the class does,
so that it makes sense at a glance.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I175' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I176>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
&#8220;responsibilities&#8221; of the class: what it should do. This can
typically be summarized by just stating the names of the member functions (since
those names should be descriptive in a good design), but it does not preclude
other notes. If you need to seed the process, look at the problem from a lazy
programmer&#8217;s standpoint: What objects would you like to magically appear
to solve your problem?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I176' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I177>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
&#8220;collaborations&#8221; of the class: what other classes does it interact
with? &#8220;Interact&#8221; is an intentionally broad term; it could mean
aggregation or simply that some other object exists that will perform services
for an object of the class. Collaborations should also consider the audience for
this class. For example, if you create a class <B>Firecracker</B>, who is going
to observe it, a <B>Chemist</B> or a <B>Spectator</B>? The former will want to
know what chemicals go into the construction, and the latter will respond to the
colors and shapes released when it explodes.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I177' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I178>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You
may feel like the cards should be bigger because of all the information
you&#8217;d like to get on them, but they are intentionally small, not only to
keep your classes small but also to keep you from getting into too much detail
too early. If you can&#8217;t fit all you need to know about a class on a small
card, the class is too complex (either you&#8217;re getting too detailed, or you
should create more than one class). The ideal class should be understood at a
glance. The idea of CRC cards is to assist you in coming up with a first cut of
the design so that you can get the big picture and then refine your
design.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I178' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I179>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the great benefits of CRC cards is
in communication. It&#8217;s best done real time, in a group, without computers.
Each person takes responsibility for several classes (which at first have no
names or other information). You run a live simulation by solving one scenario
at a time, deciding which messages are sent to the various objects to satisfy
each scenario. As you go through this process, you discover the classes that you
need along with their responsibilities and collaborations, and you fill out the
cards as you do this. When you&#8217;ve moved through all the use cases, you
should have a fairly complete first cut of your
design.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I179' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I180>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before I began using CRC cards, the most
successful consulting experiences I had when coming up with an initial design
involved standing in front of a team&#8212;who hadn&#8217;t built an OOP project
before&#8212;and drawing objects on a whiteboard. We talked about how the
objects should communicate with each other, and erased some of them and replaced
them with other objects. Effectively, I was managing all the &#8220;CRC
cards&#8221; on the whiteboard. The team (who knew what the project was supposed
to do) actually created the design; they &#8220;owned&#8221; the design rather
than having it given to them. All I was doing was guiding the process by asking
the right questions, trying out the assumptions, and taking the feedback from
the team to modify those assumptions. The true beauty of the process was that
the team learned how to do object-oriented design not by reviewing abstract
examples, but by working on the one design that was most interesting to them at
that moment: theirs.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I180' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I181>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you&#8217;ve come up with a set of
CRC cards, you may want to create a more formal description of your design using
UML</FONT><A NAME="fnB13" HREF="#fn13">[13]</A><FONT FACE="Georgia">. You
don&#8217;t need to use <A NAME="Index133"></A>UML, but it can be helpful,
especially if you want to put up a diagram on the wall for everyone to ponder,
which is a good idea. An alternative to UML is a textual description of the
objects and their interfaces, or, depending on your programming language, the
code
itself</FONT><A NAME="fnB14" HREF="#fn14">[14]</A><A NAME="Index134"></A><FONT FACE="Georgia">.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I181' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I182>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">UML also provides an additional
diagramming notation for describing the dynamic model of your system. This is
helpful in situations in which the state transitions of a system or subsystem
are dominant enough that they need their own diagrams (such as in a control
system). You may also need to describe the data structures, for systems or
subsystems in which data is a dominant factor (such as a
database).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I182' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I183>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll know you&#8217;re done with
Phase 2 when you have described the objects and their interfaces. Well, most of
them&#8212;there are usually a few that slip through the cracks and don&#8217;t
make themselves known until Phase 3. But that&#8217;s OK. All you are concerned
with is that you eventually discover all of your objects. It&#8217;s nice to
discover them early in the process, but OOP provides enough structure so that
it&#8217;s not so bad if you discover them later. In fact, the design of an
object tends to happen in five stages, throughout the process of program
development.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I183' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I184>
</FONT><A NAME="_Toc408018413"></A><A NAME="_Toc312373799"></A><BR></P></DIV>
<A NAME="Heading58"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Five stages of object
design<BR><A NAME="Index135"></A><A NAME="Index136"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The design life of an object is not
limited to the time when you&#8217;re writing the program. Instead, the design
of an object appears over a sequence of stages. It&#8217;s helpful to have this
perspective because you stop expecting perfection right away; instead, you
realize that the understanding of what an object does and what it should look
like happens over time. This view also applies to the design of various types of
programs; the pattern for a particular type of program emerges through
struggling again and again with that problem (This is chronicled in the book
<I>Thinking in Patterns with Java</I>, downloadable at
<I>www.BruceEckel.com</I>). Objects, too, have their patterns that emerge
through understanding, use, and
reuse.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I184' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I185>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>1. Object
discovery.</B></FONT><FONT FACE="Georgia"><B> </B>This stage occurs during the
initial analysis of a program. Objects may be discovered by looking for external
factors and boundaries, duplication of elements in the system, and the smallest
conceptual units. Some objects are obvious if you already have a set of class
libraries. Commonality between classes suggesting base classes and inheritance
may appear right away, or later in the design
process.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I185' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I186>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>2. Object
assembly.</B></FONT><FONT FACE="Georgia"><B> </B>As you&#8217;re building an
object you&#8217;ll discover the need for new members that didn&#8217;t appear
during discovery. The internal needs of the object may require other classes to
support it.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I186' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I187>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>3. System
construction.</B></FONT><FONT FACE="Georgia"><B> </B>Once again, more
requirements for an object may appear at this later stage. As you learn, you
evolve your objects. The need for communication and interconnection with other
objects in the system may change the needs of your classes or require new
classes. For example, you may discover the need for facilitator or helper
classes, such as a linked list, that contain little or no state information and
simply help other classes
function.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I187' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I188>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>4. System
extension.</B></FONT><FONT FACE="Georgia"><B> </B>As you add new features to a
system you may discover that your previous design doesn&#8217;t support easy
system extension. With this new information, you can restructure parts of the
system, possibly adding new classes or class
hierarchies.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I188' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I189>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>5. Object
reuse.</B></FONT><FONT FACE="Georgia"><B> <A NAME="Index137"></A></B>This is the
real stress test for a class. If someone tries to reuse it in an entirely new
situation, they&#8217;ll probably discover some shortcomings. As you change a
class to adapt to more new programs, the general principles of the class will
become clearer, until you have a truly reusable type. However, don&#8217;t
expect most objects from a system design to be reusable&#8212;it is perfectly
acceptable for the bulk of your objects to be system-specific. Reusable types
tend to be less common, and they must solve more general problems in order to be
reusable.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I189' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I190>
</FONT><BR></P></DIV>
<A NAME="Heading59"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Guidelines for object
development<BR><A NAME="Index138"></A><A NAME="Index139"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These stages suggest some guidelines when
thinking about developing your
classes:
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I190' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I191>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Let a specific problem
generate a class, then let the class grow and mature during the solution of
other problems.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I191' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I192>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Remember,
discovering the classes you need (and their interfaces) is the majority of the
system design. If you already had those classes, this would be an easy project.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I192' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I193>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Don&#8217;t
force yourself to know everything at the beginning; learn as you go. This will
happen anyway.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I193' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I194>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Start
programming; get something working so you can prove or disprove your design.
Don&#8217;t fear that you&#8217;ll end up with procedural-style spaghetti
code&#8212;classes partition the problem and help control anarchy and entropy.
Bad classes do not break good classes.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I194' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I195>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Always
keep it simple. Little clean objects with obvious utility are better than big
complicated interfaces. When decision points come up, use an Occam&#8217;s Razor
approach: Consider the choices and select the one that is simplest, because
simple classes are almost always best. Start small and simple, and you can
expand the class interface when you understand it better. As time goes on,
it&#8217;s difficult to remove elements from a class.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I195' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I196>
</FONT><A NAME="_Toc472654695"></A><A NAME="_Toc481064492"></A></OL><A NAME="Heading60"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 3: Build the core</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the initial conversion from the
rough design into a compiling and executing body of code that can be tested, and
especially that will prove or disprove your architecture. This is not a one-pass
process, but rather the beginning of a series of steps that will iteratively
build the system, as you&#8217;ll see in Phase
4.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I196' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I197>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Your goal is to find the core of your
system architecture that needs to be implemented in order to generate a running
system, no matter how incomplete that system is in this initial pass.
You&#8217;re creating a framework that you can build on with further iterations.
You&#8217;re also performing the first of many system integrations and tests,
and giving the stakeholders feedback about what their system will look like and
how it is progressing. Ideally, you are also exposing some of the critical
risks. You&#8217;ll probably also discover changes and improvements that can be
made to your original architecture&#8212;things you would not have learned
without implementing the
system.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I197' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I198>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Part of building the system is the
reality check that you get from testing against your requirements analysis and
system specification (in whatever form they exist). Make sure that your tests
verify the requirements and use cases. When the core of the system is stable,
you&#8217;re ready to move on and add more
functionality.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I198' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I199>
</FONT><A NAME="_Toc408018414"></A><A NAME="_Toc472654696"></A><A NAME="_Toc481064493"></A><BR></P></DIV>
<A NAME="Heading61"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 4: Iterate the <A NAME="Index140"></A>use cases</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the core framework is running, each
feature set you add is a small project in itself. You add a feature set during
an <A NAME="Index141"></A><I>iteration</I>, a reasonably short period of
development.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I199' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I200>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">How big is an iteration? Ideally, each
iteration lasts one to three weeks (this can vary based on the implementation
language). At the end of that period, you have an integrated, tested system with
more functionality than it had before. But what&#8217;s particularly interesting
is the basis for the iteration: a single use case. Each use case is a package of
related functionality that you build into the system all at once, during one
iteration. Not only does this give you a better idea of what the
<A NAME="Index142"></A><A NAME="Index143"></A>scope of a use case should be, but
it also gives more validation to the idea of a use case, since the concept
isn&#8217;t discarded after analysis and design, but instead it is a fundamental
unit of development throughout the software-building process.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I200' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I201>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You stop iterating when you achieve
target functionality or an external deadline arrives and the customer can be
satisfied with the current version. (Remember, software is a subscription
business.) Because the process is iterative, you have many opportunities to ship
a product rather than a single endpoint; open-source projects work exclusively
in an iterative, high-feedback environment, which is precisely what makes them
successful.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I201' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I202>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An iterative development process is
valuable for many reasons. You can reveal and resolve critical risks early, the
customers have ample opportunity to change their minds, programmer satisfaction
is higher, and the project can be steered with more precision. But an additional
important benefit is the feedback to the stakeholders, who can see by the
current state of the product exactly where everything lies. This may reduce or
eliminate the need for mind-numbing status meetings and increase the confidence
and support from the
stakeholders.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I202' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I203>
</FONT><A NAME="_Toc472654697"></A><A NAME="_Toc481064494"></A><BR></P></DIV>
<A NAME="Heading62"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Phase 5: <A NAME="Index144"></A>Evolution</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the point in the development
cycle that has traditionally been called
&#8220;<A NAME="Index145"></A><A NAME="Index146"></A>maintenance,&#8221; a
catch-all term that can mean everything from &#8220;getting it to work the way
it was really supposed to in the first place&#8221; to &#8220;adding features
that the customer forgot to mention&#8221; to the more traditional &#8220;fixing
the bugs that show up&#8221; and &#8220;adding new features as the need
arises.&#8221; So many misconceptions have been applied to the term
&#8220;maintenance&#8221; that it has taken on a slightly deceiving quality,
partly because it suggests that you&#8217;ve actually built a pristine program
and all you need to do is change parts, oil it, and keep it from rusting.
Perhaps there&#8217;s a better term to describe what&#8217;s going
on.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I203' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I204>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I&#8217;ll use the term
<I>evolution</I></FONT><A NAME="fnB15" HREF="#fn15">[15]</A><A NAME="Index147"></A><A NAME="Index148"></A><FONT FACE="Georgia">.
That is, &#8220;You won&#8217;t get it right the first time, so give yourself
the latitude to learn and to go back and make changes.&#8221; You might need to
make a lot of changes as you learn and understand the problem more deeply. The
elegance you&#8217;ll produce if you evolve until you get it right will pay off,
both in the short and the long term. Evolution is where your program goes from
good to great, and where those issues that you didn&#8217;t really understand in
the first pass become clear. It&#8217;s also where your classes can evolve from
single-project usage to reusable
resources.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I204' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I205>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What it means to &#8220;get it
right&#8221; isn&#8217;t just that the program works according to the
requirements and the use cases. It also means that the internal structure of the
code makes sense to you, and feels like it fits together well, with no awkward
syntax, oversized objects, or ungainly exposed bits of code. In addition, you
must have some sense that the program structure will survive the changes that it
will inevitably go through during its lifetime, and that those changes can be
made easily and cleanly. This is no small feat. You must not only understand
what you&#8217;re building, but also how the program will evolve (what I call
the <A NAME="Index149"></A><I>vector of change</I>). Fortunately,
object-oriented programming languages are particularly adept at supporting this
kind of continuing modification&#8212;the boundaries created by the objects are
what tend to keep the structure from breaking down. They also allow you to make
changes&#8212;ones that would seem drastic in a procedural program&#8212;without
causing earthquakes throughout your code. In fact, support for evolution might
be the most important benefit of
OOP.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I205' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I206>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With evolution, you create something that
at least approximates what you think you&#8217;re building, and then you kick
the tires, compare it to your requirements, and see where it falls short. Then
you can go back and fix it by redesigning and reimplementing the portions of the
program that didn&#8217;t work
right</FONT><A NAME="fnB16" HREF="#fn16">[16]</A><A NAME="Index150"></A><A NAME="Index151"></A><FONT FACE="Georgia">.
You might actually need to solve the problem, or an aspect of the problem,
several times before you hit on the right solution. (A study of
<A NAME="Index152"></A><A NAME="Index153"></A><I>Design Patterns </I>is usually
helpful here. You can find information in <I>Thinking in Patterns with Java</I>,
downloadable at
<I>www.BruceEckel.com</I>.)
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I206' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I207>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Evolution also occurs when you build a
system, see that it matches your requirements, and then discover it wasn&#8217;t
actually what you wanted. When you see the system in operation, you find that
you really wanted to solve a different problem. If you think this kind of
evolution is going to happen, then you owe it to yourself to build your first
version as quickly as possible so you can find out if it is indeed what you
want.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I207' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I208>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Perhaps the most important thing to
remember is that by default&#8212;by definition, really&#8212;if you modify a
class, its super- and subclasses will still function. You need not fear
modification (especially if you have a built-in set of unit tests to verify the
correctness of your modifications). Modification won&#8217;t necessarily break
the program, and any change in the outcome will be limited to subclasses and/or
specific collaborators of the class you
change.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I208' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I209>
</FONT><A NAME="_Toc408018415"></A><A NAME="_Toc472654698"></A><A NAME="_Toc481064495"></A><BR></P></DIV>
<A NAME="Heading63"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Plans pay off</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course you wouldn&#8217;t build a
house without a lot of carefully drawn plans. If you build a deck or a dog house
your plans won&#8217;t be so elaborate, but you&#8217;ll probably still start
with some kind of sketches to guide you on your way. Software development has
gone to extremes. For a long time, people didn&#8217;t have much structure in
their development, but then big projects began failing. In reaction, we ended up
with methodologies that had an intimidating amount of structure and detail,
primarily intended for those big projects. These methodologies were too scary to
use&#8212;it looked like you&#8217;d spend all your time writing documents and
no time programming. (This was often the case.) I hope that what I&#8217;ve
shown you here suggests a middle path&#8212;a sliding scale. Use an approach
that fits your needs (and your personality). No matter how minimal you choose to
make it, <I>some</I> kind of plan will make a big improvement in your project as
opposed to no plan at all. Remember that, by most estimates, over 50 percent of
projects fail (some estimates go up to 70 percent!).<A NAME="_Toc312373783"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I209' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I210>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By following a plan&#8212;preferably one
that is simple and brief&#8212;and coming up with design structure before
coding, you&#8217;ll discover that things fall together far more easily than if
you dive in and start hacking. You&#8217;ll also realize a great deal of
satisfaction. It&#8217;s my experience that coming up with an elegant solution
is deeply satisfying at an entirely different level; it feels closer to art than
technology. And <A NAME="Index154"></A>elegance always pays off; it&#8217;s not
a frivolous pursuit. Not only does it give you a program that&#8217;s easier to
build and debug, but it&#8217;s also easier to understand and maintain, and
that&#8217;s where the financial value
lies.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I210' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I211>
</FONT><A NAME="_Toc312373787"></A><A NAME="_Toc472654699"></A><A NAME="_Toc481064496"></A><BR></P></DIV>
<A NAME="Heading64"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Extreme programming</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I have studied analysis and design
techniques, on and off, since I was in graduate school. The concept of
<A NAME="Index155"></A><A NAME="Index156"></A><A NAME="Index157"></A><I>Extreme
Programming</I> (XP) is the most radical, and delightful, that I&#8217;ve seen.
You can find it chronicled in <I>Extreme Programming Explained</I> by Kent Beck
(Addison-Wesley, 2000) and on the Web at
<I>www.xprogramming.com</I>.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I211' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I212>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">XP is both a philosophy about programming
work and a set of guidelines to do it. Some of these guidelines are reflected in
other recent methodologies, but the two most important and distinct
contributions, in my opinion, are &#8220;write tests first&#8221; and
&#8220;pair programming.&#8221; Although he argues strongly for the whole
process, Beck points out that if you adopt only these two practices you&#8217;ll
greatly improve your productivity and
reliability.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I212' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I213>
</FONT><A NAME="_Toc472654700"></A><A NAME="_Toc481064497"></A><BR></P></DIV>
<A NAME="Heading65"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Write tests first<BR><A NAME="Index158"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Testing has traditionally been relegated
to the last part of a project, after you&#8217;ve &#8220;gotten everything
working, but just to be sure.&#8221; It&#8217;s implicitly had a low priority,
and people who specialize in it have not been given a lot of status and have
often even been cordoned off in a basement, away from the &#8220;real
programmers.&#8221; Test teams have responded in kind, going so far as to wear
black clothing and cackling with glee whenever they break something (to be
honest, I&#8217;ve had this feeling myself when breaking
compilers).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I213' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I214>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">XP completely revolutionizes the concept
of testing by giving it equal (or even greater) priority than the code. In fact,
you write the tests <I>before</I> you write the code that will be tested, and
the tests stay with the code forever. The tests must be executed successfully
every time you do an integration of the project (which is often, sometimes more
than once a day).
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I214' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I215>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Writing tests first has two extremely
important effects.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I215' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I216>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, it forces a clear definition of
the <A NAME="Index159"></A><A NAME="Index160"></A>interface of a class.
I&#8217;ve often suggested that people &#8220;imagine the perfect class to solve
a particular problem&#8221; as a tool when trying to design the system. The XP
testing strategy goes further than that&#8212;it specifies exactly what the
class must look like, to the consumer of that class, and exactly how the class
must behave. In no uncertain terms. You can write all the prose, or create all
the diagrams you want, describing how a class should behave and what it looks
like, but nothing is as real as a set of tests. The former is a wish list, but
the tests are a contract that is enforced by the compiler and the running
program. It&#8217;s hard to imagine a more concrete description of a class than
the tests.
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I216' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I217>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While creating the tests, you are forced
to completely think out the class and will often discover needed functionality
that might be missed during the thought experiments of UML diagrams, CRC cards,
use cases, etc. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I217' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I218>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index161"></A><FONT FACE="Georgia">The second
important effect of writing the tests first comes from running the tests every
time you do a build of your software. This activity gives you the other half of
the testing that&#8217;s performed by the compiler. If you look at the evolution
of programming languages from this perspective, you&#8217;ll see that the real
improvements in the technology have actually revolved around testing. Assembly
language checked only for syntax, but C imposed some semantic restrictions, and
these prevented you from making certain types of mistakes. OOP languages impose
even more semantic restrictions, which if you think about it are actually forms
of testing. &#8220;Is this data type being used properly?&#8221; and &#8220;Is
this function being called properly?&#8221; are the kinds of tests that are
being performed by the compiler or run-time system. We&#8217;ve seen the results
of having these tests built into the language: people have been able to write
more complex systems, and get them to work, with much less time and effort.
I&#8217;ve puzzled over why this is, but now I realize it&#8217;s the tests: you
do something wrong, and the safety net of the built-in tests tells you
there&#8217;s a problem and points you to where it is.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I218' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I219>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">But the built-in testing afforded by the
design of the language can only go so far. At some point, <I>you</I> must step
in and add the rest of the tests that produce a full suite (in cooperation with
the compiler and run-time system) that verifies all of your program. And, just
like having a compiler watching over your shoulder, wouldn&#8217;t you want
these tests helping you right from the beginning? That&#8217;s why you write
them first, and run them automatically with every build of your system. Your
tests become an extension of the safety net provided by the language.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I219' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I220>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the things that I&#8217;ve
discovered about the use of more and more powerful programming languages is that
I am emboldened to try more brazen experiments, because I know that the language
will keep me from wasting my time chasing bugs. The XP test scheme does the same
thing for your entire project. Because you know your tests will always catch any
problems that you introduce (and you regularly add any new tests as you think of
them), you can make big changes when you need to without worrying that
you&#8217;ll throw the whole project into complete disarray. This is incredibly
powerful. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I220' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I221>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index162"></A><A NAME="Index163"></A><A NAME="_Toc472654701"></A><A NAME="_Toc481064498"></A><BR></P></DIV>
<A NAME="Heading66"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Pair programming</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pair programming goes against the rugged
individualism that we&#8217;ve been indoctrinated into from the beginning,
through school (where we succeed or fail on our own, and working with our
neighbors is considered &#8220;cheating&#8221;), and media, especially Hollywood
movies in which the hero is usually fighting against mindless
conformity</FONT><A NAME="fnB17" HREF="#fn17">[17]</A><FONT FACE="Georgia">.
Programmers, too, are considered paragons of individuality&#8212;&#8220;cowboy
coders&#8221; as Larry Constantine likes to say. And yet XP, which is itself
battling against conventional thinking, says that code should be written with
two people per workstation. And that this should be done in an area with a group
of workstations, without the barriers that the facilities-design people are so
fond of. In fact, Beck says that the first task of converting to XP is to arrive
with screwdrivers and Allen wrenches and take apart everything that gets in the
way.</FONT><A NAME="fnB18" HREF="#fn18">[18]</A><FONT FACE="Georgia"> (This will
require a manager who can deflect the ire of the facilities department.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I221' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I222>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The value of pair programming is that one
person is actually doing the coding while the other is thinking about it. The
thinker keeps the big picture in mind&#8212;not only the picture of the problem
at hand, but the guidelines of XP. If two people are working, it&#8217;s less
likely that one of them will get away with saying, &#8220;I don&#8217;t want to
write the tests first,&#8221; for example. And if the coder gets stuck, they can
swap places. If both of them get stuck, their musings may be overheard by
someone else in the work area who can contribute. Working in pairs keeps things
flowing and on track. Probably more important, it makes programming a lot more
social and fun. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I222' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I223>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I&#8217;ve begun using pair programming
during the exercise periods in some of my seminars and it seems to significantly
improve everyone&#8217;s experience.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I223' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I224>
</FONT><A NAME="_Toc472654702"></A><A NAME="_Toc481064499"></A><BR></P></DIV>
<A NAME="Heading67"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Why Java succeeds</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason <A NAME="Index164"></A>Java
has been so successful is that the goal was to solve many of the problems facing
developers today. The goal of Java is improved productivity. This productivity
comes in many ways, but the language is designed to aid you as much as possible,
while hindering you as little as possible with arbitrary rules or any
requirement that you use a particular set of features. Java is designed to be
practical; Java language design decisions were based on providing the maximum
benefits to the programmer.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I224' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I225>
</FONT><A NAME="_Toc312373791"></A><A NAME="_Toc472654706"></A><A NAME="_Toc481064500"></A><BR></P></DIV>
<A NAME="Heading68"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Systems are easier <BR>to express and understand</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Classes designed to fit the problem tend
to express it better. This means that when you write the code, you&#8217;re
describing your solution in the terms of the problem space (&#8220;Put the
grommet in the bin&#8221;) rather than the terms of the computer, which is the
solution space (&#8220;Set the bit in the chip that means that the relay will
close&#8221;). You deal with higher-level concepts and can do much more with a
single line of code. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I225' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I226>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The other benefit of this ease of
expression is maintenance, which (if reports can be believed) takes a huge
portion of the cost over a program&#8217;s lifetime. If a program is easier to
understand, then it&#8217;s easier to maintain. This can also reduce the cost of
creating and maintaining the documentation.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I226' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I227>
</FONT><A NAME="_Toc312373792"></A><A NAME="_Toc472654707"></A><A NAME="_Toc481064501"></A><BR></P></DIV>
<A NAME="Heading69"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Maximal leverage with libraries</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fastest way to create a program is to
use code that&#8217;s already written: a library. A major goal in Java is to
make library use easier. This is accomplished by casting libraries into new data
types (classes), so that bringing in a library means adding new types to the
language. Because the Java compiler takes care of how the library is
used&#8212;guaranteeing proper initialization and cleanup, and ensuring that
functions are called properly&#8212;you can focus on what you want the library
to do, not how you have to do it. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I227' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I228>
</FONT><A NAME="_Toc312373793"></A><A NAME="_Toc472654709"></A><A NAME="_Toc481064502"></A><BR></P></DIV>
<A NAME="Heading70"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Error handling</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Error handling in C is a notorious
problem, and one that is often ignored&#8212;finger-crossing is usually
involved. If you&#8217;re building a large, complex program, there&#8217;s
nothing worse than having an error buried somewhere with no clue as to where it
came from. Java <I>exception handling</I> is a way to guarantee that an error is
noticed, and that something happens as a result.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I228' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I229>
</FONT><A NAME="_Toc312373794"></A><A NAME="_Toc472654710"></A><A NAME="_Toc481064503"></A><BR></P></DIV>
<A NAME="Heading71"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Programming in the large</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Many traditional languages have built-in
limitations to program size and complexity. BASIC<A NAME="Index165"></A>, for
example, can be great for pulling together quick solutions for certain classes
of problems, but if the program gets more than a few pages long, or ventures out
of the normal problem domain of that language, it&#8217;s like trying to swim
through an ever-more viscous fluid. There&#8217;s no clear line that tells you
when your language is failing you, and even if there were, you&#8217;d ignore
it. You don&#8217;t say, &#8220;My BASIC program just got too big; I&#8217;ll
have to rewrite it in C!&#8221; Instead, you try to shoehorn a few more lines in
to add that one new feature. So the extra costs come creeping up on you.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I229' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I230>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java is designed to aid
<A NAME="Index166"></A><I>programming in the large</I>&#8212;that is, to erase
those creeping-complexity boundaries between a small program and a large one.
You certainly don&#8217;t need to use OOP when you&#8217;re writing a
&#8220;hello world&#8221; style utility program, but the features are there when
you need them. And the compiler is aggressive about ferreting out bug-producing
errors for small and large programs alike.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I230' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I231>
</FONT><A NAME="_Toc312373815"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index167"></A><A NAME="_Toc472654711"></A><A NAME="_Toc481064504"></A><BR></P></DIV>
<A NAME="Heading72"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Strategies for transition</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you buy into OOP, your next question
is probably, &#8220;How can I get my manager/colleagues/department/peers to
start using objects?&#8221; Think about how you&#8212;one independent
programmer&#8212;would go about learning to use a new language and a new
programming paradigm. You&#8217;ve done it before. First comes education and
examples; then comes a trial project to give you a feel for the basics without
doing anything too confusing. Then comes a &#8220;real world&#8221; project that
actually does something useful. Throughout your first projects you continue your
education by reading, asking questions of experts, and trading hints with
friends. This is the approach many experienced programmers suggest for the
switch to Java. Switching an entire company will of course introduce certain
group dynamics, but it will help at each step to remember how one person would
do it. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I231' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I232>
</FONT><A NAME="_Toc472654712"></A><A NAME="_Toc481064505"></A><BR></P></DIV>
<A NAME="Heading73"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Guidelines</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are some guidelines to consider when
making the transition to OOP and Java:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I232' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I233>
</FONT><BR></P></DIV>
<A NAME="Heading74"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
1. <A NAME="Index168"></A>Training</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first step is some form of education.
Remember the company&#8217;s investment in code, and try not to throw everything
into disarray for six to nine months while everyone puzzles over how interfaces
work. Pick a small group for indoctrination, preferably one composed of people
who are curious, work well together, and can function as their own support
network while they&#8217;re learning Java.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An alternative approach that is sometimes
suggested is the education of all company levels at once, including overview
courses for strategic managers as well as design and programming courses for
project builders. This is especially good for smaller companies making
fundamental shifts in the way they do things, or at the division level of larger
companies. Because the cost is higher, however, some may choose to start with
project-level training, do a pilot project (possibly with an outside mentor),
and let the project team become the teachers for the rest of the company.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I233' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I234>
</FONT><BR></P></DIV>
<A NAME="Heading75"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
2. Low-risk project</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Try a low-risk project first and allow
for mistakes. Once you&#8217;ve gained some experience, you can either seed
other projects from members of this first team or use the team members as an OOP
technical support staff. This first project may not work right the first time,
so it should not be mission-critical for the company. It should be simple,
self-contained, and instructive; this means that it should involve creating
classes that will be meaningful to the other programmers in the company when
they get their turn to learn Java.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I234' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I235>
</FONT><BR></P></DIV>
<A NAME="Heading76"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
3. Model from success</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Seek out examples of good object-oriented
design before starting from scratch. There&#8217;s a good probability that
someone has solved your problem already, and if they haven&#8217;t solved it
exactly you can probably apply what you&#8217;ve learned about abstraction to
modify an existing design to fit your needs. This is the general concept of
<I>design patterns, </I>covered in <I>Thinking in Patterns with Java</I>,
downloadable at
<I>www.BruceEckel.com</I>.<A NAME="Index169"></A><A NAME="Index170"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I235' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I236>
</FONT><BR></P></DIV>
<A NAME="Heading77"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
4. Use <A NAME="Index171"></A>existing class libraries</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The primary economic motivation for
switching to OOP is the easy use of existing code in the form of class libraries
(in particular, the Standard Java libraries, which are covered throughout this
book). The shortest application development cycle will result when you can
create and use objects from off-the-shelf libraries. However, some new
programmers don&#8217;t understand this, are unaware of existing class
libraries, or, through fascination with the language, desire to write classes
that may already exist. Your success with OOP and Java will be optimized if you
make an effort to seek out and reuse other people&#8217;s code early in the
transition process. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I236' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I237>
</FONT><BR></P></DIV>
<A NAME="Heading78"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
5. Don&#8217;t rewrite existing code in Java</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is not usually the best use of your
time to take existing, functional code and rewrite it in Java. (If you must turn
it into objects, you can interface to the C or C++ code using the Java Native
Interface, described in Appendix B.) There are incremental benefits, especially
if the code is slated for reuse. But chances are you aren&#8217;t going to see
the dramatic increases in productivity that you hope for in your first few
projects unless that project is a new one. Java and OOP shine best when taking a
project from concept to reality.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I237' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I238>
</FONT><A NAME="_Toc312373817"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index172"></A><A NAME="Index173"></A><A NAME="_Toc472654713"></A><A NAME="_Toc481064506"></A><BR></P></DIV>
<A NAME="Heading79"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Management obstacles</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re a manager, your job is to
acquire resources for your team, to overcome barriers to your team&#8217;s
success, and in general to try to provide the most productive and enjoyable
environment so your team is most likely to perform those miracles that are
always being asked of you. Moving to Java falls in all three of these
categories, and it would be wonderful if it didn&#8217;t cost you anything as
well. Although moving to Java may be cheaper&#8212;depending on your
constraints&#8212;than the OOP alternatives for a team of C programmers (and
probably for programmers in other procedural languages), it isn&#8217;t free,
and there are obstacles you should be aware of before trying to sell the move to
Java within your company and embarking on the move itself.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I238' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I239>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index174"></A><A NAME="Index175"></A><BR></P></DIV>
<A NAME="Heading80"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Startup costs</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The cost of moving to Java is more than
just the acquisition of Java compilers (the Sun Java compiler is free, so this
is hardly an obstacle). Your medium- and long-term costs will be minimized if
you invest in training (and possibly mentoring for your first project) and also
if you identify and purchase class libraries that solve your problem rather than
trying to build those libraries yourself. These are hard-money costs that must
be factored into a realistic proposal. In addition, there are the hidden costs
in loss of productivity while learning a new language and possibly a new
programming environment. <A NAME="Index176"></A><A NAME="Index177"></A>Training
and mentoring can certainly minimize these, but team members must overcome their
own struggles to understand the new technology. During this process they will
make more mistakes (this is a feature, because acknowledged mistakes are the
fastest path to learning) and be less productive. Even then, with some types of
programming problems, the right classes, and the right development environment,
it&#8217;s possible to be more productive while you&#8217;re learning Java (even
considering that you&#8217;re making more mistakes and writing fewer lines of
code per day) than if you&#8217;d stayed with C.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I239' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I240>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index178"></A><BR></P></DIV>
<A NAME="Heading81"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Performance issues</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A common question is,
&#8220;Doesn&#8217;t OOP automatically make my programs a lot bigger and
slower?&#8221; The answer is, &#8220;It depends.&#8221; The extra safety
features in Java have traditionally extracted a performance penalty over a
language like C++. Technologies such as &#8220;hotspot&#8221; and compilation
technologies have improved the speed significantly in most cases, and efforts
continue toward higher performance.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I240' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I241>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When your focus is on rapid prototyping,
you can throw together components as fast as possible while ignoring efficiency
issues. If you&#8217;re using any third-party libraries, these are usually
already optimized by their vendors; in any case it&#8217;s not an issue while
you&#8217;re in rapid-development mode. When you have a system that you like, if
it&#8217;s small and fast enough, then you&#8217;re done. If not, you begin
tuning with a profiling tool, looking first for speedups that can be done by
rewriting small portions of code. If that doesn&#8217;t help, you look for
modifications that can be made in the underlying implementation so no code that
uses a particular class needs to be changed. Only if nothing else solves the
problem do you need to change the design. The fact that performance is so
critical in that portion of the design is an indicator that it must be part of
the primary design criteria. You have the benefit of finding this out early
using rapid development.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you find a function that is a
particular bottleneck, you can rewrite it in C/C++ using Java&#8217;s <I>native
methods</I>, the subject of Appendix B.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I241' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I242>
</FONT><BR></P></DIV>
<A NAME="Heading82"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Common design errors</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When starting your team into OOP and
Java, programmers will typically go through a series of common design errors.
This often happens due to insufficient feedback from experts during the design
and implementation of early projects, because no experts have been developed
within the company, and because there may be resistance to retaining
consultants. It&#8217;s easy to feel that you understand OOP too early in the
cycle and go off on a bad tangent. Something that&#8217;s obvious to someone
experienced with the language may be a subject of great internal debate for a
novice. Much of this trauma can be skipped by using an experienced outside
expert for <A NAME="Index179"></A><A NAME="Index180"></A>training and mentoring.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I242' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I243>
</FONT><A NAME="_Toc375545210"></A><A NAME="_Toc473421309"></A><A NAME="_Toc481064507"></A><BR></P></DIV>
<A NAME="Heading83"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java vs. C++?</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java looks a lot like C++, and so
naturally it would seem that C++ will be replaced by Java. But I&#8217;m
starting to question this logic. For one thing, C++ still has some features that
Java doesn&#8217;t, and although there have been a lot of promises about Java
someday being as fast or faster than C++, we&#8217;ve seen steady improvements
but no dramatic breakthroughs. Also, there seems to be a continuing interest in
C++, so I don&#8217;t think that language is going away any time soon.
(Languages seem to hang around. Speaking at one of my
&#8220;Intermediate/Advanced Java Seminars,&#8221; Allen Holub asserted that the
two most commonly used languages are Rexx and COBOL, in that order.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I243' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I244>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I&#8217;m beginning to think that the
strength of Java lies in a slightly different arena than that of C++. C++ is a
language that doesn&#8217;t try to fit a mold. Certainly it has been adapted in
a number of ways to solve particular problems. Some C++ tools combine libraries,
component models, and code-generation tools to solve the problem of developing
windowed end-user applications (for Microsoft Windows). And yet, what do the
vast majority of Windows developers use? Microsoft&#8217;s Visual Basic (VB).
This despite the fact that VB produces the kind of code that becomes
unmanageable when the program is only a few pages long (and syntax that can be
positively mystifying). As successful and popular as VB is, it&#8217;s not a
very good example of language design. It would be nice to have the ease and
power of VB without the resulting unmanageable code. And that&#8217;s where I
think Java will shine: as the &#8220;next VB.&#8221; You may or may not shudder
to hear this, but think about it: so much of Java is intended to make it easy
for the programmer to solve application-level problems like networking and
cross-platform UI, and yet it has a language design that allows the creation of
very large and flexible bodies of code. Add to this the fact that Java has the
most robust type checking and error handling systems I&#8217;ve ever seen in a
language and you have the makings of a significant leap forward in programming
productivity. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I244' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I245>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Should you use Java instead of C++ for
your project? Other than Web applets, there are two issues to consider. First,
if you want to use a lot of existing C++ libraries (and you&#8217;ll certainly
get a lot of productivity gains there), or if you have an existing C or C++ code
base, Java might slow your development down rather than speeding it up. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I245' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I246>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re developing all your code
primarily from scratch, then the simplicity of Java over C++ will significantly
shorten your development time&#8212;the anecdotal evidence (stories from C++
teams that I&#8217;ve talked to who have switched to Java) suggests a doubling
of development speed over C++. If Java performance doesn&#8217;t matter or you
can somehow compensate for it, sheer time-to-market issues make it difficult to
choose C++ over Java. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I246' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I247>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The biggest issue is performance.
Interpreted Java has been slow, even 20 to 50 times slower than C in the
original Java interpreters. This has improved greatly over time, but it will
still remain an important number. Computers are about speed; if it wasn&#8217;t
significantly faster to do something on a computer then you&#8217;d do it by
hand. (I&#8217;ve even heard it suggested that you start with Java, to gain the
short development time, then use a tool and support libraries to translate your
code to C++, if you need faster execution speed.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I247' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I248>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The key to making Java feasible for most
development projects is the appearance of speed improvements like so-called
&#8220;<A NAME="Index181"></A>just-in time&#8221; (JIT) compilers, Sun&#8217;s
own &#8220;hotspot&#8221; technology, and even native code compilers. Of course,
native code compilers will eliminate the touted cross-platform execution of the
compiled programs, but they will also bring the speed of the executable closer
to that of C and C++. And cross-compiling a program in Java should be a lot
easier than doing so in C or C++. (In theory, you just recompile, but that
promise has been made before for other languages.) 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I248' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I249>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can find comparisons of Java and C++
and observations about Java realities in the appendices of the first edition of
this book (Available on this book&#8217;s accompanying CD ROM, as well as at
<I>www.BruceEckel.com)</I>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I249' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I250>
</FONT><A NAME="_Toc312373818"></A><A NAME="_Toc472654714"></A><A NAME="_Toc481064508"></A><BR></P></DIV>
<A NAME="Heading84"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter attempts to give you a feel
for the broad issues of object-oriented programming and Java, including why OOP
is different, and why Java in particular is different, concepts of OOP
methodologies, and finally the kinds of issues you will encounter when moving
your own company to OOP and Java.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I250' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I251>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">OOP and Java may not be for everyone.
It&#8217;s important to evaluate your own needs and decide whether Java will
optimally satisfy those needs, or if you might be better off with another
programming system (including the one you&#8217;re currently using). If you know
that your needs will be very specialized for the foreseeable future and if you
have specific constraints that may not be satisfied by Java, then you owe it to
yourself to investigate the
alternatives</FONT><A NAME="fnB19" HREF="#fn19">[19]</A><A NAME="Index182"></A><A NAME="Index183"></A><FONT FACE="Georgia">.
Even if you eventually choose Java as your language, you&#8217;ll at least
understand what the options were and have a clear vision of why you took that
direction. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I251' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I252>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You know what a procedural program looks
like: data definitions and function calls. To find the meaning of such a program
you have to work a little, looking through the function calls and low-level
concepts to create a model in your mind. This is the reason we need intermediate
representations when designing procedural programs&#8212;by themselves, these
programs tend to be confusing because the terms of expression are oriented more
toward the computer than to the problem you&#8217;re solving.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I252' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER1_I253>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because Java adds many new concepts on
top of what you find in a procedural language, your natural assumption may be
that the <B>main(&#160;)</B> in a Java program will be far more complicated than
for the equivalent C program. Here, you&#8217;ll be pleasantly surprised: A
well-written Java program is generally far simpler and much easier to understand
than the equivalent C program. What you&#8217;ll see are the definitions of the
objects that represent concepts in your problem space (rather than the issues of
the computer representation) and messages sent to those objects to represent the
activities in that space. One of the delights of object-oriented programming is
that, with a well-designed program, it&#8217;s easy to understand the code by
reading it. Usually there&#8217;s a lot less code as well, because many of your
problems will be solved by reusing existing library code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER1_I253' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

</FONT><A NAME="OLE_LINK5"></A><A NAME="Chapter_2"></A><A NAME="_Toc375545216"></A><A NAME="_Toc477690722"></A><A NAME="_Toc481064509"></A><BR></P></DIV>

<HR><DIV ALIGN="LEFT"><P><A NAME="fn2" HREF="#fnB2">[2]</A><FONT FACE="Georgia" SIZE=2>
See <I>Multiparadigm Programming in Leda</I> by Timothy Budd (Addison-Wesley
1995).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn3" HREF="#fnB3">[3]</A><FONT FACE="Georgia" SIZE=2>
Some people make a distinction, stating that type determines the interface while
class is a particular implementation of that interface.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn4" HREF="#fnB4">[4]</A><FONT FACE="Georgia" SIZE=2>
I&#8217;m indebted to my friend Scott Meyers for this term.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn5" HREF="#fnB5">[5]</A><FONT FACE="Georgia" SIZE=2>
This is usually enough detail for most diagrams, and you don&#8217;t need to get
specific about whether you&#8217;re using aggregation or
composition.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn6" HREF="#fnB6">[6]</A><FONT FACE="Georgia" SIZE=2>
My term.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn7" HREF="#fnB7">[7]</A><FONT FACE="Georgia" SIZE=2>
Primitive types, which you&#8217;ll learn about later, are a special
case.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn8" HREF="#fnB8">[8]</A><FONT FACE="Georgia" SIZE=2>
An excellent example of this is <I>UML Distilled</I>, 2<SUP>nd</SUP> edition, by
Martin Fowler (Addison-Wesley 2000), which reduces the sometimes-overwhelming
UML process to a manageable subset.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn9" HREF="#fnB9">[9]</A><FONT FACE="Georgia" SIZE=2>
My rule of thumb for estimating such projects: If there&#8217;s more than one
wild card, don&#8217;t even try to plan how long it&#8217;s going to take or how
much it will cost until you&#8217;ve created a working prototype. There are too
many degrees of freedom.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn10" HREF="#fnB10">[10]</A><FONT FACE="Georgia" SIZE=2>
Thanks for help from James H Jarrett.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn11" HREF="#fnB11">[11]</A><FONT FACE="Georgia" SIZE=2>
More information on use cases can be found in <I>Applying Use Cases</I> by
Schneider &amp; Winters (Addison-Wesley 1998) and <I>Use Case Driven Object
Modeling with UML</I> by Rosenberg (Addison-Wesley 1999).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn12" HREF="#fnB12">[12]</A><FONT FACE="Georgia" SIZE=2>
My personal take on this has changed lately. Doubling and adding 10 percent will
give you a reasonably accurate estimate (assuming there are not too many
wild-card factors), but you still have to work quite diligently to finish in
that time. If you want time to really make it elegant and to enjoy yourself in
the process, the correct multiplier is more like three or four times, I
believe.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn13" HREF="#fnB13">[13]</A><FONT FACE="Georgia" SIZE=2>
For starters, I recommend the aforementioned <I>UML Distilled</I>,
2<SUP>nd</SUP> edition.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn14" HREF="#fnB14">[14]</A><FONT FACE="Georgia" SIZE=2>
Python (www.Python.org) is often used as &#8220;executable
pseudocode.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn15" HREF="#fnB15">[15]</A><FONT FACE="Georgia" SIZE=2>
At least one aspect of evolution is covered in Martin Fowler&#8217;s book
<I>Refactoring: improving the design of existing code</I> (Addison-Wesley 1999),
which uses Java examples exclusively.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn16" HREF="#fnB16">[16]</A><FONT FACE="Georgia" SIZE=2>
This is something like &#8220;rapid prototyping,&#8221; where you were supposed
to build a quick-and-dirty version so that you could learn about the system, and
then throw away your prototype and build it right. The trouble with rapid
prototyping is that people didn&#8217;t throw away the prototype, but instead
built upon it. Combined with the lack of structure in procedural programming,
this often leads to messy systems that are expensive to
maintain.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn17" HREF="#fnB17">[17]</A><FONT FACE="Georgia" SIZE=2>
Although this may be a more American perspective, the stories of Hollywood reach
everywhere.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn18" HREF="#fnB18">[18]</A><FONT FACE="Georgia" SIZE=2>
Including (especially) the PA system. I once worked in a company that insisted
on broadcasting every phone call that arrived for every executive, and it
constantly interrupted our productivity (but the managers couldn&#8217;t begin
to conceive of stifling such an important service as the PA). Finally, when no
one was looking I started snipping speaker wires.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn19" HREF="#fnB19">[19]</A><FONT FACE="Georgia" SIZE=2>
In particular, I recommend looking at Python
(http://www.Python.org).</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Intro.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap02.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:05/21/2001</P></DIV>

</BODY>

</HTML>
