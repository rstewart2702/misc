<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/21/2001
Translation Time:10:39:18
Translation Platform:Win32
Number of Output files:23
This File:Chap11.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>11: The Java  I/O System</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevHist.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 12</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap10.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap12.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="Chapter_10"></A><A NAME="_Toc375545381"></A><A NAME="_Toc477690731"></A><A NAME="_Toc481064734"></A><A NAME="Heading353"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
11: The Java <BR>I/O System</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=4><backtalk:display ID=TIJ3_CHAPTER11_I0>
Creating
a good input/output (I/O) system is one of the more difficult tasks for the
language designer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is evidenced by the number of
different approaches. The challenge seems to be in covering all eventualities.
Not only are there different sources and sinks of I/O that you want to
communicate with (files, the console, network connections), but you need to talk
to them in a wide variety of ways (sequential, random-access, buffered, binary,
character, by lines, by words, etc.).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I0' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I1>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java library designers attacked this
problem by creating lots of classes. In fact, there are so many classes for
Java&#8217;s I/O system that it can be intimidating at first (ironically, the
Java I/O design actually prevents an explosion of classes). There was also a
significant change in the I/O <A NAME="Index1128"></A>library after Java 1.0,
when the original <B>byte</B>-oriented library was supplemented with
<B>char</B>-oriented, Unicode-based I/O classes. As a result there are a fair
number of classes to learn before you understand enough of Java&#8217;s I/O
picture that you can use it properly. In addition, it&#8217;s rather important
to understand the evolution history of the I/O library, even if your first
reaction is &#8220;don&#8217;t bother me with history, just show me how to use
it!&#8221; The problem is that without the historical perspective you will
rapidly become confused with some of the classes and when you should and
shouldn&#8217;t use them. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I1' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I2>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter will give you an
introduction to the variety of I/O classes in the standard Java library and how
to use them. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I2' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I3>
</FONT><A NAME="_Toc375545382"></A><A NAME="_Toc375545390"></A><A NAME="_Toc481064735"></A><BR></P></DIV>
<A NAME="Heading354"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
The File
class<BR><A NAME="Index1129"></A><A NAME="Index1130"></A><A NAME="Index1131"></A><A NAME="Index1132"></A><A NAME="Index1133"></A><A NAME="Index1134"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before getting into the classes that
actually read and write data to streams, we&#8217;ll look a utility provided
with the library to assist you in handling file directory issues.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I3' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I4>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>File </B>class has a deceiving
name&#8212;you might think it refers to a file, but it doesn&#8217;t. It can
represent either the <I>name</I> of a particular file or the <I>names</I> of a
set of files in a directory. If it&#8217;s a set of files, you can ask for the
set with the <B>list(&#160;)</B> method, and this returns an array of
<B>String</B>. It makes sense to return an array rather than one of the flexible
container classes because the number of elements is fixed, and if you want a
different directory listing you just create a different <B>File</B> object. In
fact, &#8220;FilePath&#8221; would have been a better name for the class. This
section shows an example of the use of this class, including the associated
<B>FilenameFilter</B> <B>interface</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I4' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I5>
</FONT><A NAME="_Toc375545391"></A><A NAME="_Toc481064736"></A><BR></P></DIV>
<A NAME="Heading355"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A directory lister<BR><A NAME="Index1135"></A><A NAME="Index1136"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you&#8217;d like to see a
directory listing. The <B>File</B> object can be listed in two ways. If you call
<B>list(&#160;)</B> with no arguments, you&#8217;ll get the full list that the
<B>File</B> object contains. However, if you want a restricted list&#8212;for
example, if you want all of the files with an extension of
<B>.java</B>&#8212;then you use a &#8220;directory filter,&#8221; which is a
class that tells how to select the <B>File</B> objects for display.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I5' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I6>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the code for the example.
Note that the result has been effortlessly sorted (alphabetically) using the
<B>java.utils.Array.sort(&#160;)</B> method and the <B>AlphabeticComparator</B>
defined in Chapter 9:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:DirList.java</font>
<font color=#009900>// Displays directory listing.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(<font color=#0000ff>new</font> DirFilter(args[0]));
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
}

<font color=#0000ff>class</font> DirFilter <font color=#0000ff>implements</font> FilenameFilter {
  String afn;
  DirFilter(String afn) { <font color=#0000ff>this</font>.afn = afn; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.indexOf(afn) != -1;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>DirFilter</B> class
&#8220;implements&#8221; the <B>interface</B> <B>FilenameFilter</B>. It&#8217;s
useful to see how simple the <B>FilenameFilter</B> <B>interface</B> is:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I6' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I7>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>public</font> <font color=#0000ff>interface</font> FilenameFilter {
  <font color=#0000ff>boolean</font> accept(File dir, String name);
}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It says all that this type of object does
is provide a method called <B>accept(&#160;)</B>. The whole reason behind the
creation of this class is to provide the <B>accept(&#160;)</B> method to the
<B>list(&#160;)</B> method so that <B>list(&#160;)</B> can &#8220;call
back&#8221; <B>accept(&#160;)</B> to determine which file names should be
included in the list. Thus, this technique is often referred to as a
<A NAME="Index1137"></A><I>callback</I> or sometimes a
<A NAME="Index1138"></A><I>functor</I> (that is, <B>DirFilter</B> is a functor
because its only job is to hold a method) or the
<A NAME="Index1139"></A><A NAME="Index1140"></A><I>Command</I> <I>Pattern</I>.
Because <B>list(&#160;)</B> takes a <B>FilenameFilter</B> object as its
argument, it means that you can pass an object of any class that implements
<B>FilenameFilter</B> to choose (even at run-time) how the <B>list(&#160;)</B>
method will behave. The purpose of a callback is to provide flexibility in the
behavior of code. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I7' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I8>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DirFilter</B> shows that just because
an <B>interface</B> contains only a set of methods, you&#8217;re not restricted
to writing only those methods. (You must at least provide definitions for all
the methods in an interface, however.) In this case, the <B>DirFilter</B>
constructor is also created.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I8' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I9>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>accept(&#160;)</B> method must
accept a <B>File</B> object representing the directory that a particular file is
found in, and a <B>String</B> containing the name of that file. You might choose
to use or ignore either of these arguments, but you will probably at least use
the file name. Remember that the <B>list(&#160;)</B> method is calling
<B>accept(&#160;)</B> for each of the file names in the directory object to see
which one should be included&#8212;this is indicated by the <B>boolean</B>
result returned by <B>accept(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I9' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I10>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make sure the element you&#8217;re
working with is only the file name and contains no path information, all you
have to do is take the <B>String</B> object and create a <B>File</B> object out
of it, then call <B>getName(&#160;)</B>, which strips away all the path
information (in a platform-independent way). Then <B>accept(&#160;)</B> uses the
<A NAME="Index1141"></A><A NAME="Index1142"></A><B>String </B>class
<B>indexOf(&#160;)</B> method to see if the search string <B>afn</B> appears
anywhere in the name of the file. If <B>afn</B> is found within the string, the
return value is the starting index of <B>afn</B>, but if it&#8217;s not found
the return value is -1. Keep in mind that this is a simple string search and
does not have &#8220;glob&#8221; expression wildcard matching&#8212;such as
&#8220;fo?.b?r*&#8221;&#8212;which is much more difficult to implement.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I10' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I11>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>list(&#160;)</B> method returns an
array. You can query this array for its length and then move through it
selecting the array elements. This ability to easily pass an array in and out of
a method is a tremendous improvement over the behavior of C and C++.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I11' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I12>
</FONT><BR></P></DIV>
<A NAME="Heading356"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Anonymous inner classes</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example is ideal for rewriting using
an
<A NAME="Index1143"></A><A NAME="Index1144"></A><A NAME="Index1145"></A>anonymous
inner class (described in Chapter 8). As a first cut, a method <B>filter(&#160;)
</B>is created that returns a reference to a
<B>FilenameFilter</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:DirList2.java</font>
<font color=#009900>// Uses anonymous inner classes.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> FilenameFilter 
  filter(<font color=#0000ff>final</font> String afn) {
    <font color=#009900>// Creation of anonymous inner class:</font>
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> FilenameFilter() {
      String fn = afn;
      <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String n) {
        <font color=#009900>// Strip path information:</font>
        String f = <font color=#0000ff>new</font> File(n).getName();
        <font color=#0000ff>return</font> f.indexOf(fn) != -1;
      }
    }; <font color=#009900>// End of anonymous inner class</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(filter(args[0]));
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that the argument to
<B>filter(&#160;)</B> must be
<A NAME="Index1146"></A><A NAME="Index1147"></A><B>final</B>. This is required
by the anonymous inner class so that it can use an object from outside its
scope. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I12' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I13>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This design is an improvement because the
<B>FilenameFilter</B> class is now tightly bound to <B>DirList2</B>. However,
you can take this approach one step further and define the anonymous inner class
as an argument to <B>list(&#160;)</B>, in which case it&#8217;s even
smaller:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:DirList3.java</font>
<font color=#009900>// Building the anonymous inner class "in-place."</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> DirList3 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(<font color=#0000ff>final</font> String[] args) {
    File path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    String[] list;
    <font color=#0000ff>if</font>(args.length == 0)
      list = path.list();
    <font color=#0000ff>else</font> 
      list = path.list(<font color=#0000ff>new</font> FilenameFilter() {
        <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> 
        accept(File dir, String n) {
          String f = <font color=#0000ff>new</font> File(n).getName();
          <font color=#0000ff>return</font> f.indexOf(args[0]) != -1;
        }
      });
    Arrays.sort(list,
      <font color=#0000ff>new</font> AlphabeticComparator());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; list.length; i++)
      System.out.println(list[i]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The argument to <B>main(&#160;)</B> is
now <B>final</B>, since the anonymous inner class uses <B>args[0]</B> directly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I13' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I14>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This shows you how anonymous inner
classes allow the creation of quick-and-dirty classes to solve problems. Since
everything in Java revolves around classes, this can be a useful coding
technique. One benefit is that it keeps the code that solves a particular
problem isolated together in one spot. On the other hand, it is not always as
easy to read, so you must use it judiciously.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I14' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I15>
</FONT><A NAME="_Toc375545392"></A><A NAME="_Toc481064737"></A><BR></P></DIV>
<A NAME="Heading357"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Checking for and creating directories</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>File</B> class is more than just a
representation for an existing file or directory. You can also use a <B>File</B>
object to create a new <A NAME="Index1148"></A><A NAME="Index1149"></A>directory
or an entire directory path if it doesn&#8217;t exist. You can also look at the
<A NAME="Index1150"></A><A NAME="Index1151"></A>characteristics of files (size,
last modification date, read/write), see whether a <B>File</B> object represents
a file or a directory, and delete a file. This program shows some of the other
methods available with the <B>File</B> class (see the HTML documentation from
<I>java.sun.com </I>for the full set):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MakeDirectories.java</font>
<font color=#009900>// Demonstrates the use of the File class to</font>
<font color=#009900>// create directories and manipulate files.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MakeDirectories {
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> String usage =
    <font color=#004488>"Usage:MakeDirectories path1 ...\n"</font> +
    <font color=#004488>"Creates each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -d path1 ...\n"</font> +
    <font color=#004488>"Deletes each path\n"</font> +
    <font color=#004488>"Usage:MakeDirectories -r path1 path2\n"</font> +
    <font color=#004488>"Renames from path1 to path2\n"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> fileData(File f) {
    System.out.println(
      <font color=#004488>"Absolute path: "</font> + f.getAbsolutePath() +
      <font color=#004488>"\n Can read: "</font> + f.canRead() +
      <font color=#004488>"\n Can write: "</font> + f.canWrite() +
      <font color=#004488>"\n getName: "</font> + f.getName() +
      <font color=#004488>"\n getParent: "</font> + f.getParent() +
      <font color=#004488>"\n getPath: "</font> + f.getPath() +
      <font color=#004488>"\n length: "</font> + f.length() +
      <font color=#004488>"\n lastModified: "</font> + f.lastModified());
    <font color=#0000ff>if</font>(f.isFile())
      System.out.println(<font color=#004488>"it's a file"</font>);
    <font color=#0000ff>else</font> <font color=#0000ff>if</font>(f.isDirectory())
      System.out.println(<font color=#004488>"it's a directory"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>if</font>(args.length &lt; 1) usage();
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-r"</font>)) {
      <font color=#0000ff>if</font>(args.length != 3) usage();
      File 
        old = <font color=#0000ff>new</font> File(args[1]),
        rname = <font color=#0000ff>new</font> File(args[2]);
      old.renameTo(rname);
      fileData(old);
      fileData(rname);
      <font color=#0000ff>return</font>; <font color=#009900>// Exit main</font>
    }
    <font color=#0000ff>int</font> count = 0;
    <font color=#0000ff>boolean</font> del = <font color=#0000ff>false</font>;
    <font color=#0000ff>if</font>(args[0].equals(<font color=#004488>"-d"</font>)) {
      count++;
      del = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>for</font>( ; count &lt; args.length; count++) {
      File f = <font color=#0000ff>new</font> File(args[count]);
      <font color=#0000ff>if</font>(f.exists()) {
        System.out.println(f + <font color=#004488>" exists"</font>);
        <font color=#0000ff>if</font>(del) {
          System.out.println(<font color=#004488>"deleting..."</font> + f);
          f.delete();
        }
      } 
      <font color=#0000ff>else</font> { <font color=#009900>// Doesn't exist</font>
        <font color=#0000ff>if</font>(!del) {
          f.mkdirs();
          System.out.println(<font color=#004488>"created "</font> + f);
        }
      }
      fileData(f);
    }  
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>fileData(&#160;)</B> you can see
various file investigation methods used to display information about the file or
directory path. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I15' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I16>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first method that&#8217;s exercised
by <B>main(&#160;)</B> is
<A NAME="Index1152"></A><A NAME="Index1153"></A><B>renameTo(&#160;)</B>, which
allows you to rename (or move) a file to an entirely new path represented by the
argument, which is another <B>File</B> object. This also works with directories
of any length. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I16' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I17>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you experiment with the above program,
you&#8217;ll find that you can make a directory path of any complexity because
<A NAME="Index1154"></A><A NAME="Index1155"></A><B>mkdirs(&#160;)</B> will do
all the work for you.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I17' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I18>
</FONT><A NAME="_Toc481064738"></A><BR></P></DIV>
<A NAME="Heading358"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Input and
output<BR><A NAME="Index1156"></A><A NAME="Index1157"></A><A NAME="Index1158"></A><A NAME="Index1159"></A><A NAME="Index1160"></A><A NAME="Index1161"></A><A NAME="Index1162"></A><A NAME="Index1163"></A><A NAME="Index1164"></A><A NAME="Index1165"></A><A NAME="Index1166"></A><A NAME="Index1167"></A><A NAME="Index1168"></A><A NAME="Index1169"></A><A NAME="Index1170"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I/O libraries often use the abstraction
of a <I>stream</I>, which represents any data source or sink as an object
capable of producing or receiving pieces of data. The stream hides the details
of what happens to the data inside the actual I/O device.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I18' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I19>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java library classes for I/O are
divided by input and output, as you can see by looking at the online Java class
hierarchy with your Web browser. By inheritance, everything derived from the
<B>InputStream</B> or <B>Reader </B>classes have basic methods called
<B>read(&#160;) </B>for reading a single byte or array of bytes. Likewise,
everything derived from <B>OutputStream </B>or <B>Writer </B>classes have basic
methods called <B>write(&#160;) </B>for writing a single byte or array of bytes.
However, you won&#8217;t generally use these methods; they exist so that other
classes can use them&#8212;these other classes provide a more useful interface.
Thus, you&#8217;ll rarely create your stream object by using a single class, but
instead will layer multiple objects together to provide your desired
functionality. The fact that you create more than one object to create a single
resulting stream is the primary reason that Java&#8217;s stream library is
confusing. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I19' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I20>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s helpful to categorize the
classes by their functionality. In Java 1.0, the library designers started by
deciding that all classes that had anything to do with input would be inherited
from <B>InputStream</B> and all classes that were associated with output would
be inherited from <B>OutputStream</B>. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I20' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I21>
</FONT><A NAME="_Toc375545383"></A><A NAME="_Toc481064739"></A><BR></P></DIV>
<A NAME="Heading359"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Types of InputStream</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B>&#8217;s job is to
represent classes that produce input from different sources. These sources can
be: </FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">An array of
bytes.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
<B>String</B>
object.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
file.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
&#8220;pipe,&#8221; which works like a
physical</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">
<A NAME="Index1171"></A><A NAME="Index1172"></A>pipe: you put things in one end
and they come out the other.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A sequence of other
streams, so you can collect them together into a single
stream.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Other
sources, such as an Internet connection. (This will be discussed in a later
chapter.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I21' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I22>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each
of these has an associated subclass of <B>InputStream</B>. In addition, the
<B>FilterInputStream</B> is also a type of <B>InputStream</B>, to provide a base
class for "decorator" classes that attach attributes or useful interfaces to
input streams. This is discussed later.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I22' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I23>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 11-1. Types of
InputStream<A NAME="Index1173"></A><A NAME="Index1174"></A><A NAME="Index1175"></A><A NAME="Index1176"></A><A NAME="Index1177"></A><A NAME="Index1178"></A><A NAME="Index1179"></A><A NAME="Index1180"></A><A NAME="Index1181"></A><A NAME="Index1182"></A><A NAME="Index1183"></A><A NAME="Index1184"></A><A NAME="Index1185"></A><A NAME="Index1186"></A><A NAME="Index1187"></A><A NAME="Index1188"></A><A NAME="Index1189"></A><A NAME="Index1190"></A><A NAME="Index1191"></A><A NAME="Index1192"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=99 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Class</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=108 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Constructor
Arguments</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>How to use it</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Allows a buffer in memory to be used as
an <B>InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The buffer from which to extract the
bytes.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to a
<B>FilterInputStream</B> object to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBuffer-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converts a <B>String</B> into an
<B>InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B>. The underlying
implementation actually uses a <B>StringBuffer</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to a
<B>FilterInputStream</B> object to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For reading information from a
file</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>String</B> representing the file
name, or a <B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to a
<B>FilterInputStream</B> object to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the data that&#8217;s being
written to the associated <B>PipedOutput</B>-<B>Stream</B>. Implements the
&#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data in multithreading.
Connect it to a <B>FilterInputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sequence-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converts two or more <B>InputStream</B>
objects into a single <B>InputStream</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Two <B>InputStream</B> objects or an
<B>Enumeration</B> for a container of <B>InputStream</B>
objects.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a source of data. Connect it to a
<B>FilterInputStream</B> object to provide a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an interface for
decorators that provide useful functionality to the other <B>InputStream</B>
classes. See Table 11-3.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 11-3.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 11-3.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545385"></A><A NAME="_Toc481064740"></A></TABLE></P></DIV>
<A NAME="Heading360"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Types of OutputStream<BR><A NAME="Index1193"></A><A NAME="Index1194"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This category includes the classes that
decide where your output will go: an array of bytes (no <B>String</B>, however;
presumably you can create one using the array of bytes), a file, or a
&#8220;pipe.&#8221; 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I23' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I24>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, the
<B>FilterOutputStream</B> provides a base class for "decorator" classes that
attach attributes or useful interfaces to output streams. This is discussed
later. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I24' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I25>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 11-2. Types of
OutputStream<A NAME="Index1195"></A><A NAME="Index1196"></A><A NAME="Index1197"></A><A NAME="Index1198"></A><A NAME="Index1199"></A><A NAME="Index1200"></A><A NAME="Index1201"></A><A NAME="Index1202"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=99 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Class</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=117 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Constructor
Arguments</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=153 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>How to use it</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArray-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates a buffer in memory. All the data
that you send to the stream is placed in this buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Optional initial size of the
buffer.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of your
data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For sending information to a
file.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A String representing the file name, or a
<B>File</B> or <B>FileDescriptor</B> object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of your
data. Connect it to a <B>FilterOutputStream</B> object to provide a useful
interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Piped-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any information you write to this
automatically ends up as input for the associated <B>PipedInput-Stream</B>.
Implements the &#8220;piping&#8221; concept.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To designate the destination of your data
for multithreading. Connect it to a <B>FilterOutputStream</B> object to provide
a useful interface.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filter-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Abstract class which is an interface for
decorators that provide useful functionality to the other <B>OutputStream</B>
classes. See Table 11-4.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 11-4.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">See Table 11-4.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545386"></A><A NAME="_Toc481064741"></A></TABLE></P></DIV>
<A NAME="Heading361"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Adding attributes <BR>and useful interfaces</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of layered objects to dynamically
and transparently add responsibilities to individual objects is referred to as
the <A NAME="Index1203"></A><A NAME="Index1204"></A><I>Decorator</I> pattern.
(Patterns</FONT><A NAME="fnB57" HREF="#fn57">[57]</A><FONT FACE="Georgia"> are
the subject of <I>Thinking in Patterns with Java</I>, downloadable at
<I>www.BruceEckel.com</I>.) The decorator pattern specifies that all objects
that wrap around your initial object have the same interface. This makes the
basic use of the decorators transparent&#8212;you send the same message to an
object whether it&#8217;s been decorated or not. This is the reason for the
existence of the &#8220;filter&#8221; classes in the Java I/O library: the
abstract &#8220;filter&#8221; class is the base class for all the decorators. (A
decorator must have the same interface as the object it decorates, but the
decorator can also extend the interface, which occurs in several of the
&#8220;filter&#8221; classes).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I25' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I26>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Decorators are often used when simple
subclassing results in a large number of subclasses in order to satisfy every
possible combination that is needed&#8212;so many subclasses that it becomes
impractical. The Java I/O library requires many different combinations of
features, which is why the decorator pattern is used. There is a drawback to the
decorator pattern, however. Decorators give you much more flexibility while
you&#8217;re writing a program (since you can easily mix and match attributes),
but they add complexity to your code. The reason that the Java I/O library is
awkward to use is that you must create many classes&#8212;the &#8220;core&#8221;
I/O type plus all the decorators&#8212;in order to get the single I/O object
that you want.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I26' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I27>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classes that provide the decorator
interface to control a particular <B>InputStream</B> or <B>OutputStream</B> are
the <B>FilterInputStream</B> and <B>FilterOutputStream</B>&#8212;which
don&#8217;t have very intuitive names. <B>FilterInputStream</B> and
<B>FilterOutputStream</B> are abstract classes that are derived from the base
classes of the I/O library, <B>InputStream</B> and <B>OutputStream</B>, which is
the key requirement of the decorator (so that it provides the common interface
to all the objects that are being decorated).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I27' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I28>
</FONT><A NAME="_Toc375545387"></A><A NAME="_Toc481064742"></A><BR></P></DIV>
<A NAME="Heading362"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Reading from an InputStream <BR>with FilterInputStream</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>FilterInputStream</B> classes
accomplish two significantly different things. <B>DataInputStream</B> allows you
to read different types of primitive data as well as <B>String</B> objects. (All
the methods start with &#8220;read,&#8221; such as <B>readByte(&#160;)</B>,
<B>readFloat(&#160;)</B>, etc.) This, along with its companion
<B>DataOutputStream</B>, allows you to move primitive data from one place to
another via a stream. These &#8220;places&#8221; are determined by the classes
in Table 11-1.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I28' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I29>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The remaining classes modify the way an
<B>InputStream</B> behaves internally: whether it&#8217;s buffered or
unbuffered, if it keeps track of the lines it&#8217;s reading (allowing you to
ask for line numbers or set the line number), and whether you can push back a
single character. The last two classes look a lot like support for building a
compiler (that is, they were added to support the construction of the Java
compiler), so you probably won&#8217;t use them in general programming. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I29' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I30>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll probably need to buffer your
input almost every time, regardless of the I/O device you&#8217;re connecting
to, so it would have made more sense for the I/O library to make a special case
(or simply a method call) for unbuffered input rather than buffered input.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I30' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I31>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 11-3. Types of
FilterInputStream<A NAME="Index1205"></A><A NAME="Index1206"></A><A NAME="Index1207"></A><A NAME="Index1208"></A><A NAME="Index1209"></A><A NAME="Index1210"></A><A NAME="Index1211"></A><A NAME="Index1212"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Class</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Constructor
Arguments</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>How to use it</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataOutputStream</B>, so you can read primitives (<B>int</B>, <B>char</B>,
<B>long</B>, etc.) from a stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains a full interface to allow you to
read primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical read every
time you want more data. You&#8217;re saying &#8220;Use a
buffer.&#8221;</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B>, with optional buffer
size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an interface
<I>per se</I>, just a requirement that a buffer be used. Attach an interface
object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumber-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Keeps track of line numbers in the input
stream; you can call <B>getLineNumber(&#160;)</B> and
<B>setLineNumber(</B></FONT><BR><FONT FACE="Georgia"><B>int)</B>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This just adds line numbering, so
you&#8217;ll probably attach an interface object.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Pushback-InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Has a one byte push-back buffer so that
you can push back the last character read.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generally used in the scanner for a
compiler and probably included because the Java compiler needed it. You probably
won&#8217;t use this.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545388"></A><A NAME="_Toc481064743"></A></TABLE></P></DIV>
<A NAME="Heading363"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Writing to an OutputStream <BR>with FilterOutputStream</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The complement to <B>DataInputStream</B>
is <B>DataOutputStream</B>, which formats each of the primitive types and
<B>String</B> objects onto a stream in such a way that any
<B>DataInputStream</B>, on any machine, can read them. All the methods start
with &#8220;write,&#8221; such as <B>writeByte(&#160;)</B>,
<B>writeFloat(&#160;)</B>, etc.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I31' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I32>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The original intent of <B>PrintStream</B>
was to print all of the primitive data types and <B>String</B> objects in a
viewable format. This is different from <B>DataOutputStream</B>, whose goal is
to put data elements on a stream in a way that <B>DataInputStream</B> can
portably reconstruct them. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I32' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I33>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two important methods in
<B>PrintStream</B> are <B>print(&#160;)</B> and <B>println(&#160;)</B>, which
are overloaded to print all the various types. The difference between
<B>print(&#160;)</B> and <B>println(&#160;)</B> is that the latter adds a
newline when it&#8217;s done.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I33' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I34>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B> can be problematic
because it traps all <B>IOException</B>s (You must explicitly test the error
status with <B>checkError(&#160;)</B>, which returns <B>true</B> if an error has
occurred). Also, <B>PrintStream</B> doesn&#8217;t internationalize properly and
doesn&#8217;t handle line breaks in a platform independent way (these problems
are solved with <B>PrintWriter</B>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I34' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I35>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedOutputStream</B> is a modifier
and tells the stream to use buffering so you don&#8217;t get a physical write
every time you write to the stream. You&#8217;ll probably always want to use
this with files, and possibly console I/O.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I35' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I36>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Table 11-4. Types of
FilterOutputStream<A NAME="Index1213"></A><A NAME="Index1214"></A><A NAME="Index1215"></A><A NAME="Index1216"></A><A NAME="Index1217"></A><A NAME="Index1218"></A></B></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=99 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Class</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=130 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Constructor Arguments
</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TH WIDTH=121 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>How to use it</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Data-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Used in concert with
<B>DataInputStream</B> so you can write primitives (int, char, long, etc.) to a
stream in a portable fashion.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Contains full interface to allow you to
write primitive types.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For producing formatted output. While
<B>DataOutputStream</B> handles the <I>storage</I> of data, <B>PrintStream</B>
handles <I>display</I>.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional
<B>boolean</B> indicating that the buffer is flushed with every
newline.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Should be the &#8220;final&#8221;
wrapping for your <B>OutputStream</B> object. You&#8217;ll probably use this a
lot.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Buffered-OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use this to prevent a physical write
every time you send a piece of data. You&#8217;re saying &#8220;Use a
buffer.&#8221; You can call <B>flush(&#160;)</B> to flush the
buffer.</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B>, with optional buffer
size.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This doesn&#8217;t provide an interface
<I>per se</I>, just a requirement that a buffer is used. Attach an interface
object.</FONT><BR></P></DIV>
</TD>
</TR>
<A NAME="_Toc375545389"></A><A NAME="_Toc481064744"></A></TABLE></P></DIV>
<A NAME="Heading364"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Readers &amp; Writers<BR><A NAME="Index1219"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.1 made some significant
modifications to the fundamental I/O stream library (Java 2, however, did not
make fundamental modifications). When you see the
<A NAME="Index1220"></A><A NAME="Index1221"></A><B>Reader</B> and
<A NAME="Index1222"></A><A NAME="Index1223"></A><B>Writer</B> classes your first
thought (like mine) might be that these were meant to replace the
<B>InputStream</B> and <B>OutputStream</B> classes. But that&#8217;s not the
case. Although some aspects of the original streams library are deprecated (if
you use them you will receive a warning from the compiler), the
<B>InputStream</B> and <B>OutputStream</B> classes still provide valuable
functionality in the form of <B>byte</B>-oriented I/O, while the <B>Reader
</B>and <B>Writer </B>classes provide Unicode-compliant, character-based I/O. In
addition:
<A NAME="Index1224"></A><A NAME="Index1225"></A><A NAME="Index1226"></A><A NAME="Index1227"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I36' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I37>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Java 1.1 added new classes
into the <B>InputStream </B>and <B>OutputStream </B>hierarchy, so it&#8217;s
obvious those classes weren&#8217;t being replaced.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I37' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I38>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">There
are times when you must use classes from the &#8220;byte&#8221; hierarchy <I>in
combination</I> with classes in the &#8220;character&#8221; hierarchy. To
accomplish this there are &#8220;bridge&#8221; classes: <B>InputStreamReader</B>
converts an <B>InputStream </B>to a <B>Reader </B>and <B>OutputStreamWriter</B>
converts an <B>OutputStream</B> to a <B>Writer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I38' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I39>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
most important reason for the <B>Reader</B> and <B>Writer</B> hierarchies is for
<A NAME="Index1228"></A><A NAME="Index1229"></A>internationalization. The old
I/O stream hierarchy supports only 8-bit byte streams and doesn&#8217;t handle
the 16-bit Unicode characters well. Since Unicode is used for
internationalization (and Java&#8217;s native <B>char </B>is 16-bit
<A NAME="Index1230"></A><A NAME="Index1231"></A>Unicode), the <B>Reader</B> and
<B>Writer</B> hierarchies were added to support Unicode in all I/O operations.
In addition, the new libraries are designed for faster operations than the old.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I39' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I40>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As is the practice in this book, I will
attempt to provide an overview of the classes, but assume that you will use
online documentation to determine all the details, such as the exhaustive list
of methods.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I40' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I41>
</FONT><A NAME="_Toc481064745"></A><BR></P></DIV>
<A NAME="Heading365"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sources and sinks of data</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Almost all of the original Java I/O
stream classes have corresponding <B>Reader</B> and <B>Writer</B> classes to
provide native Unicode manipulation. However, there are some places where the
<B>byte</B>-oriented <B>InputStream</B>s and <B>OutputStream</B>s are the
correct solution;<B> </B>in particular, the <B>java.util.zip</B> libraries are
<B>byte</B>-oriented rather than <B>char</B>-oriented. So the most sensible
approach to take is to <I>try</I> to use the <B>Reader</B> and <B>Writer</B>
classes whenever you can, and you&#8217;ll discover the situations when you have
to use the <B>byte</B>-oriented libraries because your code won&#8217;t compile.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I41' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I42>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is a table that shows the
correspondence between the sources and sinks of information (that is, where the
data physically comes from or goes to) in the two hierarchies.
<A NAME="Index1232"></A><A NAME="Index1233"></A><A NAME="Index1234"></A><A NAME="Index1235"></A><A NAME="Index1236"></A><A NAME="Index1237"></A><A NAME="Index1238"></A><A NAME="Index1239"></A><A NAME="Index1240"></A><A NAME="Index1241"></A><A NAME="Index1242"></A><A NAME="Index1243"></A><A NAME="Index1244"></A><A NAME="Index1245"></A><A NAME="Index1246"></A><A NAME="Index1247"></A><A NAME="Index1248"></A><A NAME="Index1249"></A><A NAME="Index1250"></A><A NAME="Index1251"></A><A NAME="Index1252"></A><A NAME="Index1253"></A><A NAME="Index1254"></A><A NAME="Index1255"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Sources &amp;
Sinks:</B></FONT><BR><FONT FACE="Georgia"><B>Java 1.0 class</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Corresponding Java 1.1
class</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Reader
</B></FONT><BR><FONT FACE="Georgia">converter:<B>
InputStreamReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>OutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Writer
</B></FONT><BR><FONT FACE="Georgia">converter:<B>
OutputStreamWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FileWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringBufferInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(no corresponding class)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StringWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ByteArrayOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CharArrayWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PipedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you&#8217;ll find that the
interfaces for the two different hierarchies are similar if not
identical.</FONT><A NAME="_Toc481064746"></A><BR></P></DIV>
<A NAME="Heading366"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Modifying stream behavior</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For <B>InputStream</B>s and
<B>OutputStream</B>s, streams were adapted for particular needs using
&#8220;decorator&#8221; subclasses of <B>FilterInputStream</B> and
<B>FilterOutputStream.</B> The <B>Reader</B> and <B>Writer</B> class hierarchies
continue the use of this idea&#8212;but not exactly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I42' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I43>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the following table, the
correspondence is a rougher approximation than in the previous table. The
difference is because of the class organization: while
<B>BufferedOutputStream</B> is a subclass of <B>FilterOutputStream</B>,
<B>BufferedWriter</B> is <I>not</I> a subclass of <B>FilterWriter</B> (which,
even though it is <B>abstract</B>, has no subclasses and so appears to have been
put in either as a placeholder or simply so you wouldn&#8217;t wonder where it
was). However, the interfaces to the classes are quite a close match.
<A NAME="Index1256"></A><A NAME="Index1257"></A><A NAME="Index1258"></A><A NAME="Index1259"></A><A NAME="Index1260"></A><A NAME="Index1261"></A><A NAME="Index1262"></A><A NAME="Index1263"></A><A NAME="Index1264"></A><A NAME="Index1265"></A><A NAME="Index1266"></A><A NAME="Index1267"></A><A NAME="Index1268"></A><A NAME="Index1269"></A><A NAME="Index1270"></A><A NAME="Index1271"></A><A NAME="Index1272"></A><A NAME="Index1273"></A><A NAME="Index1274"></A><A NAME="Index1275"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=162 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Filters:</B></FONT><BR><FONT FACE="Georgia"><B>Java
1.0 class</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=189 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Corresponding Java 1.1
class</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>FilterWriter </B>(abstract class with
no subclasses)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedReader</B></FONT><BR><FONT FACE="Georgia">(also
has<B> readLine(&#160;)</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>BufferedWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Use<B>
DataInputStream</B></FONT><BR><FONT FACE="Georgia">(Except when you need to
use<B> readLine(&#160;)</B>,<B> </B>when you should use a<B>
BufferedReader</B>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PrintWriter</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LineNumberReader</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>StreamTokenizer</B></FONT><BR><FONT FACE="Georgia">(use
constructor that takes a <B>Reader</B> instead)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>PushBackReader</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one direction that&#8217;s
quite clear: Whenever you want to use <B>readLine(&#160;)</B>, you
shouldn&#8217;t do it with a <B>DataInputStream</B> any more (this is met with a
deprecation message at compile-time), but instead use a <B>BufferedReader</B>.
Other than this, <B>DataInputStream</B> is still a &#8220;preferred&#8221;
member of the I/O library.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make the transition to using a
<B>PrintWriter</B> easier, it has constructors that take any <B>OutputStream</B>
object, as well as <B>Writer</B> objects. However, <B>PrintWriter</B> has no
more support for formatting than <B>PrintStream</B> does; the interfaces are
virtually the same. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I43' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I44>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>PrintWriter</B> constructor also
has an option to perform automatic flushing, which happens after every
<B>println(&#160;)</B> if the constructor flag is set.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I44' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I45>
</FONT><A NAME="_Toc481064747"></A><BR></P></DIV>
<A NAME="Heading367"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Unchanged Classes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Some classes were left unchanged between
Java 1.0 and Java 1.1:
<A NAME="Index1276"></A><A NAME="Index1277"></A><A NAME="Index1278"></A><A NAME="Index1279"></A><A NAME="Index1280"></A><A NAME="Index1281"></A><A NAME="Index1282"></A><A NAME="Index1283"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=166 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java 1.0 classes without corresponding
Java 1.1 classes</FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataOutputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>File</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessFile</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SequenceInputStream</B></FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DataOutputStream</B>, in particular,
is used without change, so for storing and retrieving data in a transportable
format you use the <B>InputStream</B> and <B>OutputStream</B>
hierarchies.</FONT><A NAME="_Toc481064748"></A><BR></P></DIV>
<A NAME="Heading368"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Off by itself:
<BR>RandomAccessFile<BR><A NAME="Index1284"></A><A NAME="Index1285"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>RandomAccessFile</B> is used for files
containing records of known size so that you can move from one record to another
using <A NAME="Index1286"></A><A NAME="Index1287"></A><B>seek(&#160;)</B>, then
read or change the records. The records don&#8217;t have to be the same size;
you just have to be able to determine how big they are and where they are placed
in the file. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I45' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I46>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At first it&#8217;s a little bit hard to
believe that <B>RandomAccessFile</B> is not part of the <B>InputStream</B> or
<B>OutputStream</B> hierarchy. However, it has no association with those
hierarchies other than that it happens to implement the
<A NAME="Index1288"></A><A NAME="Index1289"></A><B>DataInput</B> and
<A NAME="Index1290"></A><A NAME="Index1291"></A><B>DataOutput</B> interfaces
(which are also implemented by <B>DataInputStream</B> and
<B>DataOutputStream</B>). It doesn&#8217;t even use any of the functionality of
the existing <B>InputStream</B> or <B>OutputStream</B> classes&#8212;it&#8217;s
a completely separate class, written from scratch, with all of its own (mostly
native) methods. The reason for this may be that <B>RandomAccessFile</B> has
essentially different behavior than the other I/O types, since you can move
forward and backward within a file. In any event, it stands alone, as a direct
descendant of <B>Object</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I46' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I47>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Essentially, a <B>RandomAccessFile</B>
works like a <B>DataInputStream</B> pasted together with a
<B>DataOutputStream</B>, along with the methods <B>getFilePointer(&#160;)</B> to
find out where you are in the file, <B>seek(&#160;)</B> to move to a new point
in the file, and <B>length(&#160;)</B> to determine the maximum size of the
file. In addition, the constructors require a second argument (identical to
<B>fopen(&#160;) </B>in C) indicating whether you are just randomly reading
(<B>&#8220;r&#8221;</B>) or reading and writing (<B>&#8220;rw&#8221;</B>).
There&#8217;s no support for write-only files, which could suggest that
<B>RandomAccessFile</B> might have worked well if it were inherited from
<B>DataInputStream</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I47' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I48>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The seeking methods are available only in
<B>RandomAccessFile</B>, which works for files only. <B>BufferedInputStream</B>
does allow you to
<A NAME="Index1292"></A><A NAME="Index1293"></A><B>mark(&#160;)</B> a position
(whose value is held in a single internal variable) and
<A NAME="Index1294"></A><A NAME="Index1295"></A><B>reset(&#160;)</B> to that
position, but this is limited and not very useful.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I48' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I49>
</FONT><A NAME="_Toc375545393"></A><A NAME="_Toc481064749"></A><BR></P></DIV>
<A NAME="Heading369"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Typical uses of I/O streams</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although you can combine the I/O stream
classes in many different ways, you&#8217;ll probably just use a few
combinations. The following example can be used as a basic reference; it shows
the creation and use of <A NAME="Index1296"></A>typical I/O configurations. Note
that each configuration begins with a commented number and title that
corresponds to the heading for the appropriate explanation that follows in the
text.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:IOStreamDemo.java</font>
<font color=#009900>// Typical I/O stream configurations.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOStreamDemo {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    <font color=#009900>// 1. Reading input by lines:</font>
    BufferedReader in =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> FileReader(<font color=#004488>"IOStreamDemo.java"</font>));
    String s, s2 = <font color=#0000ff>new</font> String();
    <font color=#0000ff>while</font>((s = in.readLine())!= <font color=#0000ff>null</font>)
      s2 += s + <font color=#004488>"\n"</font>;
    in.close();

    <font color=#009900>// 1b. Reading standard input:</font>
    BufferedReader stdin =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(System.in));      
    System.out.print(<font color=#004488>"Enter a line:"</font>);
    System.out.println(stdin.readLine());

    <font color=#009900>// 2. Input from memory</font>
    StringReader in2 = <font color=#0000ff>new</font> StringReader(s2);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in2.read()) != -1)
      System.out.print((<font color=#0000ff>char</font>)c);

    <font color=#009900>// 3. Formatted memory input</font>
    <font color=#0000ff>try</font> {
      DataInputStream in3 =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> ByteArrayInputStream(s2.getBytes()));
      <font color=#0000ff>while</font>(<font color=#0000ff>true</font>)
        System.out.print((<font color=#0000ff>char</font>)in3.readByte());
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 4. File output</font>
    <font color=#0000ff>try</font> {
      BufferedReader in4 =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> StringReader(s2));
      PrintWriter out1 =
        <font color=#0000ff>new</font> PrintWriter(
          <font color=#0000ff>new</font> BufferedWriter(
            <font color=#0000ff>new</font> FileWriter(<font color=#004488>"IODemo.out"</font>)));
      <font color=#0000ff>int</font> lineCount = 1;
      <font color=#0000ff>while</font>((s = in4.readLine()) != <font color=#0000ff>null</font> )
        out1.println(lineCount++ + <font color=#004488>": "</font> + s);
      out1.close();
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 5. Storing &amp; recovering data</font>
    <font color=#0000ff>try</font> {
      DataOutputStream out2 =
        <font color=#0000ff>new</font> DataOutputStream(
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
      out2.writeDouble(3.14159);
      out2.writeCharswriteUTF(<font color=#004488>"That was pi\n"</font>);
      out2.writeBytes(<font color=#004488>"That was pi\n"</font>);
      out2.writeDouble(1.41413);
      out2.writeUTF(<font color=#004488>"Square root of 2"</font>);      
      out2.close();
      DataInputStream in5 =
        <font color=#0000ff>new</font> DataInputStream(
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
      BufferedReader in5br =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(in5));
      <font color=#009900>// Must use DataInputStream for data:</font>
      System.out.println(in5.readDouble());
      <font color=#009900>// Only readUTF() will recover the </font>
      <font color=#009900>// Java-UTF String properly:</font>
      <font color=#009900>// Can now use the "proper" readLine():</font>
      System.out.println(in5br.readLinereadUTF());
      <font color=#009900>// But the line comes out funny.</font>
      <font color=#009900>// The one created with writeBytes is OK:</font>
      System.out.println(in5br.readLine());
      <font color=#009900>// Read the following double and String:</font>
      System.out.println(in5.readDouble());
      System.out.println(in5.readUTF());
    } <font color=#0000ff>catch</font>(EOFException e) {
      System.err.println(<font color=#004488>"End of stream"</font>);
    }

    <font color=#009900>// 6. Reading/writing random access files</font>
    RandomAccessFile rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      rf.writeDouble(i*1.414);
    rf.close();

    rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"rw"</font>);
    rf.seek(5*8);
    rf.writeDouble(47.0001);
    rf.close();

    rf =
      <font color=#0000ff>new</font> RandomAccessFile(<font color=#004488>"rtest.dat"</font>, <font color=#004488>"r"</font>);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      System.out.println(
        <font color=#004488>"Value "</font> + i + <font color=#004488>": "</font> +
        rf.readDouble());
    rf.close();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are the descriptions for the
numbered sections of the program:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I49' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I50>
</FONT><A NAME="_Toc375545394"></A><A NAME="_Toc481064750"></A><BR></P></DIV>
<A NAME="Heading370"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Input streams</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Parts 1 through 4 demonstrate the
creation and use of input streams. Part 4 also shows the simple use of an output
stream.</FONT><BR></P></DIV>
<A NAME="Heading371"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
1. Buffered input file</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To open a file for character input, you
use a <A NAME="Index1297"></A><A NAME="Index1298"></A><B>FileInputReader</B>
with a <B>String</B> or a <B>File</B> object as the file name. For speed,
you&#8217;ll want that file to be buffered so you give the resulting reference
to the constructor for a
<A NAME="Index1299"></A><A NAME="Index1300"></A><B>BufferedReader</B>. Since
<B>BufferedReader</B> also provides the <B>readLine(&#160;)</B> method, this is
your final object and the interface you read from. When you reach the end of the
file, <B>readLine(&#160;)</B> returns <B>null</B> so that is used to break out
of the <B>while</B> loop. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I50' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I51>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>String s2</B> is used to
accumulate the entire contents of the file (including newlines that must be
added since <B>readLine(&#160;)</B> strips them off). <B>s2 </B>is then used in
the later portions of this program. Finally, <B>close(&#160;)</B> is called to
close the file. Technically, <B>close(&#160;)</B> will be called when
<B>finalize(&#160;)</B> runs, and this is supposed to happen (whether or not
garbage collection occurs) as the program exits. However, this has been
inconsistently implemented, so the only safe approach is to explicitly call
<A NAME="Index1301"></A><A NAME="Index1302"></A><B>close(&#160;)</B> for files.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I51' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I52>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Section 1b shows how you can wrap
<A NAME="Index1303"></A><A NAME="Index1304"></A><B>System.in</B> for reading
<A NAME="Index1305"></A><A NAME="Index1306"></A><A NAME="Index1307"></A>console
input. <B>System.in</B> is a <B>DataInputStream</B> and <B>BufferedReader</B>
needs a <B>Reader</B> argument, so <B>InputStreamReader</B> is brought in to
perform the translation. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I52' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I53>
</FONT><BR></P></DIV>
<A NAME="Heading372"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
2. Input from memory</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section takes the <B>String s2</B>
that now contains the entire contents of the file and uses it to create a
<A NAME="Index1308"></A><A NAME="Index1309"></A><B>StringReader</B>. Then
<B>read(&#160;)</B> is used to read each character one at a time and send it out
to the console. Note that <B>read(&#160;)</B> returns the next byte as an
<B>int</B> and thus it must be cast to a <B>char</B> to print properly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I53' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I54>
</FONT><BR></P></DIV>
<A NAME="Heading373"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
3. Formatted memory input</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To read &#8220;formatted&#8221; data, you
use a <A NAME="Index1310"></A><A NAME="Index1311"></A><B>DataInputStream</B>,
which is a <B>byte</B>-oriented I/O class (rather than <B>char</B> oriented).
Thus you must use all <B>InputStream</B> classes rather than <B>Reader</B>
classes. Of course, you can read anything (such as a file) as bytes using
<B>InputStream</B> classes, but here a <B>String</B> is used. To convert the
<B>String</B> to an array of bytes, which is what is appropriate for a
<B>ByteArrayInputStream</B>, <B>String</B> has a
<A NAME="Index1312"></A><B>getBytes(&#160;)</B> method to do the job. At that
point, you have an appropriate <B>InputStream</B> to hand to
<B>DataInputStream</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I54' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I55>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you read the characters from a
<B>DataInputStream </B>one byte at a time using <B>readByte(&#160;)</B>, any
byte value is a legitimate result so the return value cannot be used to detect
the end of input. Instead, you can use the
<A NAME="Index1313"></A><A NAME="Index1314"></A><B>available(&#160;) </B>method
to find out how many more characters are available. Here&#8217;s an example that
shows how to read a file one byte at a time:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:TestEOF.java</font>
<font color=#009900>// Testing for the end of file </font>
<font color=#009900>// while reading a byte at a time.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestEOF {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    DataInputStream in = 
      <font color=#0000ff>new</font> DataInputStream(
       <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"TestEof.java"</font>)));
    <font color=#0000ff>while</font>(in.available() != 0)
      System.out.print((<font color=#0000ff>char</font>)in.readByte());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>available(&#160;)</B> works
differently depending on what sort of medium you&#8217;re reading from;
it&#8217;s literally &#8220;the number of bytes that can be read <I>without
blocking</I>.&#8221;<A NAME="Index1315"></A><A NAME="Index1316"></A> With a file
this means the whole file, but with a different kind of stream this might not be
true, so use it thoughtfully.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I55' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I56>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You could also detect the end of input in
cases like these by catching an exception. However, the use of exceptions for
control flow is considered a misuse of that feature.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I56' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I57>
</FONT><BR></P></DIV>
<A NAME="Heading374"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
4. File output</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example also shows how to write data
to a file. First, a
<A NAME="Index1317"></A><A NAME="Index1318"></A><B>FileWriter</B> is created to
connect to the file. You&#8217;ll virtually always want to buffer the output by
wrapping it in a
<A NAME="Index1319"></A><A NAME="Index1320"></A><B>BufferedWriter</B> (try
removing this wrapping to see the impact on the performance&#8212;buffering
tends to dramatically increase performance of I/O operations). Then for the
formatting it&#8217;s turned into a
<A NAME="Index1321"></A><A NAME="Index1322"></A><B>PrintWriter</B>. The data
file created this way is readable as an ordinary text file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I57' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I58>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As the lines are written to the file,
line numbers are added. Note that <B>LineNumberInputStream</B> is <I>not</I>
used, because it&#8217;s a silly class and you don&#8217;t need it. As shown
here, it&#8217;s trivial to keep track of your own line numbers.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I58' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I59>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1323"></A><A NAME="Index1324"></A><FONT FACE="Georgia">When
the input stream is exhausted,
<A NAME="Index1325"></A><A NAME="Index1326"></A><B>readLine(&#160;)</B> returns
<B>null</B>. You&#8217;ll see an explicit <B>close(&#160;)</B> for <B>out1</B>,
because if you don&#8217;t call <B>close(&#160;)</B> for all your output files,
you might discover that the buffers don&#8217;t get flushed so they&#8217;re
incomplete.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I59' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I60>
</FONT><A NAME="_Toc375545395"></A><A NAME="_Toc481064751"></A><BR></P></DIV>
<A NAME="Heading375"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Output streams</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The two primary kinds of output streams
are separated by the way they write data: one writes it for human consumption,
and the other writes it to be reacquired by a
<A NAME="Index1327"></A><A NAME="Index1328"></A><B>DataInputStream</B>. The
<A NAME="Index1329"></A><A NAME="Index1330"></A><B>RandomAccessFile</B> stands
alone, although its data format is compatible with the <B>DataInputStream</B>
and <A NAME="Index1331"></A><A NAME="Index1332"></A><B>DataOutputStream</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I60' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I61>
</FONT><BR></P></DIV>
<A NAME="Heading376"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
5. Storing and recovering
data<BR><A NAME="Index1333"></A><A NAME="Index1334"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>PrintWriter</B> formats data so
it&#8217;s readable by a human. However, to output data so that it can be
recovered by another stream, you use a <B>DataOutputStream</B> to write the data
and a <B>DataInputStream</B> to recover the data. Of course, these streams could
be anything, but here a file is used, buffered for both reading and writing.
<B>DataOutputStream</B> and <B>DataInputStream</B> are <B>byte</B>-oriented and
thus require the <B>InputStream</B>s and <B>OutputStream</B>s.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I61' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I62>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you use a <B>DataOutputStream</B> to
write the data, then Java guarantees that you can accurately recover the data
using a <B>DataInputStream</B>&#8212;regardless of what different platforms
write and read the data. This is incredibly valuable, as anyone knows who has
spent time worrying about platform-specific data issues. That problem vanishes
if you have Java on both
platforms</FONT><A NAME="fnB58" HREF="#fn58">[58]</A><FONT FACE="Georgia">.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I62' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I63>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1335"></A><A NAME="Index1336"></A><A NAME="Index1337"></A><A NAME="Index1338"></A><FONT FACE="Georgia"><STRIKE>Note
that the character string is written using both <B>writeChars(&#160;) </B>and
<B>writeBytes(&#160;)</B>. When you run the program, you&#8217;ll discover that
<B>writeChars(&#160;)</B> outputs 16-bit Unicode characters. When you read the
line using <B>readLine(&#160;)</B>, you&#8217;ll see that there is a space
between each character, because of the extra byte inserted by Unicode. Since
there is no complementary &#8220;readChars&#8221; method in
<B>DataInputStream</B>, you&#8217;re stuck pulling these characters off one at a
time with
<A NAME="Index1339"></A><A NAME="Index1340"></A><B>readChar(&#160;)</B>. So for
ASCII, it&#8217;s easier to write the characters as bytes followed by a newline;
then use <A NAME="Index1341"></A><A NAME="Index1342"></A><B>readLine(&#160;)</B>
to read back the bytes as a regular ASCII line.</STRIKE><U>When using a
<B>DataOutputStream</B>, the only reliable way to write a <B>String</B> so that
it can be recovered by a <B>DataInputStream</B> is to use UTF-8 encoding,
accomplished above using <B>writeUTF( )</B> and <B>readUTF( )</B>. UTF-8 is a
variation on Unicode, which stores all characters in 2 bytes. If you&#8217;re
working with ASCII or mostly ASCII characters (which only occupy 7 bits), this
is a tremendous waste of space and/or bandwidth, so UTF-8 encodes ASCII
characters in a single byte, and non-ASCII characters in two or three bytes. In
addition, the length of the string is stored in the first two bytes. However,
<B>writeUTF( )</B> and <B>readUTF( )</B> use a special variation of UTF-8 for
Java (which is completely described in the JavaSoft HTML documentation for those
methods) and so if you read a string written with <B>writeUTF( )</B> using a
non-Java program, you must write special code in order to read the string
properly.</U> 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I63' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I64>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><U>With <B>writeUTF( )</B> and
<B>readUTF( )</B>, you can intermingle <B>String</B>s and other types of data
using a <B>DataOutputStream </B>with the knowledge that the <B>String</B>s will
be properly stored as Unicode, and will be easily recoverable with a
<B>DataInputStream</B>.</U>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I64' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I65>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1343"></A><A NAME="Index1344"></A><B>writeDouble(&#160;)</B>
stores the <B>double</B> number to the stream and the complementary
<A NAME="Index1345"></A><A NAME="Index1346"></A><B>readDouble(&#160;)</B>
recovers it (there are similar methods for reading and writing the other types).
But for any of the reading methods to work correctly, you must know the exact
placement of the data item in the stream, since it would be equally possible to
read the stored <B>double</B> as a simple sequence of bytes, or as a
<B>char</B>, etc. So you must either have a fixed format for the data in the
file or extra information must be stored in the file that you parse to determine
where the data is located.<U> Note that object serialization (described later in
this chapter) may be an easier way to store and retrieve complex data
structures.</U> 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I65' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I66>
</FONT><BR></P></DIV>
<A NAME="Heading377"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
6. Reading and writing random access files</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As previously noted, the
<B>RandomAccessFile</B> is almost totally isolated from the rest of the I/O
hierarchy, save for the fact that it implements the <B>DataInput</B> and
<B>DataOutput</B> interfaces. So you cannot combine it with any of the aspects
of the <B>InputStream</B> and <B>OutputStream</B> subclasses. Even though it
might make sense to treat a <B>ByteArrayInputStream</B> as a random access
element, you can use <B>RandomAccessFile</B> to only open a file. You must
assume a <B>RandomAccessFile</B> is properly buffered since you cannot add
that.<B> 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I66' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I67>
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The one option you have is in the second
constructor argument: you can open a <B>RandomAccessFile</B> to read
(<B>&#8220;r&#8221;</B>) or read and write (<B>&#8220;rw&#8221;</B>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I67' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I68>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using a <B>RandomAccessFile</B> is like
using a combined <B>DataInputStream</B> and <B>DataOutputStream</B> (because it
implements the equivalent interfaces). In addition, you can see that
<A NAME="Index1347"></A><A NAME="Index1348"></A><B>seek(&#160;)</B> is used to
move about in the file and change one of the values.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I68' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I69>
</FONT><A NAME="_Toc481064752"></A><BR></P></DIV>
<A NAME="Heading378"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
A bug?A bug?</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><STRIKE>If you look at section 5,
you&#8217;ll see that the data is written <I>before</I> the text. That&#8217;s
because a problem was introduced in Java 1.1 (and persists in Java 2) that sure
seems like a bug to me, but I reported it and the bug people at JavaSoft said
that this is the way it is supposed to work (however, the problem did <I>not</I>
occur in Java 1.0, which makes me suspicious). The problem is shown in the
following code:</STRIKE></FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:IOProblem.java</font>
<font color=#009900>// Java 1.1 and higher I/O Problem.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IOProblem {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    DataOutputStream out =
      <font color=#0000ff>new</font> DataOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Data.txt"</font>)));
    out.writeDouble(3.14159);
    out.writeBytes(<font color=#004488>"That was the value of pi\n"</font>);
    out.writeBytes(<font color=#004488>"This is pi</font><font color=#004488>/2:\n"</font>);
    out.writeDouble(3.14159/2);
    out.close();

    DataInputStream in =
      <font color=#0000ff>new</font> DataInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(
          <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Data.txt"</font>)));
    BufferedReader inbr =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(in));
    <font color=#009900>// The doubles written BEFORE the line of text</font>
    <font color=#009900>// read back correctly:</font>
    System.out.println(in.readDouble());
    <font color=#009900>// Read the lines of text:</font>
    System.out.println(inbr.readLine());
    System.out.println(inbr.readLine());
    <font color=#009900>// Trying to read the doubles after the line</font>
    <font color=#009900>// produces an end-of-file exception:</font>
    System.out.println(in.readDouble());
  }</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><TT><FONT FACE="Courier New"><STRIKE>}
///:~</STRIKE></FONT></TT><BR></P></DIV>


<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">[Removed from text] <U>(This was a bug in
my reasoning &#8211; I did not understand the intention of <B>writeUTF( )
</B>and <B>readUTF( )</B>. Also, creating two buffers for the same stream turns
out to be a big mistake &#8211; the first buffer that you read sucks up extra
bytes so the second buffer gets indeterminate output).</U>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I69' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I70>
</FONT><A NAME="_Toc481064753"></A><BR></P></DIV>
<A NAME="Heading379"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Piped streams<BR><A NAME="Index1349"></A><A NAME="Index1350"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>PipedInputStream</B>,
<B>PipedOutputStream</B>, <B>PipedReader</B> and <B>PipedWriter</B> have been
mentioned only briefly in this chapter. This is not to suggest that they
aren&#8217;t useful, but their value is not apparent until you begin to
understand multithreading, since the piped streams are used to communicate
between threads. This is covered along with an example in Chapter 14.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I70' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I71>
</FONT><A NAME="_Toc481064754"></A><BR></P></DIV>
<A NAME="Heading380"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Standard
I/O<BR><A NAME="Index1351"></A><A NAME="Index1352"></A><A NAME="Index1353"></A><A NAME="Index1354"></A><A NAME="Index1355"></A><A NAME="Index1356"></A><A NAME="Index1357"></A><A NAME="Index1358"></A><A NAME="Index1359"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The term <I>standard I/O</I> refers to
the Unix concept (which is reproduced in some form in Windows and many other
operating systems) of a single stream of information that is used by a program.
All the program&#8217;s input can come from <I>standard input</I>, all its
output can go to <I>standard output</I>, and all of its error messages can be
sent to <I>standard error</I>. The value of standard I/O is that programs can
easily be chained together and one program&#8217;s standard output can become
the standard input for another program. This is a powerful tool.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I71' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I72>
</FONT><A NAME="_Toc375545397"></A><A NAME="_Toc481064755"></A><BR></P></DIV>
<A NAME="Heading381"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Reading from standard input</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Following the standard I/O model, Java
has <B>System.in</B>, <B>System.out,</B> and <B>System.err</B>. Throughout this
book you&#8217;ve seen how to write to standard output using <B>System.out,</B>
which is already prewrapped as a <B>PrintStream</B> object. <B>System.err</B> is
likewise a <B>PrintStream</B>, but <B>System.in</B> is a raw <B>InputStream</B>,
with no wrapping. This means that while you can use <B>System.out</B> and
<B>System.err</B> right away, <B>System.in</B> must be wrapped before you can
read from it. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I72' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I73>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Typically, you&#8217;ll want to read
input a line at a time using <B>readLine(&#160;)</B>, so you&#8217;ll want to
wrap <B>System.in</B> in a <B>BufferedReader</B>. To do this, you must convert
<B>System.in </B>to a <B>Reader</B> using <B>InputStreamReader</B>. Here&#8217;s
an example that simply echoes each line that you type in:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Echo.java</font>
<font color=#009900>// How to read from standard input.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Echo {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException {
    BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = in.readLine()).length() != 0)
      System.out.println(s);
    <font color=#009900>// An empty line terminates the program</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason for the exception
specification is that
<A NAME="Index1360"></A><A NAME="Index1361"></A><B>readLine(&#160;)</B> can
throw an <B>IOException</B>. Note that <B>System.in</B> should usually be
buffered, as with most streams.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I73' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I74>
</FONT><A NAME="_Toc481064756"></A><BR></P></DIV>
<A NAME="Heading382"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Changing System.out to a PrintWriter</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>System.out</B> is a
<B>PrintStream</B>, which is an <B>OutputStream</B>.<B> PrintWriter</B> has a
constructor that takes an <B>OutputStream</B> as an argument. Thus, if you want
you can convert <B>System.out</B> into a <B>PrintWriter</B> using that
constructor:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ChangeSystemOut.java</font>
<font color=#009900>// Turn System.out into a PrintWriter.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ChangeSystemOut {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    PrintWriter out = 
      <font color=#0000ff>new</font> PrintWriter(System.out, <font color=#0000ff>true</font>);
    out.println(<font color=#004488>"Hello, world"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s important to use the
two-argument version of the <B>PrintWriter</B> constructor and to set the second
argument to <B>true</B> in order to enable automatic flushing, otherwise you may
not see the output.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I74' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I75>
</FONT><A NAME="_Toc481064757"></A><BR></P></DIV>
<A NAME="Heading383"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Redirecting standard
I/O<BR><A NAME="Index1362"></A><A NAME="Index1363"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java <B>System</B> class allows you
to redirect the standard input, output, and error I/O streams using simple
static method calls:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1364"></A><A NAME="Index1365"></A><FONT FACE="Georgia"><B>setIn(InputStream)
</B></FONT><BR><A NAME="Index1366"></A><A NAME="Index1367"></A><FONT FACE="Georgia"><B>setOut(PrintStream)</B></FONT><BR><A NAME="Index1368"></A><A NAME="Index1369"></A><FONT FACE="Georgia"><B>setErr(PrintStream)
</B> 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I75' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I76>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Redirecting output is especially useful
if you suddenly start creating a large amount of output on your screen and
it&#8217;s scrolling past faster than you can read
it.</FONT><A NAME="fnB59" HREF="#fn59">[59]</A><FONT FACE="Georgia"> Redirecting
input is valuable for a command-line program in which you want to test a
particular user-input sequence repeatedly. Here&#8217;s a simple example that
shows the use of these methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Redirecting.java</font>
<font color=#009900>// Demonstrates standard I/O redirection.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Redirecting {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    BufferedInputStream in = 
      <font color=#0000ff>new</font> BufferedInputStream(
        <font color=#0000ff>new</font> FileInputStream(
          <font color=#004488>"Redirecting.java"</font>));
    PrintStream out =
      <font color=#0000ff>new</font> PrintStream(
        <font color=#0000ff>new</font> BufferedOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.out"</font>)));
    System.setIn(in);
    System.setOut(out);
    System.setErr(out);

    BufferedReader br = 
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(System.in));
    String s;
    <font color=#0000ff>while</font>((s = br.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
    out.close(); <font color=#009900>// Remember this!</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program attaches standard input to a
file, and redirects standard output and standard error to another file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I76' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I77>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">I/O redirection manipulates streams of
bytes, not streams of characters, thus <B>InputStream</B>s and
<B>OutputStream</B>s are used rather than <B>Reader</B>s and <B>Writer</B>s.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I77' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I78>
</FONT><A NAME="_Toc375545400"></A><A NAME="_Toc481064758"></A><BR></P></DIV>
<A NAME="Heading384"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Compression<BR><A NAME="Index1370"></A><A NAME="Index1371"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java I/O library contains classes to
support reading and writing streams in a compressed format. These are wrapped
around existing I/O classes to provide compression functionality.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I78' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I79>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These classes are not derived from the
<B>Reader</B> and <B>Writer</B> classes, but instead are part of the
<B>InputStream</B> and <B>OutputStream</B> hierarchies. This is because the
compression library works with bytes, not characters. However, you might
sometimes be forced to mix the two types of streams. (Remember that you can use
<B>InputStreamReader</B> and <B>OutputStreamWriter</B> to provide easy
conversion between one type and another.)
<A NAME="Index1372"></A><A NAME="Index1373"></A><A NAME="Index1374"></A><A NAME="Index1375"></A><A NAME="Index1376"></A><A NAME="Index1377"></A><A NAME="Index1378"></A><A NAME="Index1379"></A><A NAME="Index1380"></A><A NAME="Index1381"></A><A NAME="Index1382"></A><A NAME="Index1383"></A><A NAME="Index1384"></A><A NAME="Index1385"></A><A NAME="Index1386"></A><A NAME="Index1387"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=148 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Compression class</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=211 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Function</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CheckedInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> produces
checksum for any <B>InputStream</B> (not just decompression).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CheckedOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GetCheckSum(&#160;)</B> produces
checksum for any <B>OutputStream</B> (not just compression).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>DeflaterOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Base class for compression
classes.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ZipOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterOutputStream</B> that
compresses data into the Zip file format.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GZIPOutputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>DeflaterOutputStream</B> that
compresses data into the GZIP file format.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>InflaterInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Base class for decompression
classes.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ZipInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>InflaterInputStream</B> that
decompresses data that has been stored in the Zip file format.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>GZIPInputStream</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>InflaterInputStream</B> that
decompresses data that has been stored in the GZIP file format.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although there are many compression
algorithms, Zip and GZIP are possibly the most commonly used. Thus you can
easily manipulate your compressed data with the many tools available for reading
and writing these formats.</FONT><A NAME="_Toc481064759"></A><BR></P></DIV>
<A NAME="Heading385"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Simple compression with GZIP</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The GZIP interface is simple and thus is
probably more appropriate when you have a single stream of data that you want to
compress (rather than a container of dissimilar pieces of data). Here&#8217;s an
example that compresses a single file:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:GZIPcompress.java</font>
<font color=#009900>// Uses GZIP compression to compress a file </font>
<font color=#009900>// whose name is passed on the command line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> GZIPcompress {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    BufferedReader in =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> FileReader(args[0]));
    BufferedOutputStream out =
      <font color=#0000ff>new</font> BufferedOutputStream(
        <font color=#0000ff>new</font> GZIPOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.gz"</font>)));
    System.out.println(<font color=#004488>"Writing file"</font>);
    <font color=#0000ff>int</font> c;
    <font color=#0000ff>while</font>((c = in.read()) != -1)
      out.write(c);
    in.close();
    out.close();
    System.out.println(<font color=#004488>"Reading file"</font>);
    BufferedReader in2 =
      <font color=#0000ff>new</font> BufferedReader(
        <font color=#0000ff>new</font> InputStreamReader(
          <font color=#0000ff>new</font> GZIPInputStream(
            <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.gz"</font>))));
    String s;
    <font color=#0000ff>while</font>((s = in2.readLine()) != <font color=#0000ff>null</font>)
      System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of the compression classes is
straightforward&#8212;you simply wrap your output stream in a
<B>GZIPOutputStream</B> or <B>ZipOutputStream</B> and your input stream in a
<B>GZIPInputStream</B> or <B>ZipInputStream</B>. All else is ordinary I/O
reading and writing. This is an example of mixing the <B>char</B>-oriented
streams with the <B>byte</B>-oriented streams: <B>in</B> uses the <B>Reader</B>
classes, whereas <B>GZIPOutputStream</B>&#8217;s constructor can accept only an
<B>OutputStream</B> object, not a <B>Writer</B> object. When the file is opened,
the <B>GZIPInputStream</B> is converted to a <B>Reader</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I79' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I80>
</FONT><A NAME="_Toc481064760"></A><BR></P></DIV>
<A NAME="Heading386"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Multifile storage with Zip</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The library that supports the Zip format
is much more extensive. With it you can easily store multiple files, and
there&#8217;s even a separate class to make the process of reading a Zip file
easy. The library uses the standard Zip format so that it works seamlessly with
all the tools currently downloadable on the Internet. The following example has
the same form as the previous example, but it handles as many command-line
arguments as you want. In addition, it shows the use of the
<A NAME="Index1388"></A><B>Checksum</B> classes to calculate and verify the
checksum for the file. There are two <B>Checksum</B> types:
<A NAME="Index1389"></A><B>Adler32</B> (which is faster) and
<A NAME="Index1390"></A><B>CRC32</B> (which is slower but slightly more
accurate). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I80' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I81>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ZipCompress.java</font>
<font color=#009900>// Uses Zip compression to compress any </font>
<font color=#009900>// number of files given on the command line.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.util.zip.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ZipCompress {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    FileOutputStream f =
      <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"test.zip"</font>);
    CheckedOutputStream csum =
      <font color=#0000ff>new</font> CheckedOutputStream(
        f, <font color=#0000ff>new</font> Adler32());
    ZipOutputStream out =
      <font color=#0000ff>new</font> ZipOutputStream(
        <font color=#0000ff>new</font> BufferedOutputStream(csum));
    out.setComment(<font color=#004488>"A test of Java Zipping"</font>);
    <font color=#009900>// No corresponding getComment(), though.</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; args.length; i++) {
      System.out.println(
        <font color=#004488>"Writing file "</font> + args[i]);
      BufferedReader in =
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(args[i]));
      out.putNextEntry(<font color=#0000ff>new</font> ZipEntry(args[i]));
      <font color=#0000ff>int</font> c;
      <font color=#0000ff>while</font>((c = in.read()) != -1)
        out.write(c);
      in.close();
    }
    out.close();
    <font color=#009900>// Checksum valid only after the file</font>
    <font color=#009900>// has been closed!</font>
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csum.getChecksum().getValue());
    <font color=#009900>// Now extract the files:</font>
    System.out.println(<font color=#004488>"Reading file"</font>);
    FileInputStream fi =
       <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"test.zip"</font>);
    CheckedInputStream csumi =
      <font color=#0000ff>new</font> CheckedInputStream(
        fi, <font color=#0000ff>new</font> Adler32());
    ZipInputStream in2 =
      <font color=#0000ff>new</font> ZipInputStream(
        <font color=#0000ff>new</font> BufferedInputStream(csumi));
    ZipEntry ze;
    <font color=#0000ff>while</font>((ze = in2.getNextEntry()) != <font color=#0000ff>null</font>) {
      System.out.println(<font color=#004488>"Reading file "</font> + ze);
      <font color=#0000ff>int</font> x;
      <font color=#0000ff>while</font>((x = in2.read()) != -1)
        System.out.write(x);
    }
    System.out.println(<font color=#004488>"Checksum: "</font> +
      csumi.getChecksum().getValue());
    in2.close();
    <font color=#009900>// Alternative way to open and read</font>
    <font color=#009900>// zip files:</font>
    ZipFile zf = <font color=#0000ff>new</font> ZipFile(<font color=#004488>"test.zip"</font>);
    Enumeration e = zf.entries();
    <font color=#0000ff>while</font>(e.hasMoreElements()) {
      ZipEntry ze2 = (ZipEntry)e.nextElement();
      System.out.println(<font color=#004488>"File: "</font> + ze2);
      <font color=#009900>// ... and extract the data as before</font>
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For each file to add to the archive, you
must call <B>putNextEntry(&#160;) </B>and pass it a
<A NAME="Index1391"></A><A NAME="Index1392"></A><B>ZipEntry </B>object. The
<B>ZipEntry</B> object contains an extensive interface that allows you to get
and set all the data available on that particular entry in your Zip file: name,
compressed and uncompressed sizes, date, CRC checksum, extra field data,
comment, compression method, and whether it&#8217;s a directory entry. However,
even though the Zip format has a way to set a password, this is not supported in
Java&#8217;s Zip library. And although <B>CheckedInputStream</B> and
<B>CheckedOutputStream</B> support both <B>Adler32</B> and <B>CRC32</B>
checksums, the <B>ZipEntry</B> class supports only an interface for CRC. This is
a restriction of the underlying Zip format, but it might limit you from using
the faster <B>Adler32</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I81' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I82>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To extract files, <B>ZipInputStream</B>
has a <B>getNextEntry(&#160;)</B> method that returns the next <B>ZipEntry</B>
if there is one. As a more succinct alternative, you can read the file using a
<B>ZipFile</B> object, which has a method <B>entries(&#160;) </B>to return an
<B>Enumeration</B> to the <B>ZipEntries</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I82' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I83>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In order to read the checksum you must
somehow have access to the associated <B>Checksum</B> object. Here, a reference
to the <B>CheckedOutputStream</B> and <B>CheckedInputStream</B> objects is
retained, but you could also just hold onto a reference to the <B>Checksum</B>
object. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I83' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I84>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A baffling method in Zip streams is
<B>setComment(&#160;)</B>. As shown above, you can set a comment when
you&#8217;re writing a file, but there&#8217;s no way to recover the comment in
the <B>ZipInputStream</B>. Comments appear to be supported fully on an
entry-by-entry basis only via <B>ZipEntry</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I84' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I85>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you are not limited to files
when using the <B>GZIP</B> or <B>Zip</B> libraries&#8212;you can compress
anything, including data to be sent through a network connection.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I85' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I86>
</FONT><A NAME="_Toc481064761"></A><BR></P></DIV>
<A NAME="Heading387"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Java ARchives (JARs)</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Zip format is also used in the
<A NAME="Index1393"></A><A NAME="Index1394"></A>JAR (Java ARchive) file format,
which is a way to collect a group of files into a single compressed file, just
like Zip. However, like everything else in Java, JAR files are cross-platform so
you don&#8217;t need to worry about platform issues. You can also include audio
and image files as well as class files. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I86' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I87>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">JAR files are particularly helpful when
you deal with the Internet. Before JAR files, your Web browser would have to
make repeated requests of a Web server in order to download all of the files
that make up an applet. In addition, each of these files was uncompressed. By
combining all of the files for a particular applet into a single JAR file, only
one server request is necessary and the transfer is faster because of
compression. And each entry in a JAR file can be digitally signed for security
(refer to the Java documentation for details).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I87' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I88>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A JAR file consists of a single file
containing a collection of zipped files along with a
&#8220;<A NAME="Index1395"></A>manifest&#8221; that describes them. (You can
create your own manifest file; otherwise the <B>jar </B>program will do it for
you.) You can find out more about JAR manifests in the JDK HTML documentation.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I88' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I89>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>jar</B> utility that comes with
Sun&#8217;s JDK automatically compresses the files of your choice. You invoke it
on the command line: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I89' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I90>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar [options] destination [manifest] inputfile(s)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The options are simply a collection of
letters (no hyphen or any other indicator is necessary). Unix/Linux users will
note the similarity to the <B>tar </B>options. These are:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>c </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Creates a new or empty archive.
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>t </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Lists the table of contents.
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>x</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Extracts all files.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>x file</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Extracts the named file.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>f</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Says: &#8220;I&#8217;m going to give you
the name of the file.&#8221; If you don&#8217;t use this, jar assumes that its
input will come from standard input, or, if it is creating a file, its output
will go to standard output.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>m</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Says that the first argument will be the
name of the user-created manifest file.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>v</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Generates verbose output describing what
jar is doing.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>0</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Only store the files; doesn&#8217;t
compress the files (use to create a JAR file that you can put in your
classpath).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>M</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Don&#8217;t automatically create a
manifest file.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a subdirectory is included in the
files to be put into the JAR file, that subdirectory is automatically added,
including all of its subdirectories, etc. Path information is also
preserved.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here are some typical ways to invoke
<B>jar</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cf myJarFile.jar *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This creates a JAR file called
<B>myJarFile.jar</B> that contains all of the class files in the current
directory, along with an automatically generated manifest file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I90' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I91>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cmf myJarFile.jar myManifestFile.mf *.<font color=#0000ff>class</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Like the previous example, but adding a
user-created manifest file called <B>myManifestFile.mf</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I91' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I92>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tf myJarFile.jar</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces a table of contents of the files
in <B>myJarFile.jar</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I92' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I93>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar tvf myJarFile.jar</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adds the &#8220;verbose&#8221; flag to
give more detailed information about the files in <B>myJarFile.jar</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I93' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I94>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>jar cvf myApp.jar audio classes image</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assuming <B>audio</B>, <B>classes,</B>
and <B>image</B> are subdirectories, this combines all of the subdirectories
into the file <B>myApp.jar</B>. The &#8220;verbose&#8221; flag is also included
to give extra feedback while the <B>jar</B> program is working.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I94' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I95>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you create a JAR file using the
<B>0</B> option, that file can be placed in your CLASSPATH:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CLASSPATH=<font color=#004488>"lib1.jar;lib2.jar;"</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Then Java can search <B>lib1.jar</B> and
<B>lib2.jar</B> for class files.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I95' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I96>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>jar</B> tool isn&#8217;t as useful
as a <B>zip</B> utility. For example, you can&#8217;t add or update files to an
existing JAR file; you can create JAR files only from scratch. Also, you
can&#8217;t move files into a JAR file, erasing them as they are moved. However,
a JAR file created on one platform will be transparently readable by the
<B>jar</B> tool on any other platform (a problem that sometimes plagues
<B>zip</B> utilities). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I96' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I97>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you will see in Chapter 13, JAR files
are also used to package JavaBeans.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I97' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I98>
</FONT><A NAME="_Toc481064762"></A><BR></P></DIV>
<A NAME="Heading388"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Object
serialization<BR><A NAME="Index1396"></A><A NAME="Index1397"></A><A NAME="Index1398"></A><A NAME="Index1399"></A><A NAME="Index1400"></A><A NAME="Index1401"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Java&#8217;s <I>object serialization</I>
allows you to take any object that implements the <B>Serializable</B> interface
and turn it into a sequence of bytes that can later be fully restored to
regenerate the original object. This is even true across a network, which means
that the serialization mechanism automatically compensates for differences in
operating systems. That is, you can create an object on a Windows machine,
serialize it, and send it across the network to a Unix machine where it will be
correctly reconstructed. You don&#8217;t have to worry about the data
representations on the different machines, the byte ordering, or any other
details. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I98' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I99>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By itself, object serialization is
interesting because it allows you to implement <I>lightweight persistence</I>.
Remember that persistence means an object&#8217;s lifetime is not determined by
whether a program is executing&#8212;the object lives <I>in</I> <I>between</I>
invocations of the program. By taking a serializable object and writing it to
disk, then restoring that object when the program is reinvoked, you&#8217;re
able to produce the effect of persistence. The reason it&#8217;s called
&#8220;lightweight&#8221; is that you can&#8217;t simply define an object using
some kind of &#8220;persistent&#8221; keyword and let the system take care of
the details (although this might happen in the future). Instead, you must
explicitly serialize and deserialize the objects in your program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I99' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I100>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization was added to the
language to support two major features. Java&#8217;s <I>remote method
invocation</I> (RMI) allows objects that live on other machines to behave as if
they live on your machine. When sending messages to remote objects, object
serialization is necessary to transport the arguments and return values. RMI is
discussed in Chapter 15. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I100' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I101>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization is also necessary
for JavaBeans, described in Chapter 13. When a Bean is used, its state
information is generally configured at design-time. This state information must
be stored and later recovered when the program is started; object serialization
performs this task. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I101' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I102>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Serializing an object is quite simple, as
long as the object implements the <B>Serializable</B> interface (this interface
is just a flag and has no methods). When serialization was added to the
language, many standard library classes were changed to make them serializable,
including all of the wrappers for the primitive types, all of the container
classes, and many others. Even <B>Class</B> objects can be serialized. (See
Chapter 12 for the implications of this.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I102' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I103>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To serialize an object, you create some
sort of <B>OutputStream</B> object and then wrap it inside an
<A NAME="Index1402"></A><A NAME="Index1403"></A><B>ObjectOutputStream</B>
object. At this point you need only call
<A NAME="Index1404"></A><A NAME="Index1405"></A><B>writeObject(&#160;)</B> and
your object is serialized and sent to the <B>OutputStream</B>. To reverse the
process, you wrap an <B>InputStream</B> inside an <B>ObjectInputStream</B> and
call <A NAME="Index1406"></A><A NAME="Index1407"></A><B>readObject(&#160;)</B>.
What comes back is, as usual, a reference to an upcast <B>Object</B>, so you
must downcast to set things straight.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I103' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I104>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A particularly clever aspect of object
serialization is that it not only saves an image of your object but it also
follows all the references contained in your object and saves <I>those
</I>objects, and follows all the references in each of those objects, etc. This
is sometimes referred to as the
&#8220;<A NAME="Index1408"></A><A NAME="Index1409"></A>web of objects&#8221;
that a single object can be connected to, and it includes arrays of references
to objects as well as member objects. If you had to maintain your own object
serialization scheme, maintaining the code to follow all these links would be a
bit mind-boggling. However, Java object serialization seems to pull it off
flawlessly, no doubt using an optimized algorithm that traverses the web of
objects. The following example tests the serialization mechanism by making a
&#8220;worm&#8221; of linked objects, each of which has a link to the next
segment in the worm as well as an array of references to objects of a different
class, <B>Data</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Worm.java</font>
<font color=#009900>// Demonstrates object serialization.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>class</font> Data <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  Data(<font color=#0000ff>int</font> x) { i = x; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> Integer.toString(i);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Worm <font color=#0000ff>implements</font> Serializable {
  <font color=#009900>// Generate a random int value:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> r() {
    <font color=#0000ff>return</font> (<font color=#0000ff>int</font>)(Math.random() * 10);
  }
  <font color=#0000ff>private</font> Data[] d = {
    <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r()), <font color=#0000ff>new</font> Data(r())
  };
  <font color=#0000ff>private</font> Worm next;
  <font color=#0000ff>private</font> <font color=#0000ff>char</font> c;
  <font color=#009900>// Value of i == number of segments</font>
  Worm(<font color=#0000ff>int</font> i, <font color=#0000ff>char</font> x) {
    System.out.println(<font color=#004488>" Worm constructor: "</font> + i);
    c = x;
    <font color=#0000ff>if</font>(--i &gt; 0)
      next = <font color=#0000ff>new</font> Worm(i, (<font color=#0000ff>char</font>)(x + 1));
  }
  Worm() {
    System.out.println(<font color=#004488>"Default constructor"</font>);
  }
  <font color=#0000ff>public</font> String toString() {
    String s = <font color=#004488>":"</font> + c + <font color=#004488>"("</font>;
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; d.length; i++)
      s += d[i].toString();
    s += <font color=#004488>")"</font>;
    <font color=#0000ff>if</font>(next != <font color=#0000ff>null</font>)
      s += next.toString();
    <font color=#0000ff>return</font> s;
  }
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> ClassNotFoundException, IOException {
    Worm w = <font color=#0000ff>new</font> Worm(6, 'a');
    System.out.println(<font color=#004488>"w = "</font> + w);
    ObjectOutputStream out =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"worm.out"</font>));
    out.writeObject(<font color=#004488>"Worm storage"</font>);
    out.writeObject(w);
    out.close(); <font color=#009900>// Also flushes output</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"worm.out"</font>));
    String s = (String)in.readObject();
    Worm w2 = (Worm)in.readObject();
    System.out.println(s + <font color=#004488>", w2 = "</font> + w2);
    ByteArrayOutputStream bout =
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream out2 =
      <font color=#0000ff>new</font> ObjectOutputStream(bout);
    out2.writeObject(<font color=#004488>"Worm storage"</font>);
    out2.writeObject(w);
    out2.flush();
    ObjectInputStream in2 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          bout.toByteArray()));
    s = (String)in2.readObject();
    Worm w3 = (Worm)in2.readObject();
    System.out.println(s + <font color=#004488>", w3 = "</font> + w3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To make things interesting, the array of
<B>Data</B> objects inside <B>Worm</B> are initialized with random numbers.
(This way you don&#8217;t suspect the compiler of keeping some kind of
meta-information.) Each <B>Worm</B> segment is labeled with a <B>char</B>
that&#8217;s automatically generated in the process of recursively generating
the linked list of <B>Worm</B>s. When you create a <B>Worm</B>, you tell the
constructor how long you want it to be. To make the <B>next</B> reference it
calls the <B>Worm</B> constructor with a length of one less, etc. The final
<B>next</B> reference is left as <B>null</B>, indicating the end of the
<B>Worm</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I104' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I105>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The point of all this was to make
something reasonably complex that couldn&#8217;t easily be serialized. The act
of serializing, however, is quite simple. Once the <B>ObjectOutputStream</B> is
created from some other stream, <B>writeObject(&#160;)</B> serializes the
object. Notice the call to <B>writeObject(&#160;)</B> for a <B>String</B>, as
well. You can also write all the primitive data types using the same methods as
<B>DataOutputStream</B> (they share the same interface).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I105' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I106>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two separate code sections that
look similar. The first writes and reads a file and the second, for variety,
writes and reads a <B>ByteArray</B>. You can read and write an object using
serialization to any <B>DataInputStream</B> or <B>DataOutputStream</B>
including, as you will see in the Chapter 15, a network. The output from one run
was:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w2 = :a(262):b(100):c(396):d(480):e(316):f(398)
Worm storage, w3 = :a(262):b(100):c(396):d(480):e(316):f(398)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the deserialized object
really does contain all of the links that were in the original object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I106' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I107>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that no constructor, not even the
default constructor, is called in the process of deserializing a
<B>Serializable</B> object. The entire object is restored by recovering data
from the <B>InputStream</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I107' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I108>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Object serialization is
<B>byte</B>-oriented, and thus uses the <B>InputStream</B> and
<B>OutputStream</B> hierarchies.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I108' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I109>
</FONT><A NAME="_Toc481064763"></A><BR></P></DIV>
<A NAME="Heading389"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Finding the class</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder what&#8217;s necessary
for an object to be recovered from its serialized state. For example, suppose
you serialize an object and send it as a file or through a network to another
machine. Could a program on the other machine reconstruct the object using only
the contents of the file?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I109' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I110>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The best way to answer this question is
(as usual) by performing an experiment. The following file goes in the
subdirectory for this chapter:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I110' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I111>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Alien.java</font>
<font color=#009900>// A serializable class.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Alien <font color=#0000ff>implements</font> Serializable {
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The file that creates and serializes an
<B>Alien </B>object goes in the same directory:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I111' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I112>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:FreezeAlien.java</font>
<font color=#009900>// Create a serialized output file.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FreezeAlien {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    ObjectOutput out = 
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"X.file"</font>));
    Alien zorcon = <font color=#0000ff>new</font> Alien();
    out.writeObject(zorcon); 
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Rather than catching and handling
exceptions, this program takes the quick and dirty approach of passing the
exceptions out of <B>main(&#160;)</B>, so they&#8217;ll be reported on the
command line. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I112' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I113>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the program is compiled and run,
copy the resulting <B>X.file</B> to a subdirectory called <B>xfiles</B>, where
the following code goes: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I113' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I114>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:xfiles:ThawAlien.java</font>
<font color=#009900>// Try to recover a serialized file without the </font>
<font color=#009900>// class of object that's stored in that file.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ThawAlien {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"X.file"</font>));
    Object mystery = in.readObject();
    System.out.println(mystery.getClass());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program opens the file and reads in
the object <B>mystery</B> successfully. However, as soon as you try to find out
anything about the object&#8212;which requires the <B>Class</B> object for
<B>Alien</B>&#8212;the Java Virtual Machine (JVM) cannot find <B>Alien.class</B>
(unless it happens to be in the Classpath, which it shouldn&#8217;t be in this
example). You&#8217;ll get a <B>ClassNotFoundException.</B> (Once again, all
evidence of alien life vanishes before proof of its existence can be verified!)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I114' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I115>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you expect to do much after
you&#8217;ve recovered an object that has been serialized, you must make sure
that the JVM can find the associated <B>.class</B> file either in the local
class path or somewhere on the Internet.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I115' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I116>
</FONT><A NAME="_Toc481064764"></A><BR></P></DIV>
<A NAME="Heading390"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Controlling
serialization<BR><A NAME="Index1410"></A><A NAME="Index1411"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you can see, the default serialization
mechanism is trivial to use. But what if you have special needs? Perhaps you
have special security issues and you don&#8217;t want to serialize portions of
your object, or perhaps it just doesn&#8217;t make sense for one subobject to be
serialized if that part needs to be created anew when the object is recovered.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I116' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I117>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can control the process of
serialization by implementing the
<A NAME="Index1412"></A><A NAME="Index1413"></A><B>Externalizable</B> interface
instead of the
<A NAME="Index1414"></A><A NAME="Index1415"></A><B>Serializable</B> interface.
The <B>Externalizable</B> interface extends the <B>Serializable</B> interface
and adds two methods,
<A NAME="Index1416"></A><A NAME="Index1417"></A><B>writeExternal(&#160;)</B> and
<A NAME="Index1418"></A><A NAME="Index1419"></A><B>readExternal(&#160;),</B>
that are automatically called for your object during serialization and
deserialization so that you can perform your special operations.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I117' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I118>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows simple
implementations of the <B>Externalizable</B> interface methods. Note that
<B>Blip1</B> and <B>Blip2</B> are nearly identical except for a subtle
difference (see if you can discover it by looking at the code):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Blips.java</font>
<font color=#009900>// Simple use of Externalizable &amp; a pitfall.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Blip1 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>public</font> Blip1() {
    System.out.println(<font color=#004488>"Blip1 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip1.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip1.readExternal"</font>);
  }
}

<font color=#0000ff>class</font> Blip2 <font color=#0000ff>implements</font> Externalizable {
  Blip2() {
    System.out.println(<font color=#004488>"Blip2 Constructor"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
      <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip2.writeExternal"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
     <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip2.readExternal"</font>);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blips {
  <font color=#009900>// Throw exceptions to console:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip1 b1 = <font color=#0000ff>new</font> Blip1();
    Blip2 b2 = <font color=#0000ff>new</font> Blip2();
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Saving objects:"</font>);
    o.writeObject(b1);
    o.writeObject(b2);
    o.close();
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blips.out"</font>));
    System.out.println(<font color=#004488>"Recovering b1:"</font>);
    b1 = (Blip1)in.readObject();
    <font color=#009900>// OOPS! Throws an exception:</font>
<font color=#009900>//! System.out.println("Recovering b2:");</font>
<font color=#009900>//! b2 = (Blip2)in.readObject();</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for this program is:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I118' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I119>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The reason that the <B>Blip2</B> object
is not recovered is that trying to do so causes an exception. Can you see the
difference between <B>Blip1</B> and <B>Blip2</B>? The constructor for
<B>Blip1</B> is <B>public</B>, while the constructor for <B>Blip2</B> is not,
and that causes the exception upon recovery. Try making <B>Blip2</B>&#8217;s
constructor <B>public </B>and removing the <B>//! </B>comments to see the
correct results. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I119' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I120>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When <B>b1</B> is recovered, the
<B>Blip1</B> default constructor is called. This is different from recovering a
<B>Serializable</B> object, in which the object is constructed entirely from its
stored bits, with no constructor calls. With an <B>Externalizable</B> object,
all the normal default construction behavior occurs (including the
initializations at the point of field definition), and <I>then</I>
<B>readExternal(&#160;)</B> is called. You need to be aware of this&#8212;in
particular, the fact that all the default construction always takes
place&#8212;to produce the correct behavior in your <B>Externalizable</B>
objects. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I120' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I121>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows what
you must do to fully store and retrieve an <B>Externalizable</B> object:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I121' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I122>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Blip3.java</font>
<font color=#009900>// Reconstructing an externalizable object.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Blip3 <font color=#0000ff>implements</font> Externalizable {
  <font color=#0000ff>int</font> i;
  String s; <font color=#009900>// No initialization</font>
  <font color=#0000ff>public</font> Blip3() {
    System.out.println(<font color=#004488>"Blip3 Constructor"</font>);
    <font color=#009900>// s, i not initialized</font>
  }
  <font color=#0000ff>public</font> Blip3(String x, <font color=#0000ff>int</font> a) {
    System.out.println(<font color=#004488>"Blip3(String x, int a)"</font>);
    s = x;
    i = a;
    <font color=#009900>// s &amp; i initialized only in nondefault</font>
    <font color=#009900>// constructor.</font>
  }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> s + i; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> writeExternal(ObjectOutput out)
  <font color=#0000ff>throws</font> IOException {
    System.out.println(<font color=#004488>"Blip3.writeExternal"</font>);
    <font color=#009900>// You must do this:</font>
    out.writeObject(s); 
    out.writeInt(i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> readExternal(ObjectInput in)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Blip3.readExternal"</font>);
    <font color=#009900>// You must do this:</font>
    s = (String)in.readObject(); 
    i =in.readInt();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    System.out.println(<font color=#004488>"Constructing objects:"</font>);
    Blip3 b3 = <font color=#0000ff>new</font> Blip3(<font color=#004488>"A String "</font>, 47);
    System.out.println(b3);
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(
        <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Saving object:"</font>);
    o.writeObject(b3);
    o.close();
    <font color=#009900>// Now get it back:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Blip3.out"</font>));
    System.out.println(<font color=#004488>"Recovering b3:"</font>);
    b3 = (Blip3)in.readObject();
    System.out.println(b3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fields <B>s</B> and <B>i </B>are
initialized only in the second constructor, but not in the default constructor.
This means that if you don&#8217;t initialize <B>s</B> and <B>i </B>in
<B>readExternal(&#160;)</B>, it will be <B>null</B> (since the storage for the
object gets wiped to zero in the first step of object creation). If you comment
out the two lines of code following the phrases &#8220;You must do this&#8221;
and run the program, you&#8217;ll see that when the object is recovered,
<B>s</B> is <B>null</B> and <B>i</B> is zero.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I122' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I123>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are inheriting from an
<B>Externalizable</B> object, you&#8217;ll typically call the base-class
versions of <B>writeExternal(&#160;) </B>and <B>readExternal(&#160;)</B> to
provide proper storage and retrieval of the base-class components.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I123' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I124>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So to make things work correctly you must
not only write the important data from the object during the
<B>writeExternal(&#160;) </B>method (there is no default behavior that writes
any of the member objects for an <B>Externalizable</B> object), but you must
also recover that data in the <B>readExternal(&#160;)</B> method. This can be a
bit confusing at first because the default construction behavior for an
<B>Externalizable</B> object can make it seem like some kind of storage and
retrieval takes place automatically. It does not.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I124' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I125>
</FONT><BR></P></DIV>
<A NAME="Heading391"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
The transient keyword</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you&#8217;re controlling
serialization, there might be a particular subobject that you don&#8217;t want
Java&#8217;s serialization mechanism to automatically save and restore. This is
commonly the case if that subobject represents sensitive information that you
don&#8217;t want to serialize, such as a password. Even if that information is
<B>private </B>in the object, once it&#8217;s serialized it&#8217;s possible for
someone to access it by reading a file or intercepting a network transmission.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I125' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I126>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One way to prevent sensitive parts of
your object from being serialized is to implement your class as
<B>Externalizable</B>, as shown previously. Then nothing is automatically
serialized and you can explicitly serialize only the necessary parts inside
<B>writeExternal(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I126' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I127>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re working with a
<B>Serializable </B>object, however, all serialization happens automatically. To
control this, you can turn off serialization on a field-by-field basis using the
<A NAME="Index1420"></A><A NAME="Index1421"></A><A NAME="Index1422"></A><B>transient</B>
keyword, which says &#8220;Don&#8217;t bother saving or restoring
this&#8212;I&#8217;ll take care of it.&#8221;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I127' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I128>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For example, consider a <B>Login
</B>object that keeps information about a particular login session. Suppose
that, once you verify the login, you want to store the data, but without the
password. The easiest way to do this is by implementing
<A NAME="Index1423"></A><B>Serializable</B> and marking the <B>password</B>
field as <B>transient</B>. Here&#8217;s what it looks like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:Logon.java</font>
<font color=#009900>// Demonstrates the "transient" keyword.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Logon <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>private</font> Date date = <font color=#0000ff>new</font> Date();
  <font color=#0000ff>private</font> String username;
  <font color=#0000ff>private</font> <font color=#0000ff>transient</font> String password;
  Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  <font color=#0000ff>public</font> String toString() {
    String pwd =
      (password == <font color=#0000ff>null</font>) ? <font color=#004488>"(n</font><font color=#004488>/a)"</font> : password;
    <font color=#0000ff>return</font> <font color=#004488>"logon info: \n   "</font> +
      <font color=#004488>"username: "</font> + username +
      <font color=#004488>"\n   date: "</font> + date +
      <font color=#004488>"\n   password: "</font> + pwd;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    Logon a = <font color=#0000ff>new</font> Logon(<font color=#004488>"Hulk"</font>, <font color=#004488>"myLittlePony"</font>);
    System.out.println( <font color=#004488>"logon a = "</font> + a);
      ObjectOutputStream o =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"Logon.out"</font>));
    o.writeObject(a);
    o.close();
    <font color=#009900>// Delay:</font>
    <font color=#0000ff>int</font> seconds = 5;
    <font color=#0000ff>long</font> t = System.currentTimeMillis()
           + seconds * 1000;
    <font color=#0000ff>while</font>(System.currentTimeMillis() &lt; t)
      ;
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> FileInputStream(<font color=#004488>"Logon.out"</font>));
    System.out.println(
      <font color=#004488>"Recovering object at "</font> + <font color=#0000ff>new</font> Date());
    a = (Logon)in.readObject();
    System.out.println( <font color=#004488>"logon a = "</font> + a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the <B>date</B> and
<B>username</B> fields are ordinary (not <B>transient</B>), and thus are
automatically serialized. However, the <B>password</B> is <B>transient</B>, and
so is not stored to disk; also the serialization mechanism makes no attempt to
recover it. The output is:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I128' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I129>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: myLittlePony
Recovering object at Sun Mar 23 18:25:59 PST 1997
logon a = logon info:
   username: Hulk
   date: Sun Mar 23 18:25:53 PST 1997
   password: (n/a)</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the object is recovered, the
<B>password</B> field is <B>null</B>. Note that <B>toString(&#160;)</B> must
check for a <B>null</B> value of <B>password </B>because if you try to assemble
a <B>String</B> object using the overloaded &#8216;<B>+</B>&#8217; operator, and
that operator encounters a <B>null </B>reference, you&#8217;ll get a
<B>NullPointerException.</B> (Newer versions of Java might contain code to avoid
this problem.) 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I129' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I130>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also see that the <B>date</B>
field is stored to and recovered from disk and not generated anew.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I130' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I131>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since <B>Externalizable</B> objects do
not store any of their fields by default, the <B>transient</B> keyword is for
use with <B>Serializable</B> objects only.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I131' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I132>
</FONT><BR></P></DIV>
<A NAME="Heading392"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
An alternative to Externalizable</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;re not keen on implementing
the <A NAME="Index1424"></A><B>Externalizable </B>interface, there&#8217;s
another approach. You can implement the <B>Serializable</B> interface and <I>add
</I>(notice I say &#8220;add&#8221; and not &#8220;override&#8221; or
&#8220;implement&#8221;) methods called
<A NAME="Index1425"></A><A NAME="Index1426"></A><B>writeObject(&#160;)</B> and
<A NAME="Index1427"></A><A NAME="Index1428"></A><B>readObject(&#160;)</B> that
will automatically be called when the object is serialized and deserialized,
respectively. That is, if you provide these two methods they will be used
instead of the default serialization.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I132' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I133>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The methods must have these exact
signatures:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  writeObject(ObjectOutputStream stream)
    <font color=#0000ff>throws</font> IOException;

<font color=#0000ff>private</font> <font color=#0000ff>void</font> 
  readObject(ObjectInputStream stream)
    <font color=#0000ff>throws</font> IOException, ClassNotFoundException</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From a design standpoint, things get
really weird here. First of all, you might think that because these methods are
not part of a base class or the <B>Serializable</B> interface, they ought to be
defined in their own interface(s). But notice that they are defined as
<B>private</B>, which means they are to be called only by other members of this
class. However, you don&#8217;t actually call them from other members of this
class, but instead the <B>writeObject(&#160;)</B> and <B>readObject(&#160;)</B>
methods of the <B>ObjectOutputStream</B> and <B>ObjectInputStream</B> objects
call your object&#8217;s <B>writeObject(&#160;)</B> and
<B>readObject(&#160;)</B> methods. (Notice my tremendous restraint in not
launching into a long diatribe about using the same method names here. In a
word: confusing.) You might wonder how the <B>ObjectOutputStream</B> and
<B>ObjectInputStream</B> objects have access to <B>private</B> methods of your
class. We can only assume that this is part of the serialization magic.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I133' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I134>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In any event, anything defined in an
<B>interface</B> is automatically <B>public</B> so if <B>writeObject(&#160;)</B>
and <B>readObject(&#160;)</B> must be <B>private</B>, then they can&#8217;t be
part of an <B>interface</B>. Since you must follow the signatures exactly, the
effect is the same as if you&#8217;re implementing an <B>interface</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I134' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I135>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It would appear that when you call
<B>ObjectOutputStream.writeObject(&#160;)</B>, the <B>Serializable</B> object
that you pass it to is interrogated (using reflection, no doubt) to see if it
implements its own <B>writeObject(&#160;)</B>. If so, the normal serialization
process is skipped and the <B>writeObject(&#160;)</B> is called. The same sort
of situation exists for <B>readObject(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I135' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I136>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one other twist. Inside
your <B>writeObject(&#160;)</B>, you can choose to perform the default
<B>writeObject(&#160;)</B> action by calling <B>defaultWriteObject(&#160;)</B>.
Likewise, inside <B>readObject(&#160;)</B> you can call
<B>defaultReadObject(&#160;)</B>. Here is a simple example that demonstrates how
you can control the storage and retrieval of a <B>Serializable</B>
object:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:SerialCtl.java</font>
<font color=#009900>// Controlling serialization by adding your own</font>
<font color=#009900>// writeObject() and readObject() methods.</font>
<font color=#0000ff>import</font> java.io.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SerialCtl <font color=#0000ff>implements</font> Serializable {
  String a;
  <font color=#0000ff>transient</font> String b;
  <font color=#0000ff>public</font> SerialCtl(String aa, String bb) {
    a = <font color=#004488>"Not Transient: "</font> + aa;
    b = <font color=#004488>"Transient: "</font> + bb;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> a + <font color=#004488>"\n"</font> + b;
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    writeObject(ObjectOutputStream stream)
      <font color=#0000ff>throws</font> IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>void</font> 
    readObject(ObjectInputStream stream)
      <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    SerialCtl sc = 
      <font color=#0000ff>new</font> SerialCtl(<font color=#004488>"Test1"</font>, <font color=#004488>"Test2"</font>);
    System.out.println(<font color=#004488>"Before:\n"</font> + sc);
    ByteArrayOutputStream buf = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o =
      <font color=#0000ff>new</font> ObjectOutputStream(buf);
    o.writeObject(sc);
    <font color=#009900>// Now get it back:</font>
    ObjectInputStream in =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf.toByteArray()));
    SerialCtl sc2 = (SerialCtl)in.readObject();
    System.out.println(<font color=#004488>"After:\n"</font> + sc2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this example, one <B>String</B> field
is ordinary and the other is <B>transient</B>, to prove that the
non-<B>transient</B> field is saved by the
<A NAME="Index1429"></A><A NAME="Index1430"></A><B>defaultWriteObject(&#160;)</B>
method and the <B>transient</B> field is saved and restored explicitly. The
fields are initialized inside the constructor rather than at the point of
definition to prove that they are not being initialized by some automatic
mechanism during deserialization.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I136' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I137>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are going to use the default
mechanism to write the non-<B>transient</B> parts of your object, you must call
<B>defaultWriteObject(&#160;)</B> as the first operation in
<B>writeObject(&#160;)</B> and
<A NAME="Index1431"></A><A NAME="Index1432"></A><B>defaultReadObject(&#160;)</B>
as the first operation in <B>readObject(&#160;)</B>. These are strange method
calls. It would appear, for example, that you are calling
<B>defaultWriteObject(&#160;)</B> for an <B>ObjectOutputStream</B> and passing
it no arguments, and yet it somehow turns around and knows the reference to your
object and how to write all the non-<B>transient</B> parts. Spooky.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I137' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I138>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The storage and retrieval of the
<B>transient</B> objects uses more familiar code. And yet, think about what
happens here. In <B>main(&#160;)</B>, a <B>SerialCtl</B> object is created, and
then it&#8217;s serialized to an <B>ObjectOutputStream.</B> (Notice in this case
that a buffer is used instead of a file&#8212;it&#8217;s all the same to the
<B>ObjectOutputStream</B>.) The serialization occurs in the
line:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>o.writeObject(sc);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>writeObject(&#160;)</B> method
must be examining <B>sc</B> to see if it has its own <B>writeObject(&#160;)</B>
method. (Not by checking the interface&#8212;there isn&#8217;t one&#8212;or the
class type, but by actually hunting for the method using reflection.) If it
does, it uses that. A similar approach holds true for <B>readObject(&#160;)</B>.
Perhaps this was the only practical way that they could solve the problem, but
it&#8217;s certainly strange.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I138' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I139>
</FONT><BR></P></DIV>
<A NAME="Heading393"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Versioning<BR><A NAME="Index1433"></A><A NAME="Index1434"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible that you might want
to change the version of a serializable class (objects of the original class
might be stored in a database, for example). This is supported but you&#8217;ll
probably do it only in special cases, and it requires an extra depth of
understanding that we will not attempt to achieve here. The JDK HTML documents
downloadable from <I>java.sun.com</I> cover this topic quite thoroughly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I139' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I140>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You will also notice in the JDK HTML
documentation many comments that begin with:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B><I>Warning:</I></B><I> Serialized
objects of this class will not be compatible with future Swing releases. The
current serialization support is appropriate for short term storage or RMI
between applications. ...</I></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is because the versioning mechanism
is too simple to work reliably in all situations, especially with JavaBeans.
They&#8217;re working on a correction for the design, and that&#8217;s what the
warning is about.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I140' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I141>
</FONT><A NAME="_Toc481064765"></A><BR></P></DIV>
<A NAME="Heading394"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using persistence<BR><A NAME="Index1435"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s quite appealing to use
<A NAME="Index1436"></A>serialization technology to store some of the state of
your program so that you can easily restore the program to the current state
later. But before you can do this, some questions must be answered. What happens
if you serialize two objects that both have a reference to a third object? When
you restore those two objects from their serialized state, do you get only one
occurrence of the third object? What if you serialize your two objects to
separate files and deserialize them in different parts of your code?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I141' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I142>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that shows the
problem:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:MyWorld.java</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> House <font color=#0000ff>implements</font> Serializable {}

<font color=#0000ff>class</font> Animal <font color=#0000ff>implements</font> Serializable {
  String name;
  House preferredHouse;
  Animal(String nm, House h) { 
    name = nm; 
    preferredHouse = h;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> name + <font color=#004488>"["</font> + <font color=#0000ff>super</font>.toString() + 
      <font color=#004488>"], "</font> + preferredHouse + <font color=#004488>"\n"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MyWorld {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args)
  <font color=#0000ff>throws</font> IOException, ClassNotFoundException {
    House house = <font color=#0000ff>new</font> House();
    ArrayList  animals = <font color=#0000ff>new</font> ArrayList();
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Bosco the dog"</font>, house));
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Ralph the hamster"</font>, house));
    animals.add(
      <font color=#0000ff>new</font> Animal(<font color=#004488>"Fronk the cat"</font>, house));
    System.out.println(<font color=#004488>"animals: "</font> + animals);

    ByteArrayOutputStream buf1 = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o1 =
      <font color=#0000ff>new</font> ObjectOutputStream(buf1);
    o1.writeObject(animals);
    o1.writeObject(animals); <font color=#009900>// Write a 2nd set</font>
    <font color=#009900>// Write to a different stream:</font>
    ByteArrayOutputStream buf2 = 
      <font color=#0000ff>new</font> ByteArrayOutputStream();
    ObjectOutputStream o2 =
      <font color=#0000ff>new</font> ObjectOutputStream(buf2);
    o2.writeObject(animals);
    <font color=#009900>// Now get them back:</font>
    ObjectInputStream in1 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf1.toByteArray()));
    ObjectInputStream in2 =
      <font color=#0000ff>new</font> ObjectInputStream(
        <font color=#0000ff>new</font> ByteArrayInputStream(
          buf2.toByteArray()));
    ArrayList animals1 = 
      (ArrayList)in1.readObject();
    ArrayList animals2 = 
      (ArrayList)in1.readObject();
    ArrayList animals3 = 
      (ArrayList)in2.readObject();
    System.out.println(<font color=#004488>"animals1: "</font> + animals1);
    System.out.println(<font color=#004488>"animals2: "</font> + animals2);
    System.out.println(<font color=#004488>"animals3: "</font> + animals3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing that&#8217;s interesting here
is that it&#8217;s possible to use object serialization to and from a byte array
as a way of doing a &#8220;deep copy&#8221; of any object that&#8217;s
<B>Serializable.</B> (A deep copy means that you&#8217;re duplicating the entire
web of objects, rather than just the basic object and its references.) Copying
is covered in depth in Appendix A.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I142' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I143>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Animal</B> objects contain fields of
type <B>House</B>. In <B>main(&#160;)</B>, an <B>ArrayList</B> of these
<B>Animal</B>s is created and it is serialized twice to one stream and then
again to a separate stream. When these are deserialized and printed, you see the
following results for one run (the objects will be in different memory locations
each run):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>animals: [Bosco the dog[Animal@1cc76c], House@1cc769
, Ralph the hamster[Animal@1cc76d], House@1cc769
, Fronk the cat[Animal@1cc76e], House@1cc769
]
animals1: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals2: [Bosco the dog[Animal@1cca0c], House@1cca16
, Ralph the hamster[Animal@1cca17], House@1cca16
, Fronk the cat[Animal@1cca1b], House@1cca16
]
animals3: [Bosco the dog[Animal@1cca52], House@1cca5c
, Ralph the hamster[Animal@1cca5d], House@1cca5c
, Fronk the cat[Animal@1cca61], House@1cca5c
]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course you expect that the
deserialized objects have different addresses from their originals. But notice
that in <B>animals1</B> and <B>animals2</B> the same addresses appear, including
the references to the <B>House </B>object that both share. On the other hand,
when <B>animals3 </B>is recovered the system has no way of knowing that the
objects in this other stream are aliases of the objects in the first stream, so
it makes a completely different web of objects.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I143' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I144>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As long as you&#8217;re serializing
everything to a single stream, you&#8217;ll be able to recover the same web of
objects that you wrote, with no accidental duplication of objects. Of course,
you can change the state of your objects in between the time you write the first
and the last, but that&#8217;s your responsibility&#8212;the objects will be
written in whatever state they are in (and with whatever connections they have
to other objects) at the time you serialize them.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I144' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I145>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The safest thing to do if you want to
save the state of a system is to serialize as an &#8220;atomic&#8221; operation.
If you serialize some things, do some other work, and serialize some more, etc.,
then you will not be storing the system safely. Instead, put all the objects
that comprise the state of your system in a single container and simply write
that container out in one operation. Then you can restore it with a single
method call as well. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I145' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I146>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example is an imaginary
computer-aided design (CAD) system that demonstrates the approach. In addition,
it throws in the issue of <B>static</B> fields&#8212;if you look at the
documentation you&#8217;ll see that <B>Class</B> is <B>Serializable</B>, so it
should be easy to store the <B>static</B> fields by simply serializing the
<A NAME="Index1437"></A><A NAME="Index1438"></A><B>Class</B> object. That seems
like a sensible approach, anyway.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:CADState.java</font>
<font color=#009900>// Saving and restoring the state of a </font>
<font color=#009900>// pretend CAD system.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>abstract</font> <font color=#0000ff>class</font> Shape <font color=#0000ff>implements</font> Serializable {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> 
    RED = 1, BLUE = 2, GREEN = 3;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> xPos, yPos, dimension;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> counter = 0;
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor);
  <font color=#0000ff>abstract</font> <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor();
  <font color=#0000ff>public</font> Shape(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    xPos = xVal;
    yPos = yVal;
    dimension = dim;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> getClass() + 
      <font color=#004488>" color["</font> + getColor() +
      <font color=#004488>"] xPos["</font> + xPos +
      <font color=#004488>"] yPos["</font> + yPos +
      <font color=#004488>"] dim["</font> + dimension + <font color=#004488>"]\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Shape randomFactory() {
    <font color=#0000ff>int</font> xVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> yVal = r.nextInt() % 100;
    <font color=#0000ff>int</font> dim = r.nextInt() % 100;
    <font color=#0000ff>switch</font>(counter++ % 3) {
      <font color=#0000ff>default</font>: 
      <font color=#0000ff>case</font> 0: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Circle(xVal, yVal, dim);
      <font color=#0000ff>case</font> 1: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Square(xVal, yVal, dim);
      <font color=#0000ff>case</font> 2: <font color=#0000ff>return</font> <font color=#0000ff>new</font> Line(xVal, yVal, dim);
    }
  }
}

<font color=#0000ff>class</font> Circle <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> Circle(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Square <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color;
  <font color=#0000ff>public</font> Square(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
    color = RED;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>class</font> Line <font color=#0000ff>extends</font> Shape {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> color = RED;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  serializeStaticState(ObjectOutputStream os)
      <font color=#0000ff>throws</font> IOException {
    os.writeInt(color);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  deserializeStaticState(ObjectInputStream os)
      <font color=#0000ff>throws</font> IOException {
    color = os.readInt();
  }
  <font color=#0000ff>public</font> Line(<font color=#0000ff>int</font> xVal, <font color=#0000ff>int</font> yVal, <font color=#0000ff>int</font> dim) {
    <font color=#0000ff>super</font>(xVal, yVal, dim);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> setColor(<font color=#0000ff>int</font> newColor) { 
    color = newColor;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getColor() { 
    <font color=#0000ff>return</font> color;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CADState {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> Exception {
    ArrayList shapeTypes, shapes;
    <font color=#0000ff>if</font>(args.length == 0) {
      shapeTypes = <font color=#0000ff>new</font> ArrayList();
      shapes = <font color=#0000ff>new</font> ArrayList();
      <font color=#009900>// Add references to the class objects:</font>
      shapeTypes.add(Circle.<font color=#0000ff>class</font>);
      shapeTypes.add(Square.<font color=#0000ff>class</font>);
      shapeTypes.add(Line.<font color=#0000ff>class</font>);
      <font color=#009900>// Make some shapes:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        shapes.add(Shape.randomFactory());
      <font color=#009900>// Set all the static colors to GREEN:</font>
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
        ((Shape)shapes.get(i))
          .setColor(Shape.GREEN);
      <font color=#009900>// Save the state vector:</font>
      ObjectOutputStream out =
        <font color=#0000ff>new</font> ObjectOutputStream(
          <font color=#0000ff>new</font> FileOutputStream(<font color=#004488>"CADState.out"</font>));
      out.writeObject(shapeTypes);
      Line.serializeStaticState(out);
      out.writeObject(shapes);
    } <font color=#0000ff>else</font> { <font color=#009900>// There's a command-line argument</font>
      ObjectInputStream in =
        <font color=#0000ff>new</font> ObjectInputStream(
          <font color=#0000ff>new</font> FileInputStream(args[0]));
      <font color=#009900>// Read in the same order they were written:</font>
      shapeTypes = (ArrayList)in.readObject();
      Line.deserializeStaticState(in);
      shapes = (ArrayList)in.readObject();
    }
    <font color=#009900>// Display the shapes:</font>
    System.out.println(shapes);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Shape</B> class <B>implements
<A NAME="Index1439"></A>Serializable</B>, so anything that is inherited from
<B>Shape</B> is automatically <B>Serializable</B> as well. Each <B>Shape</B>
contains data, and each derived <B>Shape</B> class contains a <B>static</B>
field that determines the color of all of those types of <B>Shape</B>s. (Placing
a <B>static</B> field in the base class would result in only one field, since
<B>static</B> fields are not duplicated in derived classes.) Methods in the base
class can be overridden to set the color for the various types (<B>static</B>
methods are not dynamically bound, so these are normal methods). The
<B>randomFactory(&#160;)</B> method creates a different <B>Shape</B> each time
you call it, using random values for the <B>Shape</B> data.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I146' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I147>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Circle</B> and <B>Square</B> are
straightforward extensions of <B>Shape</B>; the only difference is that
<B>Circle</B> initializes <B>color</B> at the point of definition and
<B>Square</B> initializes it in the constructor. We&#8217;ll leave the
discussion of <B>Line</B> for later.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I147' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I148>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, one
<B>ArrayList</B> is used to hold the <B>Class</B> objects and the other to hold
the shapes. If you don&#8217;t provide a command line argument the
<B>shapeTypes</B> <B>ArrayList</B> is created and the <B>Class</B> objects are
added, and then the <B>shapes</B> <B>ArrayList</B> is created and <B>Shape</B>
objects are added. Next, all the <B>static</B> <B>color</B> values are set to
<B>GREEN</B>, and everything is serialized to the file <B>CADState.out</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I148' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I149>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you provide a command line argument
(presumably <B>CADState.out</B>), that file is opened and used to restore the
state of the program. In both situations, the resulting <B>ArrayList</B> of
<B>Shape</B>s is printed. The results from one run are:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>&gt;java CADState
[<font color=#0000ff>class</font> Circle color[3] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[3] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[3] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[3] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[3] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[3] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[3] xPos[17] yPos[90] dim[-76]
]

&gt;java CADState CADState.out
[<font color=#0000ff>class</font> Circle color[1] xPos[-51] yPos[-99] dim[38]
, <font color=#0000ff>class</font> Square color[0] xPos[2] yPos[61] dim[-46]
, <font color=#0000ff>class</font> Line color[3] xPos[51] yPos[73] dim[64]
, <font color=#0000ff>class</font> Circle color[1] xPos[-70] yPos[1] dim[16]
, <font color=#0000ff>class</font> Square color[0] xPos[3] yPos[94] dim[-36]
, <font color=#0000ff>class</font> Line color[3] xPos[-84] yPos[-21] dim[-35]
, <font color=#0000ff>class</font> Circle color[1] xPos[-75] yPos[-43] dim[22]
, <font color=#0000ff>class</font> Square color[0] xPos[81] yPos[30] dim[-45]
, <font color=#0000ff>class</font> Line color[3] xPos[-29] yPos[92] dim[17]
, <font color=#0000ff>class</font> Circle color[1] xPos[17] yPos[90] dim[-76]
]</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the values of
<B>xPos</B>, <B>yPos,</B> and <B>dim</B> were all stored and recovered
successfully, but there&#8217;s something wrong with the retrieval of the
<B>static</B> information. It&#8217;s all &#8220;3&#8221; going in, but it
doesn&#8217;t come out that way. <B>Circle</B>s have a value of 1 (<B>RED</B>,
which is the definition), and <B>Square</B>s have a value of 0 (remember, they
are initialized in the constructor). It&#8217;s as if the <B>static</B>s
didn&#8217;t get serialized at all! That&#8217;s right&#8212;even though class
<B>Class</B> is <B>Serializable</B>, it doesn&#8217;t do what you expect. So if
you want to serialize <B>statics</B>, you must do it yourself.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I149' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I150>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is what the
<B>serializeStaticState(&#160;) </B>and <B>deserializeStaticState(&#160;)</B>
<B>static </B>methods in <B>Line</B> are for. You can see that they are
explicitly called as part of the storage and retrieval process. (Note that the
order of writing to the serialize file and reading back from it must be
maintained.) Thus to make <B>CADState.java</B> run correctly you must:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I150' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I151>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add a
<B>serializeStaticState(&#160;)</B> and <B>deserializeStaticState(&#160;)</B> to
the shapes.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Remove
the <B>ArrayList</B> <B>shapeTypes</B> and all code related to
it.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add calls to the
new serialize and deserialize static methods in the shapes.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I151' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I152>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another
issue you might have to think about is security, since serialization also saves
<B>private</B> data. If you have a security issue, those fields should be marked
as <B>transient</B>. But then you have to design a secure way to store that
information so that when you do a restore you can reset those <B>private</B>
variables. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I152' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I153>
</FONT><A NAME="_Toc481064766"></A><BR></P></DIV>
<A NAME="Heading395"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Tokenizing input<BR><A NAME="Index1440"></A><A NAME="Index1441"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"> <I>Tokenizing </I>is the process of
breaking a sequence of characters into a sequence of &#8220;tokens,&#8221; which
are bits of text delimited by whatever you choose. For example, your tokens
could be words, and then they would be delimited by white space and punctuation.
There are two classes provided in the standard Java library that can be used for
tokenization: <B>StreamTokenizer</B> and <B>StringTokenizer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I153' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I154>
</FONT><A NAME="_Toc375545398"></A><A NAME="_Toc481064767"></A><BR></P></DIV>
<A NAME="Heading396"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
StreamTokenizer<BR><A NAME="Index1442"></A><A NAME="Index1443"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although <B>StreamTokenizer</B> is not
derived from <B>InputStream</B> or <B>OutputStream</B>, it works only with
<B>InputStream</B> objects, so it rightfully belongs in the I/O portion of the
library. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I154' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I155>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Consider a program to count the
occurrence of words in a text file:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:WordCount.java</font>
<font color=#009900>// Counts words from a file, outputs</font>
<font color=#009900>// results in sorted form.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i = 1;
  <font color=#0000ff>int</font> read() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>void</font> increment() { i++; }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WordCount {
  <font color=#0000ff>private</font> FileReader file;
  <font color=#0000ff>private</font> StreamTokenizer st;
  <font color=#009900>// A TreeMap keeps keys in sorted order:</font>
  <font color=#0000ff>private</font> TreeMap counts = <font color=#0000ff>new</font> TreeMap();
  WordCount(String filename)
    <font color=#0000ff>throws</font> FileNotFoundException {
    <font color=#0000ff>try</font> {
      file = <font color=#0000ff>new</font> FileReader(filename);
      st = <font color=#0000ff>new</font> StreamTokenizer(
        <font color=#0000ff>new</font> BufferedReader(file));
      st.ordinaryChar('.');
      st.ordinaryChar('-');
    } <font color=#0000ff>catch</font>(FileNotFoundException e) {
      System.err.println(
        <font color=#004488>"Could not open "</font> + filename);
      <font color=#0000ff>throw</font> e;
    }
  }
  <font color=#0000ff>void</font> cleanup() {
    <font color=#0000ff>try</font> {
      file.close();
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"file.close() unsuccessful"</font>);
    }
  }
  <font color=#0000ff>void</font> countWords() {
    <font color=#0000ff>try</font> {
      <font color=#0000ff>while</font>(st.nextToken() !=
        StreamTokenizer.TT_EOF) {
        String s;
        <font color=#0000ff>switch</font>(st.ttype) {
          <font color=#0000ff>case</font> StreamTokenizer.TT_EOL:
            s = <font color=#0000ff>new</font> String(<font color=#004488>"EOL"</font>);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_NUMBER:
            s = Double.toString(st.nval);
            <font color=#0000ff>break</font>;
          <font color=#0000ff>case</font> StreamTokenizer.TT_WORD:
            s = st.sval; <font color=#009900>// Already a String</font>
            <font color=#0000ff>break</font>;
          <font color=#0000ff>default</font>: <font color=#009900>// single character in ttype</font>
            s = String.valueOf((<font color=#0000ff>char</font>)st.ttype);
        }
        <font color=#0000ff>if</font>(counts.containsKey(s))
          ((Counter)counts.get(s)).increment();
        <font color=#0000ff>else</font>
          counts.put(s, <font color=#0000ff>new</font> Counter());
      }
    } <font color=#0000ff>catch</font>(IOException e) {
      System.err.println(
        <font color=#004488>"st.nextToken() unsuccessful"</font>);
    }
  }
  Collection values() {
    <font color=#0000ff>return</font> counts.values();
  }
  Set keySet() { <font color=#0000ff>return</font> counts.keySet(); }
  Counter getCounter(String s) {
    <font color=#0000ff>return</font> (Counter)counts.get(s);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> FileNotFoundException {
    WordCount wc =
      <font color=#0000ff>new</font> WordCount(args[0]);
    wc.countWords();
    Iterator keys = wc.keySet().iterator();
    <font color=#0000ff>while</font>(keys.hasNext()) {
      String key = (String)keys.next();
      System.out.println(key + <font color=#004488>": "</font>
               + wc.getCounter(key).read());
    }
    wc.cleanup();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Presenting the words in sorted form is
easy to do by storing the data in a <B>TreeMap</B>, which automatically
organizes<B> </B>its keys in sorted order (see Chapter 9). When you get a set of
keys using <B>keySet(&#160;)</B>, they will also be in sorted order.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I155' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I156>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To open the file, a <B>FileReader</B> is
used, and to turn the file into words a <B>StreamTokenizer</B> is created from
the <B>FileReader</B> wrapped in a <B>BufferedReader</B>. In
<B>StreamTokenizer</B>, there is a default list of separators, and you can add
more with a set of methods. Here, <B>ordinaryChar(&#160;)</B> is used to say
&#8220;This character has no significance that I&#8217;m interested in,&#8221;
so the parser doesn&#8217;t include it as part of any of the words that it
creates. For example, saying <B>st.ordinaryChar('.')</B> means that periods will
not be included as parts of the words that are parsed. You can find more
information in the JDK HTML documentation from <I>java.sun.com</I>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I156' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I157>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>countWords(&#160;)</B>, the tokens
are pulled one at a time from the stream, and the <B>ttype</B> information is
used to determine what to do with each token, since a token can be an
end-of-line, a number, a string, or a single character.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I157' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I158>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a token is found, the
<A NAME="Index1444"></A><B>TreeMap counts</B> is queried to see if it already
contains the token as a key. If it does, the corresponding <B>Counter</B> object
is incremented to indicate that another instance of this word has been found. If
not, a new <B>Counter</B> is created&#8212;since the <B>Counter</B> constructor
initializes its value to one, this also acts to count the word.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I158' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I159>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>WordCount</B> is not a type of
<B>TreeMap</B>, so it wasn&#8217;t inherited. It performs a specific type of
functionality, so even though the <B>keys(&#160;)</B> and <B>values(&#160;)</B>
methods must be reexposed, that still doesn&#8217;t mean that
<A NAME="Index1445"></A><A NAME="Index1446"></A>inheritance should be used since
a number of <B>TreeMap</B> methods are inappropriate here. In addition, other
methods like <B>getCounter(&#160;)</B>, which get the <B>Counter</B> for a
particular <B>String</B>, and <B>sortedKeys(&#160;)</B>, which produces an
<B>Iterator</B>, finish the change in the shape of <B>WordCount</B>&#8217;s
interface. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I159' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I160>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B> you can see the
use of a <B>WordCount</B> to open and count the words in a file&#8212;it just
takes two lines of code. Then an Iterator to a sorted list of keys (words) is
extracted, and this is used to pull out each key and associated <B>Count</B>.
The call to <B>cleanup(&#160;)</B> is necessary to ensure that the file is
closed.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I160' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I161>
</FONT><A NAME="_Toc375545399"></A><A NAME="_Toc481064768"></A><BR></P></DIV>
<A NAME="Heading397"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
StringTokenizer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although it isn&#8217;t part of the I/O
library, the <B>StringTokenizer</B> has sufficiently similar functionality to
<B>StreamTokenizer</B> that it will be described here.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I161' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I162>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1447"></A><B>StringTokenizer</B> returns the tokens within a
string one at a time. These tokens are consecutive characters delimited by tabs,
spaces, and newlines. Thus, the tokens of the string &#8220;Where is my
cat?&#8221; are &#8220;Where&#8221;, &#8220;is&#8221;, &#8220;my&#8221;, and
&#8220;cat?&#8221; Like the <B>StreamTokenizer</B>,<B> </B>you can tell the
<B>StringTokenizer</B> to break up the input in any way that you want, but with
<B>StringTokenizer </B>you do this by passing a second argument to the
constructor, which is a <B>String </B>of the delimiters you wish to use. In
general, if you need more sophistication, use a <B>StreamTokenizer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I162' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I163>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You ask a <B>StringTokenizer</B> object
for the next token in the string using the <B>nextToken(&#160;)</B> method,
which either returns the token or an empty string to indicate that no tokens
remain.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I163' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I164>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, the following program
performs a limited analysis of a sentence, looking for key phrase sequences to
indicate whether happiness or sadness is implied. </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:AnalyzeSentence.java</font>
<font color=#009900>// Look for particular sequences in sentences.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AnalyzeSentence {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    analyze(<font color=#004488>"I am happy about this"</font>);
    analyze(<font color=#004488>"I am not happy about this"</font>);
    analyze(<font color=#004488>"I am not! I am happy"</font>);
    analyze(<font color=#004488>"I am sad about this"</font>);
    analyze(<font color=#004488>"I am not sad about this"</font>);
    analyze(<font color=#004488>"I am not! I am sad"</font>);
    analyze(<font color=#004488>"Are you happy about this?"</font>);
    analyze(<font color=#004488>"Are you sad about this?"</font>);
    analyze(<font color=#004488>"It's you! I am happy"</font>);
    analyze(<font color=#004488>"It's you! I am sad"</font>);
  }
  <font color=#0000ff>static</font> StringTokenizer st;
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> analyze(String s) {
    prt(<font color=#004488>"\nnew sentence &gt;&gt; "</font> + s);
    <font color=#0000ff>boolean</font> sad = <font color=#0000ff>false</font>;
    st = <font color=#0000ff>new</font> StringTokenizer(s);
    <font color=#0000ff>while</font> (st.hasMoreTokens()) {
      String token = next();
      <font color=#009900>// Look until you find one of the</font>
      <font color=#009900>// two starting tokens:</font>
      <font color=#0000ff>if</font>(!token.equals(<font color=#004488>"I"</font>) &amp;&amp;
         !token.equals(<font color=#004488>"Are"</font>))
        <font color=#0000ff>continue</font>; <font color=#009900>// Top of while loop</font>
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"I"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"am"</font>)) <font color=#009900>// Must be after I</font>
          <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
        <font color=#0000ff>else</font> {
          String tk3 = next();
          <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>)) {
            sad = <font color=#0000ff>true</font>;
            <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
          }
          <font color=#0000ff>if</font> (tk3.equals(<font color=#004488>"not"</font>)) {
            String tk4 = next();
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"sad"</font>))
              <font color=#0000ff>break</font>; <font color=#009900>// Leave sad false</font>
            <font color=#0000ff>if</font>(tk4.equals(<font color=#004488>"happy"</font>)) {
              sad = <font color=#0000ff>true</font>;
              <font color=#0000ff>break</font>;
            }
          }
        }
      }
      <font color=#0000ff>if</font>(token.equals(<font color=#004488>"Are"</font>)) {
        String tk2 = next();
        <font color=#0000ff>if</font>(!tk2.equals(<font color=#004488>"you"</font>))
          <font color=#0000ff>break</font>; <font color=#009900>// Must be after Are</font>
        String tk3 = next();
        <font color=#0000ff>if</font>(tk3.equals(<font color=#004488>"sad"</font>))
          sad = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
      }
    }
    <font color=#0000ff>if</font>(sad) prt(<font color=#004488>"Sad detected"</font>);
  }
  <font color=#0000ff>static</font> String next() {
    <font color=#0000ff>if</font>(st.hasMoreTokens()) {
      String s = st.nextToken();
      prt(s);
      <font color=#0000ff>return</font> s;
    } 
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>""</font>;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> prt(String s) {
    System.out.println(s);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For each string being analyzed, a
<B>while</B> loop is entered and tokens are pulled off the string. Notice the
first <B>if</B> statement, which says to <B>continue</B> (go back to the
beginning of the loop and start again) if the token is neither an
&#8220;I&#8221; nor an &#8220;Are.&#8221; </FONT><FONT FACE="Georgia">This means
that it will get tokens until an &#8220;I&#8221; or an &#8220;Are&#8221; is
found. You might think to use the <B>==</B> instead of the
<A NAME="Index1448"></A><A NAME="Index1449"></A><B>equals(&#160;)</B> method,
but that won&#8217;t work correctly, since <B>==</B> compares reference values
while <B>equals(&#160;)</B> compares contents.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I164' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I165>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The logic of the rest of the
<B>analyze(&#160;)</B> method is that the pattern that&#8217;s being searched
for is &#8220;I am sad,&#8221; &#8220;I am not happy,&#8221; or &#8220;Are you
sad?&#8221; Without the <B>break</B> statement, the code for this would be even
messier than it is. You should be aware that a typical parser (this is a
primitive example of one) normally has a table of these tokens and a piece of
code that moves through the states in the table as new tokens are read.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I165' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I166>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should think of the
<B>StringTokenizer</B> only as shorthand for a simple and specific kind of
<B>StreamTokenizer</B>. However, if you have a <B>String</B> that you want to
tokenize and <B>StringTokenizer</B> is too limited, all you have to do is turn
it into a stream with <B>StringBufferInputStream</B> and then use that to create
a much more powerful <B>StreamTokenizer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I166' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I167>
</FONT><A NAME="_Toc375545504"></A><A NAME="_Toc481064769"></A><BR></P></DIV>
<A NAME="Heading398"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Checking capitalization style</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this section we&#8217;ll look at a
more complete example of the use of Java I/O, which also uses tokenization.
<A NAME="Index1450"></A><A NAME="Index1451"></A>This project is directly useful
because it performs a style check to make sure that your capitalization conforms
to the Java style as found at <I>java.sun.com/docs/codeconv/index.html</I>. It
opens each <B>.java</B> file in the current directory and extracts all the class
names and identifiers, then shows you if any of them don&#8217;t meet the Java
style. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I167' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I168>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the program to operate correctly, you
must first build a class name repository to hold all the class names in the
standard Java library. You do this by moving into all the source code
subdirectories for the standard Java library and running <B>ClassScanner</B> in
each subdirectory. Provide as arguments the name of the repository file (using
the same path and name each time) and the <B>-a</B> command-line option to
indicate that the class names should be added to the repository.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I168' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I169>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To use the program to check your code,
hand it the path and name of the repository to use. It will check all the
classes and identifiers in the current directory and tell you which ones
don&#8217;t follow the typical Java capitalization style.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I169' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I170>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should be aware that the program
isn&#8217;t perfect; there are a few times when it will point out what it thinks
is a problem but on looking at the code you&#8217;ll see that nothing needs to
be changed. This is a little annoying, but it&#8217;s still much easier than
trying to find all these cases by staring at your code.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c11:ClassScanner.java</font>
<font color=#009900>// Scans all files in directory for classes</font>
<font color=#009900>// and identifiers, to check capitalization.</font>
<font color=#009900>// Assumes properly compiling code listings.</font>
<font color=#009900>// Doesn't do everything right, but is a </font>
<font color=#009900>// useful aid.</font>
<font color=#0000ff>import</font> java.io.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MultiStringMap <font color=#0000ff>extends</font> HashMap {
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(String key, String value) {
    <font color=#0000ff>if</font>(!containsKey(key))
      put(key, <font color=#0000ff>new</font> ArrayList());
    ((ArrayList)get(key)).add(value);
  }
  <font color=#0000ff>public</font> ArrayList getArrayList(String key) {
    <font color=#0000ff>if</font>(!containsKey(key)) {
      System.err.println(
        <font color=#004488>"ERROR: can't find key: "</font> + key);
      System.exit(1);
    }
    <font color=#0000ff>return</font> (ArrayList)get(key);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> printValues(PrintStream p) {
    Iterator k = keySet().iterator();
    <font color=#0000ff>while</font>(k.hasNext()) {
      String oneKey = (String)k.next();
      ArrayList val = getArrayList(oneKey);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; val.size(); i++)
        p.println((String)val.get(i));
    }
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ClassScanner {
  <font color=#0000ff>private</font> File path;
  <font color=#0000ff>private</font> String[] fileList;
  <font color=#0000ff>private</font> Properties classes = <font color=#0000ff>new</font> Properties();
  <font color=#0000ff>private</font> MultiStringMap 
    classMap = <font color=#0000ff>new</font> MultiStringMap(),
    identMap = <font color=#0000ff>new</font> MultiStringMap();
  <font color=#0000ff>private</font> StreamTokenizer in;
  <font color=#0000ff>public</font> ClassScanner() <font color=#0000ff>throws</font> IOException {
    path = <font color=#0000ff>new</font> File(<font color=#004488>"."</font>);
    fileList = path.list(<font color=#0000ff>new</font> JavaFilter());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; fileList.length; i++) {
      System.out.println(fileList[i]);
      <font color=#0000ff>try</font> {
        scanListing(fileList[i]);
      } <font color=#0000ff>catch</font>(FileNotFoundException e) {
        System.err.println(<font color=#004488>"Could not open "</font> +
          fileList[i]);
      }
    }
  }
  <font color=#0000ff>void</font> scanListing(String fname) 
  <font color=#0000ff>throws</font> IOException {
    in = <font color=#0000ff>new</font> StreamTokenizer(
        <font color=#0000ff>new</font> BufferedReader(
          <font color=#0000ff>new</font> FileReader(fname)));
    <font color=#009900>// Doesn't seem to work:</font>
    <font color=#009900>// in.slashStarComments(true);</font>
    <font color=#009900>// in.slashSlashComments(true);</font>
    in.ordinaryChar('/');
    in.ordinaryChar('.');
    in.wordChars('_', '_');
    in.eolIsSignificant(<font color=#0000ff>true</font>);
    <font color=#0000ff>while</font>(in.nextToken() != 
          StreamTokenizer.TT_EOF) {
      <font color=#0000ff>if</font>(in.ttype == '/')
        eatComments();
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(in.ttype == 
              StreamTokenizer.TT_WORD) {
        <font color=#0000ff>if</font>(in.sval.equals(<font color=#004488>"class"</font>) || 
           in.sval.equals(<font color=#004488>"interface"</font>)) {
          <font color=#009900>// Get class name:</font>
             <font color=#0000ff>while</font>(in.nextToken() != 
                   StreamTokenizer.TT_EOF
                   &amp;&amp; in.ttype != 
                   StreamTokenizer.TT_WORD)
               ;
             classes.put(in.sval, in.sval);
             classMap.add(fname, in.sval);
        }
        <font color=#0000ff>if</font>(in.sval.equals(<font color=#004488>"import"</font>) ||
           in.sval.equals(<font color=#004488>"package"</font>))
          discardLine();
        <font color=#0000ff>else</font> <font color=#009900>// It's an identifier or keyword</font>
          identMap.add(fname, in.sval);
      }
    }
  }
  <font color=#0000ff>void</font> discardLine() <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>while</font>(in.nextToken() != 
          StreamTokenizer.TT_EOF
          &amp;&amp; in.ttype != 
          StreamTokenizer.TT_EOL)
      ; <font color=#009900>// Throw away tokens to end of line</font>
  }
  <font color=#009900>// StreamTokenizer's comment removal seemed</font>
  <font color=#009900>// to be broken. This extracts them:</font>
  <font color=#0000ff>void</font> eatComments() <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>if</font>(in.nextToken() != 
       StreamTokenizer.TT_EOF) {
      <font color=#0000ff>if</font>(in.ttype == '/')
        discardLine();
      <font color=#0000ff>else</font> <font color=#0000ff>if</font>(in.ttype != '*')
        in.pushBack();
      <font color=#0000ff>else</font> 
        <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
          <font color=#0000ff>if</font>(in.nextToken() == 
            StreamTokenizer.TT_EOF)
            <font color=#0000ff>break</font>;
          <font color=#0000ff>if</font>(in.ttype == '*')
            <font color=#0000ff>if</font>(in.nextToken() != 
              StreamTokenizer.TT_EOF
              &amp;&amp; in.ttype == '/')
              <font color=#0000ff>break</font>;
        }
    }
  }
  <font color=#0000ff>public</font> String[] classNames() {
    String[] result = <font color=#0000ff>new</font> String[classes.size()];
    Iterator e = classes.keySet().iterator();
    <font color=#0000ff>int</font> i = 0;
    <font color=#0000ff>while</font>(e.hasNext())
      result[i++] = (String)e.next();
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> checkClassNames() {
    Iterator files = classMap.keySet().iterator();
    <font color=#0000ff>while</font>(files.hasNext()) {
      String file = (String)files.next();
      ArrayList cls = classMap.getArrayList(file);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cls.size(); i++) {
        String className = (String)cls.get(i);
        <font color=#0000ff>if</font>(Character.isLowerCase(
             className.charAt(0)))
          System.out.println(
            <font color=#004488>"class capitalization error, file: "</font>
            + file + <font color=#004488>", class: "</font> 
            + className);
      }
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> checkIdentNames() {
    Iterator files = identMap.keySet().iterator();
    ArrayList reportSet = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>while</font>(files.hasNext()) {
      String file = (String)files.next();
      ArrayList ids = identMap.getArrayList(file);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; ids.size(); i++) {
        String id = (String)ids.get(i);
        <font color=#0000ff>if</font>(!classes.contains(id)) {
          <font color=#009900>// Ignore identifiers of length 3 or</font>
          <font color=#009900>// longer that are all uppercase</font>
          <font color=#009900>// (probably static final values):</font>
          <font color=#0000ff>if</font>(id.length() &gt;= 3 &amp;&amp;
             id.equals(
               id.toUpperCase()))
            <font color=#0000ff>continue</font>;
          <font color=#009900>// Check to see if first char is upper:</font>
          <font color=#0000ff>if</font>(Character.isUpperCase(id.charAt(0))){
            <font color=#0000ff>if</font>(reportSet.indexOf(file + id)
                == -1){ <font color=#009900>// Not reported yet</font>
              reportSet.add(file + id);
              System.out.println(
                <font color=#004488>"Ident capitalization error in:"</font>
                + file + <font color=#004488>", ident: "</font> + id);
            }
          }
        }
      }
    }
  }
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> String usage =
    <font color=#004488>"Usage: \n"</font> + 
    <font color=#004488>"ClassScanner classnames -a\n"</font> +
    <font color=#004488>"\tAdds all the class names in this \n"</font> +
    <font color=#004488>"\tdirectory to the repository file \n"</font> +
    <font color=#004488>"\tcalled 'classnames'\n"</font> +
    <font color=#004488>"ClassScanner classnames\n"</font> +
    <font color=#004488>"\tChecks all the java files in this \n"</font> +
    <font color=#004488>"\tdirectory for capitalization errors, \n"</font> +
    <font color=#004488>"\tusing the repository file 'classnames'"</font>;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> usage() {
    System.err.println(usage);
    System.exit(1);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) 
  <font color=#0000ff>throws</font> IOException {
    <font color=#0000ff>if</font>(args.length &lt; 1 || args.length &gt; 2)
      usage();
    ClassScanner c = <font color=#0000ff>new</font> ClassScanner();
    File old = <font color=#0000ff>new</font> File(args[0]);
    <font color=#0000ff>if</font>(old.exists()) {
      <font color=#0000ff>try</font> {
        <font color=#009900>// Try to open an existing </font>
        <font color=#009900>// properties file:</font>
        InputStream oldlist =
          <font color=#0000ff>new</font> BufferedInputStream(
            <font color=#0000ff>new</font> FileInputStream(old));
        c.classes.load(oldlist);
        oldlist.close();
      } <font color=#0000ff>catch</font>(IOException e) {
        System.err.println(<font color=#004488>"Could not open "</font>
          + old + <font color=#004488>" for reading"</font>);
        System.exit(1);
      }
    }
    <font color=#0000ff>if</font>(args.length == 1) {
      c.checkClassNames();
      c.checkIdentNames();
    }
    <font color=#009900>// Write the class names to a repository:</font>
    <font color=#0000ff>if</font>(args.length == 2) {
      <font color=#0000ff>if</font>(!args[1].equals(<font color=#004488>"-a"</font>))
        usage();
      <font color=#0000ff>try</font> {
        BufferedOutputStream out =
          <font color=#0000ff>new</font> BufferedOutputStream(
            <font color=#0000ff>new</font> FileOutputStream(args[0]));
        c.classes.store(out,
          <font color=#004488>"Classes found by ClassScanner.java"</font>);
        out.close();
      } <font color=#0000ff>catch</font>(IOException e) {
        System.err.println(
          <font color=#004488>"Could not write "</font> + args[0]);
        System.exit(1);
      }
    }
  }
}

<font color=#0000ff>class</font> JavaFilter <font color=#0000ff>implements</font> FilenameFilter {
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> accept(File dir, String name) {
    <font color=#009900>// Strip path information:</font>
    String f = <font color=#0000ff>new</font> File(name).getName();
    <font color=#0000ff>return</font> f.trim().endsWith(<font color=#004488>".java"</font>);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index1452"></A><A NAME="Index1453"></A><A NAME="Index1454"></A><FONT FACE="Georgia">The
class <B>MultiStringMap</B> is a tool that allows you to map a group of strings
onto each key entry. It uses a <B>HashMap</B> (this time with inheritance) with
the key as the single string that&#8217;s mapped onto the <B>ArrayList</B>
value. The <B>add(&#160;)</B> method simply checks to see if there&#8217;s a key
already in the <B>HashMap</B>, and if not it puts one there. The
<B>getArrayList(&#160;)</B> method produces an <B>ArrayList</B> for a particular
key, and <B>printValues(&#160;)</B>, which is primarily useful for debugging,
prints out all the values <B>ArrayList</B> by <B>ArrayList</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I170' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I171>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To keep life simple, the class names from
the standard Java libraries are all put into a
<A NAME="Index1455"></A><B>Properties</B> object (from the standard Java
library). Remember that a <B>Properties</B> object is a <B>HashMap</B> that
holds only<B> String</B> objects for both the key and value entries. However, it
can be saved to disk and restored from disk in one method call, so it&#8217;s
ideal for the repository of names. Actually, we need only a list of names, and a
<B>HashMap</B> can&#8217;t accept <B>null</B> for either its key or its value
entry. So the same object will be used for both the key and the value.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I171' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I172>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the classes and identifiers that are
discovered for the files in a particular directory, two <B>MultiStringMap</B>s
are used: <B>classMap </B>and <B>identMap</B>. Also, when the program starts up
it loads the standard class name repository into the <B>Properties </B>object
called <B>classes</B>, and when a new class name is found in the local directory
that is also added to <B>classes </B>as well as to <B>classMap</B>. This way,
<B>classMap</B> can be used to step through all the classes in the local
directory, and <B>classes</B> can be used to see if the current token is a class
name (which indicates a definition of an object or method is beginning, so grab
the next tokens&#8212;until a semicolon&#8212;and put them into
<B>identMap</B>). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I172' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I173>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default constructor for
<B>ClassScanner</B> creates a list of file names, using the <B>JavaFilter</B>
implementation of
<A NAME="Index1456"></A><A NAME="Index1457"></A><B>FilenameFilter</B>, shown at
the end of the file. Then it calls <B>scanListing(&#160;)</B> for each file
name. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I173' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I174>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inside <B>scanListing(&#160;)</B> the
source code file is opened and turned into a
<A NAME="Index1458"></A><A NAME="Index1459"></A><B>StreamTokenizer</B>. In the
documentation, passing <B>true </B>to <B>slashStarComments(&#160;)</B> and
<B>slashSlashComments(&#160;)</B> is supposed to strip those comments out, but
this seems to be a bit flawed, as it doesn&#8217;t quite work. Instead, those
lines are commented out and the comments are extracted by another method. To do
this, the &#8220;<B>/</B>&#8221; must be captured as an ordinary character
rather than letting the <B>StreamTokenizer</B> absorb it as part of a comment,
and the <B>ordinaryChar(&#160;)</B> method tells the <B>StreamTokenizer
</B>to<B> </B>do this. This is also true for dots (&#8220;<B>.</B>&#8221;),
since we want to have the method calls pulled apart into individual identifiers.
However, the underscore, which is ordinarily treated by <B>StreamTokenizer</B>
as an individual character, should be left as part of identifiers since it
appears in such <B>static</B> <B>final</B> values as <B>TT_EOF</B>, etc., used
in this very program. The <B>wordChars(&#160;) </B>method takes a range of
characters you want to add to those that are left inside a token that is being
parsed as a word. Finally, when parsing for one-line comments or discarding a
line we need to know when an end-of-line occurs, so by calling
<B>eolIsSignificant(true)</B> the EOL will show up rather than being absorbed by
the <B>StreamTokenizer</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I174' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I175>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of <B>scanListing(&#160;)</B>
reads and reacts to tokens until the end of the file, signified when
<B>nextToken(&#160;)</B> returns the <B>final static </B>value
<B>StreamTokenizer.TT_EOF</B>. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I175' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I176>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the token is a &#8220;/&#8221; it is
potentially a comment, so <B>eatComments(&#160;)</B> is called to deal with it.
The only other situation we&#8217;re interested in here is if it&#8217;s a word,
of which there are some special cases.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I176' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I177>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the word is <B>class</B> or
<B>interface</B> then the next token represents a class or interface name, and
it is put into <B>classes</B> and <B>classMap</B>. If the word is <B>import</B>
or <B>package</B>, then we don&#8217;t want the rest of the line. Anything else
must be an identifier (which we&#8217;re interested in) or a keyword (which
we&#8217;re not, but they&#8217;re all lowercase anyway so it won&#8217;t spoil
things to put those in). These are added to <B>identMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I177' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I178>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>discardLine(&#160;)</B> method is
a simple tool that looks for the end of a line. Note that any time you get a new
token, you must check for the end of the file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I178' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I179>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>eatComments(&#160;)</B> method is
called whenever a forward slash is encountered in the main parsing loop.
However, that doesn&#8217;t necessarily mean a comment has been found, so the
next token must be extracted to see if it&#8217;s another forward slash (in
which case the line is discarded) or an asterisk. But if it&#8217;s neither of
those, it means the token you&#8217;ve just pulled out is needed back in the
main parsing loop! Fortunately, the
<A NAME="Index1460"></A><A NAME="Index1461"></A><B>pushBack(&#160;)</B> method
allows you to &#8220;push back&#8221; the current token onto the input stream so
that when the main parsing loop calls
<A NAME="Index1462"></A><A NAME="Index1463"></A><B>nextToken(&#160;)</B> it will
get the one you just pushed back.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I179' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I180>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For convenience, the
<B>classNames(&#160;)</B> method produces an array of all the names in the
<B>classes</B> container. This method is not used in the program but is helpful
for debugging. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I180' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I181>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The next two methods are the ones in
which the actual checking takes place. In <B>checkClassNames(&#160;)</B>, the
class names are extracted from the <B>classMap</B> (which, remember, contains
only the names in this directory, organized by file name so the file name can be
printed along with the errant class name). This is accomplished by pulling each
associated <B>ArrayList</B> and stepping through that, looking to see if the
first character is lowercase. If so, the appropriate error message is printed.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I181' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I182>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>checkIdentNames(&#160;)</B>, a
similar approach is taken: each identifier name is extracted from
<B>identMap</B>. If the name is not in the <B>classes</B> list, it&#8217;s
assumed to be an identifier or keyword. A special case is checked: if the
identifier length is three or more <I>and</I> all the characters are uppercase,
this identifier is ignored because it&#8217;s probably a <B>static</B>
<B>final</B> value such as <B>TT_EOF</B>. Of course, this is not a perfect
algorithm, but it assumes that you&#8217;ll eventually notice any all-uppercase
identifiers that are out of place.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I182' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I183>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Instead of reporting every identifier
that starts with an uppercase character, this method keeps track of which ones
have already been reported in an <B>ArrayList</B> called
<B>reportSet(&#160;)</B>. This treats the <B>ArrayList</B> as a
&#8220;set&#8221; that tells you whether an item is already in the set. The item
is produced by concatenating the file name and identifier. If the element
isn&#8217;t in the set, it&#8217;s added and then the report is made.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I183' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I184>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the listing is comprised of
<B>main(&#160;)</B>, which busies itself by handling the command line arguments
and figuring out whether you&#8217;re building a repository of class names from
the standard Java library or checking the validity of code you&#8217;ve written.
In both cases it makes a <B>ClassScanner</B> object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I184' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I185>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whether you&#8217;re building a
repository or using one, you must try to open the existing repository. By making
a <A NAME="Index1464"></A><A NAME="Index1465"></A><B>File</B> object and testing
for existence, you can decide whether to open the file and <B>load(&#160;)</B>
the <B>Properties</B> list <B>classes</B> inside <B>ClassScanner</B>. (The
classes from the repository add to, rather than overwrite, the classes found by
the <B>ClassScanner</B> constructor.) If you provide only one command-line
argument it means that you want to perform a check of the class names and
identifier names, but if you provide two arguments (the second being
&#8220;<B>-a</B>&#8221;)<B> </B>you&#8217;re building a class name repository.
In this case, an output file is opened and the method
<B>Properties.save(&#160;)</B> is used to write the list into a file, along with
a string that provides header file information.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I185' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I186>
</FONT><A NAME="_Toc481064770"></A><BR></P></DIV>
<A NAME="Heading399"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java I/O stream library does satisfy
the basic requirements: you can perform reading and writing with the console, a
file, a block of memory, or even across the Internet (as you will see in Chapter
15). With inheritance, you can create new types of input and output objects. And
you can even add a simple extensibility to the kinds of objects a stream will
accept by redefining the <B>toString(&#160;)</B> method that&#8217;s
automatically called when you pass an object to a method that&#8217;s expecting
a <B>String</B> (Java&#8217;s limited &#8220;automatic type conversion&#8221;). 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I186' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I187>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are questions left unanswered by
the documentation and design of the I/O stream library. For example, it would
have been nice if you could say that you want an exception thrown if you try to
overwrite a file when opening it for output&#8212;some programming systems allow
you to specify that you want to open an output file, but only if it
doesn&#8217;t already exist. In Java, it appears that you are supposed to use a
<B>File</B> object to determine whether a file exists, because if you open it as
a <B>FileOutputStream</B> or <B>FileWriter </B>it will always get overwritten.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I187' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I188>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The I/O stream library brings up mixed
feelings; it does much of the job and it&#8217;s portable. But if you
don&#8217;t already understand the decorator pattern, the design is
nonintuitive, so there&#8217;s extra overhead in learning and teaching it.
It&#8217;s also incomplete: there&#8217;s no support for the kind of output
formatting that almost every other language&#8217;s I/O package supports. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I188' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I189>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, once you <I>do</I> understand
the decorator pattern and begin using the library in situations that require its
flexibility, you can begin to benefit from this design, at which point its cost
in extra lines of code may not bother you as much.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I189' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I190>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you do not find what you&#8217;re
looking for in this chapter (which has only been an introduction, and is not
meant to be comprehensive), you can find in-depth coverage in <I>Java I/O</I>,
by Elliotte Rusty Harold (O&#8217;Reilly, 1999).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I190' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I191>
</FONT><A NAME="_Toc375545401"></A><A NAME="_Toc481064771"></A><BR></P></DIV>
<A NAME="Heading400"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=2>Solutions to selected exercises
can be found in the electronic document <I>The Thinking in Java Annotated
Solution Guide</I>, available for a small fee from
<I>www.BruceEckel.com</I>.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Open a text file so that
you can read the file one line at a time. Read each line as a <B>String </B>and
place that <B>String </B>object into a <B>LinkedList</B>. Print all of the lines
in the <B>LinkedList</B> in reverse order.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I191' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I192>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 1 so that the name of the file you read is provided as a command-line
argument.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I192' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I193>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to also open a text file so you can write text into it. Write the
lines in the <B>ArrayList</B>, along with line numbers (do not attempt to use
the &#8220;LineNumber&#8221; classes), out to the file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I193' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I194>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to force all the lines in the <B>ArrayList</B> to upper case and send
the results to <B>System.out</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I194' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I195>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 2 to take additional command-line arguments of words to find in the
file. Print any lines in which the words match.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I195' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I196>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>DirList.java</B> so that the <B>FilenameFilter</B> actually opens each file
and accepts the file based on whether any of the trailing arguments on the
command line exist in that file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I196' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I197>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a class called <B>SortedDirList</B> with a constructor that takes file path
information and builds a sorted directory list from the files at that path.
Create two overloaded <B>list(&#160;) </B>methods that will either produce the
whole list or a subset of the list based on an argument. Add a
<B>size(&#160;)</B> method that takes a file name and produces the size of that
file.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I197' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I198>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>WordCount.java</B> so that it produces an alphabetic sort instead, using the
tool from Chapter 9.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I198' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I199>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>WordCount.java</B> so that it uses a class containing a <B>String</B> and a
count value to store each different word, and a <B>Set</B> of these objects to
maintain the list of words.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I199' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I200>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>IOStreamDemo.java</B> so that it uses <B>LineNumberInputStream</B> to keep
track of the line count. Note that it&#8217;s much easier to just keep track
programmatically.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I200' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I201>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Starting
with section 4 of <B>IOStreamDemo.java</B>, write a program that compares the
performance of writing to a file when using buffered and unbuffered I/O.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I201' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I202>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
section 5 of <B>IOStreamDemo.java</B> to eliminate the spaces in the line
produced by the first call to <B>in5br.readLine(&#160;)</B>. Do this using a
<B>while</B> loop and <B>readChar(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I202' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I203>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Repair
the program <B>CADState.java</B> as described in the text.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I203' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I204>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
<B>Blips.java</B>, copy the file and rename it to <B>BlipCheck.java </B>and
rename the class <B>Blip2</B> to <B>BlipCheck </B>(making it <B>public</B> and
removing the public scope from the class <B>Blips</B> in the process). Remove
the <B>//!</B> marks in the file and execute the program including the offending
lines. Next, comment out the default constructor for <B>BlipCheck</B>. Run it
and explain why it works. Note that after compiling, you must execute the
program with &#8220;<B>java Blips</B>&#8221; because the <B>main(&#160;)</B>
method is still in class <B>Blips</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I204' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I205>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
<B>Blip3.java</B>, comment out the two lines after the phrases &#8220;You must
do this:&#8221; and run the program. Explain the result and why it differs from
when the two lines are in the program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I205' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER11_I206>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">(Intermediate)
In Chapter 8, locate the <B>GreenhouseControls.java</B> example, which consists
of three files. In <B>GreenhouseControls.java</B>, the <B>Restart(&#160;)</B>
inner class has a hard-coded set of events. Change the program so that it reads
the events and their relative times from a text file. (Challenging: Use a design
patterns <I>factory method </I>to build the events&#8212;see <I>Thinking in
Patterns with Java</I>, downloadable at <I>www.BruceEckel.com.</I>)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER11_I206' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn57" HREF="#fnB57">[57]</A><FONT FACE="Georgia" SIZE=2>
<I>Design Patterns</I>, Erich Gamma <I>et al.</I>, Addison-Wesley
1995.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn58" HREF="#fnB58">[58]</A><FONT FACE="Georgia" SIZE=2>
XML is another way to solve the problem of moving data across different
computing platforms, and does not depend on having Java on all platforms.
<STRIKE>However, </STRIKE>Java tools exist that support XML.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn59" HREF="#fnB59">[59]</A><FONT FACE="Georgia" SIZE=2>
Chapter 13 shows an even more convenient solution for this: a GUI program with a
scrolling text area.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap10.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap12.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:05/21/2001</P></DIV>

</BODY>

</HTML>
