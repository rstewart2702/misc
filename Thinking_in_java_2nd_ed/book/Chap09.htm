<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIJ2.rtf
Application Directory:C:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:05/21/2001
Translation Time:10:39:12
Translation Platform:Win32
Number of Output files:23
This File:Chap09.htm
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>9: Holding  Your Objects</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README.txt">Viewing Hints</a> ]
    [ <a href="RevHist.htm">Revision History</a> ]
    [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]
    [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/Services">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in Java, 2nd edition, Revision 12</FONT></H2>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap08.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap10.htm">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc477690729"></A><A NAME="_Toc481064664"></A><A NAME="Heading276"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
9: Holding <BR>Your Objects<A NAME="OLE_LINK2"></A></H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=4><backtalk:display ID=TIJ3_CHAPTER9_I0>
It&#8217;s
a fairly simple program that has only a fixed quantity of objects with known
lifetimes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, your programs will always be
creating new objects based on some criteria that will be known only at the time
the program is running. You won&#8217;t know until run-time the quantity or even
the exact type of the objects you need. To solve the general programming
problem, you need to be able to create any number of objects, anytime, anywhere.
So you can&#8217;t rely on creating a named reference to hold each one of your
objects:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MyObject myReference;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">since you&#8217;ll never know how many of
these you&#8217;ll actually need.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I0' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I1>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To solve this rather essential problem,
Java has several ways to hold objects (or rather, references to objects). The
built-in type is the array, which has been discussed before. Also, the Java
utilities library has a reasonably complete set of
<A NAME="Index848"></A><I>container classes</I> (also known as
<A NAME="Index849"></A><I>collection</I> <I>classes</I>, but because the Java 2
libraries use the name <B>Collection</B> to refer to a particular subset of the
library, I shall use the more inclusive term &#8220;container&#8221;).
Containers provide sophisticated ways to hold and even manipulate your objects.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I1' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I2>
</FONT><A NAME="_Toc375545347"></A><A NAME="_Toc481064665"></A><BR></P></DIV>
<A NAME="Heading277"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Arrays</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most of the necessary introduction to
<A NAME="Index850"></A>arrays is in the last section of Chapter 4, which showed
how you define and initialize an array. Holding objects is the focus of this
chapter, and an array is just one way to hold objects. But there are a number of
other ways to hold objects, so what makes an array special?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I2' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I3>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are two issues that distinguish
arrays from other types of containers: <A NAME="Index851"></A>efficiency and
<A NAME="Index852"></A>type. The array is the most efficient way that Java
provides to store and randomly access a sequence of objects (actually, object
references). The array is a simple linear sequence, which makes element access
fast, but you pay for this speed: when you create an array object, its size is
fixed and cannot be changed for the lifetime of that array object. You might
suggest creating an array of a particular size and then, if you run out of
space, creating a new one and moving all the references from the old one to the
new one. This is the behavior of the <B>ArrayList </B>class, which will be
studied later in this chapter. However, because of the overhead of this size
flexibility, an <B>ArrayList</B> is measurably less efficient than an array.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I3' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I4>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <A NAME="Index853"></A><B>vector</B>
container class in C++ <I>does</I> know the type of objects it holds, but it has
a different drawback when compared with arrays in Java: the C++
<B>vector</B>&#8217;s <B>operator[]</B> doesn&#8217;t do bounds checking, so you
can run past the
end</FONT><A NAME="fnB44" HREF="#fn44">[44]</A><FONT FACE="Georgia">. In Java,
you get bounds checking regardless of whether you&#8217;re using an array or a
container&#8212;you&#8217;ll get a
<A NAME="Index854"></A><B>RuntimeException</B> if you exceed the bounds. As
you&#8217;ll learn in Chapter 10, this type of exception indicates a programmer
error, and thus you don&#8217;t need to check for it in your code. As an aside,
the reason the C++ <B>vector</B> doesn&#8217;t check bounds with every access is
speed&#8212;in Java you have the constant performance overhead of bounds
checking all the time for both arrays and containers.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I4' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I5>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The other generic container classes that
will be studied in this chapter, <A NAME="Index855"></A><B>List</B>,
<A NAME="Index856"></A><B>Set</B>, and <A NAME="Index857"></A><B>Map</B>, all
deal with objects as if they had no specific type. That is, they treat them as
type <A NAME="Index858"></A><B>Object</B>, the root class of all classes in
Java. This works fine from one standpoint: you need to build only one container,
and any Java object will go into that container. (Except for
primitives&#8212;these can be placed in containers as constants using the Java
primitive wrapper classes, or as changeable values by wrapping in your own
class.) This is the second place where an array is superior to the generic
containers: when you create an array, you create it to hold a specific type.
This means that you get compile-time type checking to prevent you from putting
the wrong type in, or mistaking the type that you&#8217;re extracting. Of
course, Java will prevent you from sending an inappropriate message to an
object, either at compile-time or at run-time. So it&#8217;s not much riskier
one way or the other, it&#8217;s just nicer if the compiler points it out to
you, faster at run-time, and there&#8217;s less likelihood that the end user
will get surprised by an exception.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I5' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I6>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For efficiency and type checking
it&#8217;s always worth trying to use an array if you can. However, when
you&#8217;re trying to solve a more general problem arrays can be too
restrictive. After looking at arrays, the rest of this chapter will be devoted
to the container classes provided by Java.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I6' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I7>
</FONT><A NAME="_Toc375545348"></A><A NAME="_Toc481064666"></A><BR></P></DIV>
<A NAME="Heading278"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Arrays are first-class
objects<BR><A NAME="Index859"></A><A NAME="Index860"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Regardless of what type of array
you&#8217;re working with, the array identifier is actually a reference to a
true object that&#8217;s created on the heap. This is the object that holds the
references to the other objects, and it can be created either implicitly, as
part of the array initialization syntax, or explicitly with a <B>new</B>
expression. Part of the array object (in fact, the only field or method you can
access) is the read-only <B>length</B> member that tells you how many elements
can be stored in that array object.
<A NAME="Index861"></A><A NAME="Index862"></A>The &#8216;<B>[]</B>&#8217; syntax
is the only other access that you have to the array object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I7' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I8>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows the various
ways that an array can be initialized, and how the array references can be
assigned to different array objects. It also shows that
<A NAME="Index863"></A>arrays of objects and <A NAME="Index864"></A>arrays of
primitives are almost identical in their use. The only difference is that arrays
of objects hold references, while arrays of primitives hold the primitive values
directly. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I8' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I9>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ArraySize.java</font>
<font color=#009900>// Initialization &amp; re-assignment of arrays.</font>

<font color=#0000ff>class</font> Weeble {} <font color=#009900>// A small mythical creature</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySize {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Arrays of objects:</font>
    Weeble[] a; <font color=#009900>// Null reference</font>
    Weeble[] b = <font color=#0000ff>new</font> Weeble[5]; <font color=#009900>// Null references</font>
    Weeble[] c = <font color=#0000ff>new</font> Weeble[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; c.length; i++)
      c[i] = <font color=#0000ff>new</font> Weeble();
    <font color=#009900>// Aggregate initialization:</font>
    Weeble[] d = { 
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    <font color=#009900>// Dynamic aggregate initialization:</font>
    a = <font color=#0000ff>new</font> Weeble[] {
      <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble()
    };
    System.out.println(<font color=#004488>"a.length="</font> + a.length);
    System.out.println(<font color=#004488>"b.length = "</font> + b.length);
    <font color=#009900>// The references inside the array are </font>
    <font color=#009900>// automatically initialized to null:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; b.length; i++)
      System.out.println(<font color=#004488>"b["</font> + i + <font color=#004488>"]="</font> + b[i]);
    System.out.println(<font color=#004488>"c.length = "</font> + c.length);
    System.out.println(<font color=#004488>"d.length = "</font> + d.length);
    a = d;
    System.out.println(<font color=#004488>"a.length = "</font> + a.length);

    <font color=#009900>// Arrays of primitives:</font>
    <font color=#0000ff>int</font>[] e; <font color=#009900>// Null reference</font>
    <font color=#0000ff>int</font>[] f = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[5];
    <font color=#0000ff>int</font>[] g = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[4];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; g.length; i++)
      g[i] = i*i;
    <font color=#0000ff>int</font>[] h = { 11, 47, 93 };
    <font color=#009900>// Compile error: variable e not initialized:</font>
    <font color=#009900>//!System.out.println("e.length=" + e.length);</font>
    System.out.println(<font color=#004488>"f.length = "</font> + f.length);
    <font color=#009900>// The primitives inside the array are</font>
    <font color=#009900>// automatically initialized to zero:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; f.length; i++)
      System.out.println(<font color=#004488>"f["</font> + i + <font color=#004488>"]="</font> + f[i]);
    System.out.println(<font color=#004488>"g.length = "</font> + g.length);
    System.out.println(<font color=#004488>"h.length = "</font> + h.length);
    e = h;
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
    e = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[] { 1, 2 };
    System.out.println(<font color=#004488>"e.length = "</font> + e.length);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the output from the
program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>b.length = 5
b[0]=<font color=#0000ff>null</font>
b[1]=<font color=#0000ff>null</font>
b[2]=<font color=#0000ff>null</font>
b[3]=<font color=#0000ff>null</font>
b[4]=<font color=#0000ff>null</font>
c.length = 4
d.length = 3
a.length = 3
a.length = 2
f.length = 5
f[0]=0
f[1]=0
f[2]=0
f[3]=0
f[4]=0
g.length = 4
h.length = 3
e.length = 3
e.length = 2</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The array <B>a</B> is initially just a
<A NAME="Index865"></A><B>null </B>reference, and the compiler prevents you from
doing anything with this reference until you&#8217;ve properly initialized it.
The array <B>b</B> is initialized to point to an array of <B>Weeble</B>
references, but no actual <B>Weeble</B> objects are ever placed in that array.
However, you can still ask what the size of the array is, since <B>b</B> is
pointing to a legitimate object. This brings up a slight drawback: you
can&#8217;t find out how many elements are actually <I>in</I> the array, since
<B>length</B> tells you only how many elements <I>can</I> be placed in the
array; that is, the size of the array object, not the number of elements it
actually holds. However, when an array object is created its references are
automatically initialized to <B>null</B>, so you can see whether a particular
array slot has an object in it by checking to see whether it&#8217;s
<B>null</B>. Similarly, an array of primitives is automatically initialized to
zero for numeric types, <B>(char)0 </B>for <B>char</B>, and<B> false</B> for
<B>boolean</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I9' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I10>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Array <B>c</B> shows the creation of the
array object followed by the assignment of <B>Weeble</B> objects to all the
slots in the array. Array <B>d</B> shows the &#8220;aggregate
initialization&#8221; syntax that causes the array object to be created
(implicitly with <B>new</B> on the heap, just like for array <B>c</B>)
<I>and</I> initialized with <B>Weeble</B> objects, all in one statement.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I10' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I11>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index866"></A><A NAME="Index867"></A><FONT FACE="Georgia">The
next array initialization could be thought of as a &#8220;dynamic aggregate
initialization.&#8221; The aggregate initialization used by <B>d</B> must be
used at the point of <B>d</B>&#8217;s definition, but with the second syntax you
can create and initialize an array object anywhere. For example, suppose
<B>hide(&#160;)</B> is a method that takes an array of <B>Weeble</B> objects.
You could call it by saying:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(d);</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">but you can also dynamically create the
array you want to pass as the argument:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>hide(<font color=#0000ff>new</font> Weeble[] { <font color=#0000ff>new</font> Weeble(), <font color=#0000ff>new</font> Weeble() });</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In some situations this new syntax
provides a more convenient way to write code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I11' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I12>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The expression:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a = d;</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">shows how you can take a reference
that&#8217;s attached to one array object and assign it to another array object,
just as you can do with any other type of object reference. Now both <B>a</B>
and <B>d</B> are pointing to the same array object on the heap.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I12' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I13>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second part of <B>ArraySize.java</B>
shows that primitive arrays work just like object arrays <I>except</I> that
primitive arrays hold the primitive values directly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I13' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I14>
</FONT><A NAME="_Toc375545349"></A><BR></P></DIV>
<A NAME="Heading279"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Containers of primitives<BR><A NAME="Index868"></A><A NAME="Index869"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Container classes can hold only
references to objects. An array, however, can be created to hold primitives
directly, as well as references to objects. It <I>is</I> possible to use the
&#8220;wrapper&#8221; classes such as <B>Integer</B>, <B>Double,</B> etc. to
place primitive values inside a container, but the wrapper classes for
primitives can be awkward to use. In addition, it&#8217;s much more efficient to
create and access an array of primitives than a container of wrapped primitives.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I14' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I15>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, if you&#8217;re using a
primitive type and you need the flexibility of a container that automatically
expands when more space is needed, the array won&#8217;t work and you&#8217;re
forced to use a container of wrapped primitives. You might think that there
should be a specialized type of <B>ArrayList</B> for each of the primitive data
types, but Java doesn&#8217;t provide this for you. Some sort of templatizing
mechanism might someday provide a better way for Java to handle this
problem.</FONT><A NAME="fnB45" HREF="#fn45">[45]</A><FONT FACE="Georgia">

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I15' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I16>
</FONT><A NAME="_Toc481064667"></A><BR></P></DIV>
<A NAME="Heading280"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Returning an array</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Suppose you&#8217;re writing a method and
you don&#8217;t just want to return just one thing, but a whole bunch of things.
Languages like C and C++ make this difficult because you can&#8217;t just return
an array, only a pointer to an array. This introduces problems because it
becomes messy to control the lifetime of the array, which easily leads to memory
leaks. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I16' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I17>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index870"></A><A NAME="Index871"></A><FONT FACE="Georgia">Java
takes a similar approach, but you just &#8220;return an array.&#8221; Actually,
of course, you&#8217;re returning a reference to an array, but with Java you
never worry about responsibility for that array&#8212;it will be around as long
as you need it, and the garbage collector will clean it up when you&#8217;re
done. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I17' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I18>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example, consider returning an
array of <B>String</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:IceCream.java</font>
<font color=#009900>// Returning arrays from methods.</font>

<font color=#0000ff>public</font> <font color=#0000ff>class</font> IceCream {
  <font color=#0000ff>static</font> String[] flav = {
    <font color=#004488>"Chocolate"</font>, <font color=#004488>"Strawberry"</font>,
    <font color=#004488>"Vanilla Fudge Swirl"</font>, <font color=#004488>"Mint Chip"</font>,
    <font color=#004488>"Mocha Almond Fudge"</font>, <font color=#004488>"Rum Raisin"</font>,
    <font color=#004488>"Praline Cream"</font>, <font color=#004488>"Mud Pie"</font> 
  };
  <font color=#0000ff>static</font> String[] flavorSet(<font color=#0000ff>int</font> n) {
    <font color=#009900>// Force it to be positive &amp; within bounds:</font>
    n = Math.abs(n) % (flav.length + 1);
    String[] results = <font color=#0000ff>new</font> String[n];
    <font color=#0000ff>boolean</font>[] picked = 
      <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[flav.length];
    <font color=#0000ff>for</font> (<font color=#0000ff>int</font> i = 0; i &lt; n; i++) {
      <font color=#0000ff>int</font> t;
      <font color=#0000ff>do</font> 
        t = (<font color=#0000ff>int</font>)(Math.random() * flav.length);
      <font color=#0000ff>while</font> (picked[t]);
      results[i] = flav[t];
      picked[t] = <font color=#0000ff>true</font>;
    }
    <font color=#0000ff>return</font> results;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 20; i++) {
      System.out.println(
        <font color=#004488>"flavorSet("</font> + i + <font color=#004488>") = "</font>);
      String[] fl = flavorSet(flav.length);
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; fl.length; j++)
        System.out.println(<font color=#004488>"\t"</font> + fl[j]);
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The method <B>flavorSet(&#160;)</B>
creates an array of <B>String</B> called <B>results</B>. The size of this array
is <B>n</B>, determined by the argument you pass into the method. Then it
proceeds to choose flavors randomly from the array <B>flav</B> and place them
into <B>results</B>, which it finally returns. Returning an array is just like
returning any other object&#8212;it&#8217;s a reference. It&#8217;s not
important that the array was created within <B>flavorSet(&#160;)</B>, or that
the array was created anyplace else, for that matter. The garbage collector
takes care of cleaning up the array when you&#8217;re done with it, and the
array will persist for as long as you need it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I18' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I19>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an aside, notice that when
<B>flavorSet(&#160;)</B> chooses flavors randomly, it ensures that a random
choice hasn&#8217;t been picked before. This is performed in a <B>do</B> loop
that keeps making random choices until it finds one that&#8217;s not already in
the <B>picked</B> array. (Of course, a <B>String</B> comparison could also have
been performed to see if the random choice was already in the <B>results</B>
array, but <B>String</B> comparisons are inefficient.) If it&#8217;s successful,
it adds the entry and finds the next one (<B>i </B>gets incremented). 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I19' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I20>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>main(&#160;)</B> prints out 20 full
sets of flavors, so you can see that <B>flavorSet(&#160;)</B> chooses the
flavors in a random order each time. It&#8217;s easiest to see this if you
redirect the output into a file. And while you&#8217;re looking at the file,
remember, you just <I>want</I> the ice cream, you don&#8217;t <I>need</I> it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I20' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I21>
</FONT><A NAME="_Toc481064668"></A><BR></P></DIV>
<A NAME="Heading281"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The Arrays class</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>java.util</B>, you&#8217;ll find
the <A NAME="Index872"></A><B>Arrays</B> class, which holds a set of
<B>static</B> methods that perform utility functions for arrays. There are four
basic functions: <B>equals(&#160;)</B>, to compare two arrays for equality;
<B>fill(&#160;)</B>, to fill an array with a value; <B>sort(&#160;)</B>, to sort
the array; and <B>binarySearch(&#160;)</B>, to find an element in a sorted
array. All of these methods are overloaded for all the primitive types and
<B>Object</B>s. In addition, there&#8217;s a single <B>asList(&#160;)</B> method
that takes any array and turns it into a <B>List</B> container&#8212;which
you&#8217;ll learn about later in this chapter.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I21' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I22>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While useful, the <B>Arrays</B> class
stops short of being fully functional. For example, it would be nice to be able
to easily print the elements of an array without having to code a <B>for</B>
loop by hand every time. And as you&#8217;ll see, the <B>fill(&#160;)</B> method
only takes a single value and places it in the array, so if you wanted&#8212;for
example&#8212;to fill an array with randomly generated numbers,
<B>fill(&#160;)</B> is no help.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I22' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I23>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus it makes sense to supplement the
<B>Arrays</B> class with some additional utilities, which will be placed in the
<B>package</B> <B>com.bruceeckel.util</B> for convenience. These will print an
array of any type, and fill an array with values or objects that are created by
an object called a <I>generator</I> that you can define.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I23' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I24>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index873"></A><FONT FACE="Georgia">Because code needs
to be created for each primitive type as well as <B>Object</B>, there&#8217;s a
lot of nearly duplicated
code</FONT><A NAME="fnB46" HREF="#fn46">[46]</A><FONT FACE="Georgia">. For
example, a &#8220;generator&#8221; interface is required for each type because
the return type of <B>next(&#160;)</B> must be different in each
case:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Generator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> Generator { 
  Object next(); 
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:BooleanGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> BooleanGenerator {
  <font color=#0000ff>boolean</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:ByteGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ByteGenerator {
  <font color=#0000ff>byte</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:CharGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> CharGenerator {
  <font color=#0000ff>char</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:ShortGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> ShortGenerator {
  <font color=#0000ff>short</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:IntGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> IntGenerator {
  <font color=#0000ff>int</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:LongGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> LongGenerator {
  <font color=#0000ff>long</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:FloatGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> FloatGenerator {
  <font color=#0000ff>float</font> next();
} <font color=#009900>///:~</font>

<font color=#009900>//: com:bruceeckel:util:DoubleGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> DoubleGenerator {
  <font color=#0000ff>double</font> next();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index874"></A><FONT FACE="Georgia"><B>Arrays2</B>
contains a variety of <B>print(&#160;)</B> functions, overloaded for each type.
You can simply print an array, you can add a message before the array is
printed, or you can print a range of elements within an array. The
<B>print(&#160;)</B> code is self-explanatory:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Arrays2.java</font>
<font color=#009900>// A supplement to java.util.Arrays, to provide</font>
<font color=#009900>// additional useful functionality when working</font>
<font color=#009900>// with arrays. Allows any array to be printed,</font>
<font color=#009900>// and to be filled via a user-defined </font>
<font color=#009900>// "generator" object.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Arrays2 {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font>
  start(<font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, <font color=#0000ff>int</font> length) {
    <font color=#0000ff>if</font>(from != 0 || to != length)
      System.out.print(<font color=#004488>"["</font>+ from +<font color=#004488>":"</font>+ to +<font color=#004488>"] "</font>);
    System.out.print(<font color=#004488>"("</font>);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> end() {
    System.out.println(<font color=#004488>")"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Object[] a) {
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, Object[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(Object[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to){
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>boolean</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>boolean</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>boolean</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>byte</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>byte</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>byte</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>char</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>char</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>char</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to -1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>short</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>short</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>short</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>int</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>int</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>int</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>long</font>[] a) {
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>long</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>long</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>float</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>float</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>float</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to) {
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(<font color=#0000ff>double</font>[] a) {
      print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(String msg, <font color=#0000ff>double</font>[] a) {
    System.out.print(msg + <font color=#004488>" "</font>);
    print(a, 0, a.length);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  print(<font color=#0000ff>double</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to){
    start(from, to, a.length);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++) {
      System.out.print(a[i]);
      <font color=#0000ff>if</font>(i &lt; to - 1)
        System.out.print(<font color=#004488>", "</font>);
    }
    end();
  }
  <font color=#009900>// Fill an array using a generator:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Object[] a, Generator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Object[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       Generator gen){
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>boolean</font>[] a, BooleanGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>boolean</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to,
       BooleanGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>byte</font>[] a, ByteGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>byte</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       ByteGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>char</font>[] a, CharGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>char</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       CharGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>short</font>[] a, ShortGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>short</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       ShortGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>int</font>[] a, IntGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>int</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       IntGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>long</font>[] a, LongGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>long</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       LongGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>float</font>[] a, FloatGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>float</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to, 
       FloatGenerator gen) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>double</font>[] a, DoubleGenerator gen) {
      fill(a, 0, a.length, gen);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(<font color=#0000ff>double</font>[] a, <font color=#0000ff>int</font> from, <font color=#0000ff>int</font> to,
       DoubleGenerator gen){
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = from; i &lt; to; i++)
      a[i] = gen.next();
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandBooleanGenerator 
  <font color=#0000ff>implements</font> BooleanGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> next() { 
      <font color=#0000ff>return</font> r.nextBoolean();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandByteGenerator 
  <font color=#0000ff>implements</font> ByteGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>byte</font> next() { 
      <font color=#0000ff>return</font> (<font color=#0000ff>byte</font>)r.nextInt();
    }
  }
  <font color=#0000ff>static</font> String ssource = 
    <font color=#004488>"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</font> +
    <font color=#004488>"abcdefghijklmnopqrstuvwxyz"</font>;
  <font color=#0000ff>static</font> <font color=#0000ff>char</font>[] src = ssource.toCharArray();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandCharGenerator 
  <font color=#0000ff>implements</font> CharGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>char</font> next() {
      <font color=#0000ff>int</font> pos = Math.abs(r.nextInt());
      <font color=#0000ff>return</font> src[pos % src.length];
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandStringGenerator
  <font color=#0000ff>implements</font> Generator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> len;
    <font color=#0000ff>private</font> RandCharGenerator cg = 
      <font color=#0000ff>new</font> RandCharGenerator();
    <font color=#0000ff>public</font> RandStringGenerator(<font color=#0000ff>int</font> length) {
      len = length;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#0000ff>char</font>[] buf = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[len];
      <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; len; i++)
        buf[i] = cg.next();
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> String(buf);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandShortGenerator 
  <font color=#0000ff>implements</font> ShortGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>short</font> next() { 
      <font color=#0000ff>return</font> (<font color=#0000ff>short</font>)r.nextInt();
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandIntGenerator 
  <font color=#0000ff>implements</font> IntGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> mod = 10000;
    <font color=#0000ff>public</font> RandIntGenerator() {}
    <font color=#0000ff>public</font> RandIntGenerator(<font color=#0000ff>int</font> modulo) {
      mod = modulo;
    }
    <font color=#0000ff>public</font> <font color=#0000ff>int</font> next() { 
      <font color=#0000ff>return</font> r.nextInt() % mod; 
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandLongGenerator 
  <font color=#0000ff>implements</font> LongGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>long</font> next() { <font color=#0000ff>return</font> r.nextLong(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandFloatGenerator 
  <font color=#0000ff>implements</font> FloatGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>float</font> next() { <font color=#0000ff>return</font> r.nextFloat(); }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandDoubleGenerator 
  <font color=#0000ff>implements</font> DoubleGenerator {
    <font color=#0000ff>public</font> <font color=#0000ff>double</font> next() {<font color=#0000ff>return</font> r.nextDouble();}
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To fill an array of elements using a
generator, the <B>fill(&#160;)</B> method takes a reference to an appropriate
generator <B>interface</B>, which has a <B>next(&#160;)</B> method that will
somehow produce an object of the right type (depending on how the interface is
implemented). The <B>fill(&#160;)</B> method simply calls <B>next(&#160;)</B>
until the desired range has been filled. Now you can create any generator by
implementing the appropriate <B>interface</B>, and use your generator with
<B>fill(&#160;)</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I24' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I25>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Random data generators are useful for
testing, so a set of inner classes is created to implement all the primitive
generator interfaces, as well as a <B>String</B> generator to represent
<B>Object</B>. You can see that <B>RandStringGenerator</B> uses
<B>RandCharGenerator</B> to fill an array of characters, which is then turned
into a <B>String</B>. The size of the array is determined by the constructor
argument. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I25' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I26>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To generate numbers that aren&#8217;t too
large, <B>RandIntGenerator</B> defaults to a modulus of 10,000, but the
overloaded constructor allows you to choose a smaller value.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I26' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I27>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a program to test the
library, and to demonstrate how it is used:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:TestArrays2.java</font>
<font color=#009900>// Test and demonstrate Arrays2 utilities</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> TestArrays2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Or get the size from the command line:</font>
    <font color=#0000ff>if</font>(args.length != 0)
      size = Integer.parseInt(args[0]);
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    String[] a9 = <font color=#0000ff>new</font> String[size];
    Arrays2.fill(a1, 
      <font color=#0000ff>new</font> Arrays2.RandBooleanGenerator());
    Arrays2.print(a1);
    Arrays2.print(<font color=#004488>"a1 = "</font>, a1);
    Arrays2.print(a1, size/3, size/3 + size/3);
    Arrays2.fill(a2,
      <font color=#0000ff>new</font> Arrays2.RandByteGenerator());
    Arrays2.print(a2);
    Arrays2.print(<font color=#004488>"a2 = "</font>, a2);
    Arrays2.print(a2, size/3, size/3 + size/3);
    Arrays2.fill(a3,
      <font color=#0000ff>new</font> Arrays2.RandCharGenerator());
    Arrays2.print(a3);
    Arrays2.print(<font color=#004488>"a3 = "</font>, a3);
    Arrays2.print(a3, size/3, size/3 + size/3);
    Arrays2.fill(a4,
      <font color=#0000ff>new</font> Arrays2.RandShortGenerator());
    Arrays2.print(a4);
    Arrays2.print(<font color=#004488>"a4 = "</font>, a4);
    Arrays2.print(a4, size/3, size/3 + size/3);
    Arrays2.fill(a5,
      <font color=#0000ff>new</font> Arrays2.RandIntGenerator());
    Arrays2.print(a5);
    Arrays2.print(<font color=#004488>"a5 = "</font>, a5);
    Arrays2.print(a5, size/3, size/3 + size/3);
    Arrays2.fill(a6,
      <font color=#0000ff>new</font> Arrays2.RandLongGenerator());
    Arrays2.print(a6);
    Arrays2.print(<font color=#004488>"a6 = "</font>, a6);
    Arrays2.print(a6, size/3, size/3 + size/3);
    Arrays2.fill(a7,
      <font color=#0000ff>new</font> Arrays2.RandFloatGenerator());
    Arrays2.print(a7);
    Arrays2.print(<font color=#004488>"a7 = "</font>, a7);
    Arrays2.print(a7, size/3, size/3 + size/3);
    Arrays2.fill(a8,
      <font color=#0000ff>new</font> Arrays2.RandDoubleGenerator());
    Arrays2.print(a8);
    Arrays2.print(<font color=#004488>"a8 = "</font>, a8);
    Arrays2.print(a8, size/3, size/3 + size/3);
    Arrays2.fill(a9,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(7));
    Arrays2.print(a9);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
    Arrays2.print(a9, size/3, size/3 + size/3);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>size</B> parameter has a default
value, but you can also set it from the command line.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I27' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I28>
</FONT><A NAME="_Toc481064669"></A><BR></P></DIV>
<A NAME="Heading282"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Filling an array</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java standard library <B>Arrays</B>
also has a <B>fill(&#160;)</B> method, but that is rather trivial&#8212;it only
duplicates a single value into each location, or in the case of objects, copies
the same reference into each location. Using <B>Arrays2.print(&#160;)</B>, the
<A NAME="Index875"></A><B>Arrays.fill(&#160;)</B> methods can be easily
demonstrated:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FillingArrays.java</font>
<font color=#009900>// Using Arrays.fill()</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 6;
    <font color=#009900>// Or get the size from the command line:</font>
    <font color=#0000ff>if</font>(args.length != 0)
      size = Integer.parseInt(args[0]);
    <font color=#0000ff>boolean</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>boolean</font>[size];
    <font color=#0000ff>byte</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>byte</font>[size];
    <font color=#0000ff>char</font>[] a3 = <font color=#0000ff>new</font> <font color=#0000ff>char</font>[size];
    <font color=#0000ff>short</font>[] a4 = <font color=#0000ff>new</font> <font color=#0000ff>short</font>[size];
    <font color=#0000ff>int</font>[] a5 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[size];
    <font color=#0000ff>long</font>[] a6 = <font color=#0000ff>new</font> <font color=#0000ff>long</font>[size];
    <font color=#0000ff>float</font>[] a7 = <font color=#0000ff>new</font> <font color=#0000ff>float</font>[size];
    <font color=#0000ff>double</font>[] a8 = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[size];
    String[] a9 = <font color=#0000ff>new</font> String[size];
    Arrays.fill(a1, <font color=#0000ff>true</font>);
    Arrays2.print(<font color=#004488>"a1 = "</font>, a1);
    Arrays.fill(a2, (<font color=#0000ff>byte</font>)11);
    Arrays2.print(<font color=#004488>"a2 = "</font>, a2);
    Arrays.fill(a3, 'x');
    Arrays2.print(<font color=#004488>"a3 = "</font>, a3);
    Arrays.fill(a4, (<font color=#0000ff>short</font>)17);
    Arrays2.print(<font color=#004488>"a4 = "</font>, a4);
    Arrays.fill(a5, 19);
    Arrays2.print(<font color=#004488>"a5 = "</font>, a5);
    Arrays.fill(a6, 23);
    Arrays2.print(<font color=#004488>"a6 = "</font>, a6);
    Arrays.fill(a7, 29);
    Arrays2.print(<font color=#004488>"a7 = "</font>, a7);
    Arrays.fill(a8, 47);
    Arrays2.print(<font color=#004488>"a8 = "</font>, a8);
    Arrays.fill(a9, <font color=#004488>"Hello"</font>);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
    <font color=#009900>// Manipulating ranges:</font>
    Arrays.fill(a9, 3, 5, <font color=#004488>"World"</font>);
    Arrays2.print(<font color=#004488>"a9 = "</font>, a9);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can either fill the entire array,
or&#8212;as the last two statements show&#8212;a range of elements. But since
you can only provide a single value to use for filling using
<B>Arrays.fill(&#160;)</B>, the <B>Arrays2.fill(&#160;)</B> methods produce much
more interesting results.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I28' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I29>
</FONT><A NAME="_Toc481064670"></A><BR></P></DIV>
<A NAME="Heading283"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Copying an array<BR><A NAME="Index876"></A><A NAME="Index877"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java standard library provides a
<B>static </B>method, <A NAME="Index878"></A><B>System.arraycopy(&#160;)</B>,
which can make much faster copies of an array than if you use a <B>for</B> loop
to perform the copy by hand. <B>System.arraycopy(&#160;) </B>is overloaded to
handle all types. Here&#8217;s an example that manipulates arrays of
<B>int</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CopyingArrays.java</font>
<font color=#009900>// Using System.arraycopy()</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CopyingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] i = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[25];
    <font color=#0000ff>int</font>[] j = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[25];
    Arrays.fill(i, 47);
    Arrays.fill(j, 99);
    Arrays2.print(<font color=#004488>"i = "</font>, i);
    Arrays2.print(<font color=#004488>"j = "</font>, j);
    System.arraycopy(i, 0, j, 0, i.length);
    Arrays2.print(<font color=#004488>"j = "</font>, j);
    <font color=#0000ff>int</font>[] k = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(k, 103);
    System.arraycopy(i, 0, k, 0, k.length);
    Arrays2.print(<font color=#004488>"k = "</font>, k);
    Arrays.fill(k, 103);
    System.arraycopy(k, 0, i, 0, k.length);
    Arrays2.print(<font color=#004488>"i = "</font>, i);
    <font color=#009900>// Objects:</font>
    Integer[] u = <font color=#0000ff>new</font> Integer[10];
    Integer[] v = <font color=#0000ff>new</font> Integer[5];
    Arrays.fill(u, <font color=#0000ff>new</font> Integer(47));
    Arrays.fill(v, <font color=#0000ff>new</font> Integer(99));
    Arrays2.print(<font color=#004488>"u = "</font>, u);
    Arrays2.print(<font color=#004488>"v = "</font>, v);
    System.arraycopy(v, 0, 
      u, u.length/2, v.length);
    Arrays2.print(<font color=#004488>"u = "</font>, u);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The arguments to <B>arraycopy(&#160;)</B>
are the source array, the offset into the source array from whence to start
copying, the destination array, the offset into the destination array where the
copying begins, and the number of elements to copy. Naturally, any violation of
the array boundaries will cause an exception.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I29' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I30>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example shows that both primitive
arrays and object arrays can be copied. However, if you copy arrays of objects
then only the references get copied&#8212;there&#8217;s no duplication of the
objects themselves. This is called a <I>shallow copy</I> (see Appendix A).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I30' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I31>
</FONT><A NAME="_Toc375545350"></A><A NAME="_Toc481064671"></A><BR></P></DIV>
<A NAME="Heading284"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Comparing arrays<BR><A NAME="Index879"></A><A NAME="Index880"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Arrays</B> provides the overloaded
method <B>equals(&#160;)</B> to compare entire arrays for equality. Again, these
are overloaded for all the primitives, and for <B>Object</B>. To be equal, the
arrays must have the same number of elements and each element must be equivalent
to each corresponding element in the other array, using the <B>equals(&#160;)
</B>for each element. (For primitives, that primitive&#8217;s wrapper class
<B>equals(&#160;)</B> is used; for example, <B>Integer.equals(&#160;) </B>for
<B>int</B>.)<B> </B>Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ComparingArrays.java</font>
<font color=#009900>// Using Arrays.equals()</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparingArrays {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a1 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    <font color=#0000ff>int</font>[] a2 = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[10];
    Arrays.fill(a1, 47);
    Arrays.fill(a2, 47);
    System.out.println(Arrays.equals(a1, a2));
    a2[3] = 11;
    System.out.println(Arrays.equals(a1, a2));
    String[] s1 = <font color=#0000ff>new</font> String[5];
    Arrays.fill(s1, <font color=#004488>"Hi"</font>);
    String[] s2 = {<font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>, <font color=#004488>"Hi"</font>};
    System.out.println(Arrays.equals(s1, s2));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Originally, <B>a1</B> and <B>a2</B> are
exactly equal, so the output is &#8220;true,&#8221; but then one of the elements
is changed so the second line of output is &#8220;false.&#8221; In the last
case, all the elements of <B>s1</B> point to the same object, but <B>s2</B> has
five unique objects. However, array equality is based on contents (via
<B>Object.equals(&#160;)</B>) and so the result is &#8220;true.&#8221;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I31' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I32>
</FONT><A NAME="_Toc481064672"></A><BR></P></DIV>
<A NAME="Heading285"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Array element comparisons<BR><A NAME="Index881"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the missing features in the Java
1.0 and 1.1 libraries is algorithmic operations&#8212;even simple
<A NAME="Index882"></A>sorting. This was a rather confusing situation to someone
expecting an adequate standard library. Fortunately, Java 2 remedies the
situation, at least for the sorting problem.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I32' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I33>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A problem with writing generic sorting
code is that sorting must perform comparisons based on the actual type of the
object. Of course, one approach is to write a different sorting method for every
different type, but you should be able to recognize that this does not produce
code that is easily reused for new types.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I33' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I34>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A primary goal of programming design is
to &#8220;separate things that change from things that stay the same,&#8221; and
here, the code that stays the same is the general sort algorithm, but the thing
that changes from one use to the next is the way objects are compared. So
instead of hard-wiring the comparison code into many different sort routines,
the technique of the <A NAME="Index883"></A><I>callback</I> is used. With a
callback, the part of the code that varies from case to case is encapsulated
inside its own class, and the part of the code that&#8217;s always the same will
call back to the code that changes. That way you can make different objects to
express different ways of comparison and feed them to the same sorting code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I34' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I35>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Java 2, there are two ways to provide
comparison functionality. The first is with the <I>natural comparison method</I>
that is imparted to a class by implementing the <B>java.lang.Comparable</B>
interface. This is a very simple interface with a single method,
<A NAME="Index884"></A><B>compareTo(&#160;)</B>. This method takes another
<B>Object</B> as an argument, and produces a negative value if the
<STRIKE>argument is less than the </STRIKE>current object<U> is less than the
argument</U>, zero if the argument is equal, and a positive value if the
<U>current object is greater than the </U>argument <STRIKE>is greater than the
current object</STRIKE>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I35' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I36>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a class that implements
<A NAME="Index885"></A><B>Comparable</B> and demonstrates the comparability by
using the Java standard library method
<B>Arrays.sort(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CompType.java</font>
<font color=#009900>// Implementing Comparable in a class.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CompType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>int</font> j;
  <font color=#0000ff>public</font> CompType(<font color=#0000ff>int</font> n1, <font color=#0000ff>int</font> n2) { 
    i = n1;
    j = n2;
  }
  <font color=#0000ff>public</font> String toString() { 
    <font color=#0000ff>return</font> <font color=#004488>"[i = "</font> + i + <font color=#004488>", j = "</font> + j + <font color=#004488>"]"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>int</font> rvi = ((CompType)rv).i;
    <font color=#0000ff>return</font> (i &lt; rvi ? -1 : (i == rvi ? 0 : 1));
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Random r = <font color=#0000ff>new</font> Random();
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> randInt() {
    <font color=#0000ff>return</font> Math.abs(r.nextInt()) % 100;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Generator generator() {
    <font color=#0000ff>return</font> <font color=#0000ff>new</font> Generator() {
      <font color=#0000ff>public</font> Object next() {
        <font color=#0000ff>return</font> <font color=#0000ff>new</font> CompType(randInt(),randInt());
      }
    };
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a);
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you define the comparison function,
you are responsible for deciding what it means to compare one of your objects to
another. Here, only the <B>i</B> values are used in the comparison, and the
<B>j</B> values are ignored.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I36' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I37>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>static randInt(&#160;)</B> method
produces positive values between zero and 100, and the <B>generator(&#160;)</B>
method produces an object that implements the <B>Generator</B> interface, by
creating an anonymous inner class (see Chapter 8). This builds <B>CompType</B>
objects by initializing them with random values. In <B>main(&#160;)</B>, the
generator is used to fill an array of <B>CompType</B>, which is then sorted. If
<B>Comparable</B> hadn&#8217;t been implemented, then you&#8217;d get a
compile-time error message when you tried to call <B>sort(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I37' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I38>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now suppose someone hands you a class
that doesn&#8217;t implement <B>Comparable</B>, or they hand you this class that
<I>does</I> implement <B>Comparable</B>, but you decide you don&#8217;t like the
way it works and would rather have a different comparison function for the type.
To do this, you use the second approach for comparing objects, by creating a
separate class that implements an interface called
<A NAME="Index886"></A><B>Comparator</B>. This has two methods,
<B>compare(&#160;)</B> and <B>equals(&#160;)</B>. However, you don&#8217;t have
to implement <B>equals(&#160;)</B> except for special performance needs, because
anytime you create a class it is implicitly inherited from <B>Object</B>, which
has an <B>equals(&#160;)</B>. So you can just use the default <B>Object</B>
<B>equals(&#160;)</B> and satisfy the contract imposed by the interface.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I38' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I39>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Collections</B> class (which
we&#8217;ll look at more later) contains a single <B>Comparator</B> that
reverses the natural sorting order. This can easily be applied to the
<B>CompType</B>: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I39' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I40>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Reverse.java</font>
<font color=#009900>// The Collecions.reverseOrder() Comparator.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Reverse {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a, Collections.reverseOrder());
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index887"></A><FONT FACE="Georgia">The call to
<B>Collections.reverseOrder(&#160;)</B> produces the reference to the
<B>Comparator</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I40' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I41>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a second example, the following
<B>Comparator</B> compares <B>CompType</B> objects based on their <B>j</B>
values rather than their <B>i</B> values:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ComparatorTest.java</font>
<font color=#009900>// Implementing a Comparator for a class.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> CompTypeComparator <font color=#0000ff>implements</font> Comparator {
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    <font color=#0000ff>int</font> j1 = ((CompType)o1).j;
    <font color=#0000ff>int</font> j2 = ((CompType)o2).j;
    <font color=#0000ff>return</font> (j1 &lt; j2 ? -1 : (j1 == j2 ? 0 : 1));
  }
}
           
<font color=#0000ff>public</font> <font color=#0000ff>class</font> ComparatorTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    CompType[] a = <font color=#0000ff>new</font> CompType[10];
    Arrays2.fill(a, CompType.generator());
    Arrays2.print(<font color=#004488>"before sorting, a = "</font>, a);
    Arrays.sort(a, <font color=#0000ff>new</font> CompTypeComparator());
    Arrays2.print(<font color=#004488>"after sorting, a = "</font>, a);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>compare(&#160;)</B> method must
return a negative integer, zero, or a positive integer if the first argument is
less than, equal to, or greater than the second, respectively.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I41' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I42>
</FONT><A NAME="_Toc481064673"></A><BR></P></DIV>
<A NAME="Heading286"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sorting an array</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With the built-in sorting methods, you
can sort any array of primitives, and any array of objects that either
implements <B>Comparable</B> or has an associated <B>Comparator</B>. This fills
a big hole in the Java libraries&#8212;believe it or not, there was no support
in Java 1.0 or 1.1 for sorting <B>String</B>s! Here&#8217;s an example that
generates random <B>String</B> objects and sorts them:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:StringSorting.java</font>
<font color=#009900>// Sorting an array of Strings.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    Arrays2.print(<font color=#004488>"Before sorting: "</font>, sa);
    Arrays.sort(sa);
    Arrays2.print(<font color=#004488>"After sorting: "</font>, sa);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing you&#8217;ll notice about the
output in the <B>String</B> sorting algorithm is that it&#8217;s
<A NAME="Index888"></A><A NAME="Index889"></A><A NAME="Index890"></A><I>lexicographic</I>,
so it puts all the words starting with uppercase letters first, followed by all
the words starting with lowercase letters. (Telephone books are typically sorted
this way.) You may also want to group the words together regardless of case, and
you can do this by defining a <B>Comparator </B>class, thereby overriding the
default <B>String Comparable </B>behavior. For reuse, this will be added to the
&#8220;util&#8221; package:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I42' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I43>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:AlphabeticComparator.java</font>
<font color=#009900>// Keeping upper and lowercase letters together.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticComparator 
<font color=#0000ff>implements</font> Comparator{
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compare(Object o1, Object o2) {
    String s1 = (String)o1;
    String s2 = (String)o2;
    <font color=#0000ff>return</font> s1.toLowerCase().compareTo(
      s2.toLowerCase());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each <B>String</B> is converted to
lowercase before the comparison. <B>String</B>&#8217;s built-in
<B>compareTo(&#160;)</B> method provides the desired functionality.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I43' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I44>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a test using
<B>AlphabeticComparator</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:AlphabeticSorting.java</font>
<font color=#009900>// Keeping upper and lowercase letters together.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSorting {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    Arrays2.print(<font color=#004488>"Before sorting: "</font>, sa);
    Arrays.sort(sa, <font color=#0000ff>new</font> AlphabeticComparator());
    Arrays2.print(<font color=#004488>"After sorting: "</font>, sa);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The sorting algorithm that&#8217;s used
in the Java standard library is designed to be optimal for the particular type
you&#8217;re sorting&#8212;a Quicksort for primitives, and a stable merge sort
for objects. So you shouldn&#8217;t need to spend any time worrying about
performance unless your profiling tool points you to the sorting process as a
bottleneck.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I44' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I45>
</FONT><A NAME="_Toc481064674"></A><BR></P></DIV>
<A NAME="Heading287"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Searching a sorted array<BR><A NAME="Index891"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once an array is sorted, you can perform
a fast search for a particular item using
<A NAME="Index892"></A><B>Arrays.binarySearch(&#160;)</B>. However, it&#8217;s
very important that you do not try to use
<A NAME="Index893"></A><B>binarySearch(&#160;)</B> on an unsorted array; the
results will be unpredictable. The following example uses a
<B>RandIntGenerator</B> to fill an array, then to produces values to search for:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I45' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I46>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ArraySearching.java</font>
<font color=#009900>// Using Arrays.binarySearch().</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ArraySearching {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font>[] a = <font color=#0000ff>new</font> <font color=#0000ff>int</font>[100];
    Arrays2.RandIntGenerator gen = 
      <font color=#0000ff>new</font> Arrays2.RandIntGenerator(1000);
    Arrays2.fill(a, gen);
    Arrays.sort(a);
    Arrays2.print(<font color=#004488>"Sorted array: "</font>, a);
    <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
      <font color=#0000ff>int</font> r = gen.next();
      <font color=#0000ff>int</font> location = Arrays.binarySearch(a, r);
      <font color=#0000ff>if</font>(location &gt;= 0) {
        System.out.println(<font color=#004488>"Location of "</font> + r + 
          <font color=#004488>" is "</font> + location + <font color=#004488>", a["</font> + 
          location + <font color=#004488>"] = "</font> + a[location]);
        <font color=#0000ff>break</font>; <font color=#009900>// Out of while loop</font>
      }
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>while</B> loop, random values
are generated as search items, until one of them is found.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I46' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I47>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Arrays.binarySearch(&#160;)</B>
produces a value greater than or equal to zero if the search item is found.
Otherwise, it produces a negative value representing the place that the element
should be inserted if you are maintaining the sorted array by hand. The value
produced is </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>-(insertion point) - 1</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The insertion point is the index of the
first element greater than the key, or <B>a.size(&#160;)</B>, if all elements in
the array are less than the specified key.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I47' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I48>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the array contains duplicate elements,
there is no guarantee which one will be found. The algorithm is thus not really
designed to support duplicate elements, as much as tolerate them. If you need a
sorted list of nonduplicated elements, however, use a <B>TreeSet</B>, which will
be introduced later in this chapter. This takes care of all the details for you
automatically. Only in cases of performance bottlenecks should you replace the
<B>TreeSet</B> with a hand-maintained array.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I48' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I49>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have sorted an object array using
a <B>Comparator</B> (primitive arrays do not allow sorting with a
<B>Comparator</B>), you must include that same <B>Comparator</B> when you
perform a <B>binarySearch(&#160;)</B> (using the overloaded version of the
function that&#8217;s provided). For example, the <B>AlphabeticSorting.java</B>
program can be modified to perform a search:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:AlphabeticSearch.java</font>
<font color=#009900>// Searching with a Comparator.</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> AlphabeticSearch {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    String[] sa = <font color=#0000ff>new</font> String[30];
    Arrays2.fill(sa,
      <font color=#0000ff>new</font> Arrays2.RandStringGenerator(5));
    AlphabeticComparator comp =
      <font color=#0000ff>new</font> AlphabeticComparator();
    Arrays.sort(sa, comp);
    <font color=#0000ff>int</font> index =
      Arrays.binarySearch(sa, sa[10], comp);
    System.out.println(<font color=#004488>"Index = "</font> + index);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Comparator</B> must be passed to
the overloaded <B>binarySearch(&#160;)</B> as the third argument. In the above
example, success is guaranteed because the search item is plucked out of the
array itself.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I49' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I50>
</FONT><A NAME="_Toc481064675"></A><BR></P></DIV>
<A NAME="Heading288"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Array summary</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To summarize what you&#8217;ve seen so
far, your first and most efficient choice to hold a group of objects should be
an array, and you&#8217;re forced into this choice if you want to hold a group
of primitives. In the remainder of this chapter we&#8217;ll look at the more
general case, when you don&#8217;t know at the time you&#8217;re writing the
program how many objects you&#8217;re going to need, or if you need a more
sophisticated way to store your objects. Java provides a library of
<A NAME="Index894"></A><I>container classes</I> to solve this problem, the basic
types of which are <A NAME="Index895"></A><B>List</B>,
<A NAME="Index896"></A><B>Set</B>,<B> </B>and <A NAME="Index897"></A><B>Map</B>.
You can solve a surprising number of problems using these tools.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I50' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I51>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Among their other
characteristics&#8212;<B>Set</B>, for example, holds only one object of each
value, and <B>Map</B> is an <A NAME="Index898"></A><I>associative array</I> that
lets you associate any object with any other object&#8212;the Java container
classes will automatically resize themselves. So, unlike arrays, you can put in
any number of objects and you don&#8217;t need to worry about how big to make
the container while you&#8217;re writing the program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I51' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I52>
</FONT><A NAME="_Toc481064676"></A><BR></P></DIV>
<A NAME="Heading289"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Introduction to containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To me, container classes are one of the
most powerful tools for raw development because they significantly increase your
programming muscle. <A NAME="Index899"></A><A NAME="Index900"></A>The Java 2
containers represent a thorough
redesign</FONT><A NAME="fnB47" HREF="#fn47">[47]</A><FONT FACE="Georgia"> of the
rather poor showings in Java 1.0 and 1.1. Some of the redesign makes things
tighter and more sensible. It also fills out the functionality of the containers
library, providing the behavior of <A NAME="Index901"></A>linked lists,
<A NAME="Index902"></A>queues, and <A NAME="Index903"></A>deques (double-ended
queues, pronounced &#8220;decks&#8221;).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I52' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I53>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The design of a containers library is
difficult (true of most library design problems). In
<A NAME="Index904"></A><A NAME="Index905"></A>C++, the container classes covered
the bases with many different classes. This was better than what was available
prior to the C++ container classes (nothing), but it didn&#8217;t translate well
into Java. On the other extreme, I&#8217;ve seen a containers library that
consists of a single class, &#8220;container,&#8221; which acts like both a
linear sequence and an associative array at the same time. The Java 2 container
library strikes a balance: the full functionality that you expect from a mature
container library, but easier to learn and use than the C++ container classes
and other similar container libraries. The result can seem a bit odd in places.
Unlike some of the decisions made in the early Java libraries, these oddities
were not accidents, but carefully considered decisions based on trade-offs in
complexity. It might take you a little while to get comfortable with some
aspects of the library, but I think you&#8217;ll find yourself rapidly acquiring
and using these new tools. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I53' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I54>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java 2 container library takes the
issue of &#8220;holding your objects&#8221; and divides it into two distinct
concepts:
<A NAME="Index906"></A><A NAME="Index907"></A><A NAME="Index908"></A><A NAME="Index909"></A><A NAME="Index910"></A></FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Collection</B>:
a group of individual elements, often with some rule applied to them. A
<B>List</B> must hold the elements in a particular sequence, and a <B>Set</B>
cannot have any duplicate elements. (A <I>bag</I>, which is not implemented in
the Java container library&#8212;since <B>List</B>s provide you with enough of
that functionality&#8212;has no such rules.)<B>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I54' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I55>
</B></FONT><LI><FONT FACE="Verdana"><B>	</B></FONT><FONT FACE="Georgia"><B>Map</B>:
a group of key-value object pairs. At first glance, this might seem like it
ought to be a <B>Collection</B> of pairs, but when you try to implement it that
way the design gets awkward, so it&#8217;s clearer to make it a separate
concept. On the other hand, it&#8217;s convenient to look at portions of a
<B>Map</B> by creating a <B>Collection</B> to represent that portion. Thus, a
<B>Map</B> can return a <B>Set</B> of its keys, a <B>Collection </B>of its
values, or a <B>Set </B>of its pairs. <B>Map</B>s, like arrays, can easily be
expanded to multiple dimensions without adding new concepts: you simply make a
<B>Map</B> whose values are <B>Map</B>s (and the values of <I>those</I>
<B>Map</B>s can be <B>Map</B>s, etc.).<B>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I55' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I56>
</B></FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We
will first look at the general features of containers, then go into details, and
finally learn why there are different versions of some containers, and how to
choose between them.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I56' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I57>
</FONT><A NAME="_Ref348399494"></A><A NAME="_Toc375545351"></A><A NAME="_Toc481064677"></A><BR></P></DIV>
<A NAME="Heading290"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Printing containers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unlike arrays, the containers print
nicely without any help. Here&#8217;s an example that also introduces you to the
basic types of containers:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:PrintingContainers.java</font>
<font color=#009900>// Containers print themselves automatically.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> PrintingContainers {
  <font color=#0000ff>static</font> Collection fill(Collection c) {
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"dog"</font>);
    c.add(<font color=#004488>"cat"</font>);
    <font color=#0000ff>return</font> c;
  }
  <font color=#0000ff>static</font> Map fill(Map m) {
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Bosco"</font>);
    m.put(<font color=#004488>"dog"</font>, <font color=#004488>"Spot"</font>);
    m.put(<font color=#004488>"cat"</font>, <font color=#004488>"Rags"</font>);
    <font color=#0000ff>return</font> m;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(fill(<font color=#0000ff>new</font> HashSet()));
    System.out.println(fill(<font color=#0000ff>new</font> HashMap()));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned before, there are two basic
categories in the Java container library. The distinction is based on the number
of items that are held in each location of the container. The <B>Collection</B>
category only holds one item in each location (the name is a bit misleading
since entire container libraries are often called &#8220;collections&#8221;). It
includes the <B>List</B>, which holds a group of items in a specified sequence,
and the <B>Set</B>, which only allows the addition of one item of each type. The
<B>ArrayList </B>is a type of <B>List</B>, and <B>HashSet </B>is a type of
<B>Set</B>. To add items to any <B>Collection</B>, there&#8217;s an
<B>add(&#160;)</B> method. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I57' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I58>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Map</B> holds key-value pairs,
rather like a mini database. The above program uses one flavor of <B>Map</B>,<B>
</B>the <B>HashMap</B>. If you have a <B>Map</B> that associates states with
their capitals and you want to know the capital of Ohio, you look it
up&#8212;almost as if you were indexing into an array. (Maps are also called
<A NAME="Index911"></A><A NAME="Index912"></A><I>associative arrays</I>.) To add
elements to a <B>Map</B> there&#8217;s a <B>put(&#160;)</B> method that takes a
key and a value as arguments. The above example only shows adding elements and
does not look the elements up after they&#8217;re added. That will be shown
later. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I58' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I59>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The overloaded <B>fill(&#160;)</B>
methods fill <B>Collection</B>s and <B>Map</B>s, respectively. If you look at
the output, you can see that the default printing behavior (provided via the
container&#8217;s various <B>toString(&#160;)</B> methods) produces quite
readable results, so no additional printing support is necessary as it was with
arrays:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>[dog, dog, cat]
[cat, dog]
{cat=Rags, dog=Spot}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>Collection</B> is printed surrounded
by square braces, with each element separated by a comma. A <B>Map</B> is
surrounded by curly braces, with each key and value associated with an equal
sign (keys on the left, values on the right).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I59' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I60>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also immediately see the basic
behavior of the different containers. The <B>List</B> holds the objects exactly
as they are entered, without any reordering or editing. The <B>Set</B>, however,
only accepts one of each object and it uses its own internal ordering method (in
general, you are only concerned with whether or not something is a member of the
<B>Set</B>, not the order in which it appears&#8212;for that you&#8217;d use a
<B>List</B>). And the <B>Map</B> also only accepts one of each type of item,
based on the key, and it also has its own internal ordering and does not care
about the order in which you enter the items.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I60' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I61>
</FONT><A NAME="_Toc481064678"></A><BR></P></DIV>
<A NAME="Heading291"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Filling containers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the problem of printing the
containers is taken care of, filling containers suffers from the same deficiency
as <B>java.util.Arrays</B>. Just like <B>Arrays</B>, there is a companion class
called <B>Collections</B> containing <B>static</B> utility methods including one
called <A NAME="Index913"></A><B>fill(&#160;)</B>. This <B>fill(&#160;)</B> also
just duplicates a single object reference throughout the container, and also
only works for <B>List</B> objects and not <B>Set</B>s or
<B>Map</B>s:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FillingLists.java</font>
<font color=#009900>// The Collections.fill() method.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillingLists {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      list.add(<font color=#004488>""</font>);
    Collections.fill(list, <font color=#004488>"Hello"</font>);
    System.out.println(list);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This method is made even less useful by
the fact that it can only replace elements that are already in the <B>List</B>,
and will not add new elements.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I61' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I62>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To be able to create interesting
examples, here is a complementary <B>Collections2</B> library (part of
<B>com.bruceeckel.util </B>for convenience) with a <B>fill(&#160;)</B> method
that uses a <A NAME="Index914"></A>generator to add elements, and allows you to
specify the number of elements you want to <B>add(&#160;)</B>. The <B>Generator
interface</B> defined previously will work for <B>Collection</B>s, but the
<B>Map</B> requires its own generator <B>interface</B> since a pair of objects
(one key and one value) must be produced by each call to <B>next(&#160;)</B>.
Here is the <B>Pair</B> class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Pair.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Pair {
  <font color=#0000ff>public</font> Object key, value;
  Pair(Object k, Object v) {
    key = k;
    value = v;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Next, the generator <B>interface</B> that
produces the <B>Pair</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:MapGenerator.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>interface</font> MapGenerator {
  Pair next();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With these, a set of utilities for
working with the <A NAME="Index915"></A>container classes can be
developed:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:Collections2.java</font>
<font color=#009900>// To fill any type of container </font>
<font color=#009900>// using a generator object.</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collections2 {
  <font color=#009900>// Fill an array using a generator:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Collection c, Generator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++)
      c.add(gen.next());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  fill(Map m, MapGenerator gen, <font color=#0000ff>int</font> count) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; count; i++) {
      Pair p = gen.next();
      m.put(p.key, p.value);
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> RandStringPairGenerator
  <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> Arrays2.RandStringGenerator gen;
    <font color=#0000ff>public</font> RandStringPairGenerator(<font color=#0000ff>int</font> len) {
      gen = <font color=#0000ff>new</font> Arrays2.RandStringGenerator(len);
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(gen.next(), gen.next());
    }
  }
  <font color=#009900>// Default object so you don't have </font>
  <font color=#009900>// to create your own:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> RandStringPairGenerator rsp =
    <font color=#0000ff>new</font> RandStringPairGenerator(10);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringPairGenerator
  <font color=#0000ff>implements</font> MapGenerator {
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>public</font> StringPairGenerator(String[][] data) {
      d = data;
    }
    <font color=#0000ff>public</font> Pair next() {
      <font color=#009900>// Force the index to wrap:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> <font color=#0000ff>new</font> Pair(d[index][0], d[index][1]);
    }
    <font color=#0000ff>public</font> StringPairGenerator reset() { 
      index = -1; 
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color=#009900>// Use a predefined dataset:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringPairGenerator geography =
    <font color=#0000ff>new</font> StringPairGenerator(
      CountryCapitals.pairs);
  <font color=#009900>// Produce a sequence from a 2D array:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> StringGenerator
  <font color=#0000ff>implements</font> Generator {
    <font color=#0000ff>private</font> String[][] d;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> position;
    <font color=#0000ff>private</font> <font color=#0000ff>int</font> index = -1;
    <font color=#0000ff>public</font> 
    StringGenerator(String[][] data, <font color=#0000ff>int</font> pos) {
      d = data;
      position = pos;
    }
    <font color=#0000ff>public</font> Object next() {
      <font color=#009900>// Force the index to wrap:</font>
      index = (index + 1) % d.length;
      <font color=#0000ff>return</font> d[index][position];
    }
    <font color=#0000ff>public</font> StringGenerator reset() { 
      index = -1;
      <font color=#0000ff>return</font> <font color=#0000ff>this</font>;
    }
  }
  <font color=#009900>// Use a predefined dataset:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator countries =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs,0);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> StringGenerator capitals =
    <font color=#0000ff>new</font> StringGenerator(CountryCapitals.pairs,1);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both versions of <B>fill(&#160;)</B> take
an argument that determines the number of items to add to the container. In
addition, there are two generators for the map: <B>RandStringPairGenerator</B>,
which creates any number of pairs of gibberish <B>String</B>s with length
determined by the constructor argument; and <B>StringPairGenerator</B>, which
produces pairs of <B>String</B>s given a two-dimensional array of <B>String</B>.
The <B>StringGenerator</B> also takes a two-dimensional array of <B>String
</B>but generates single items rather than <B>Pair</B>s.<B> </B>The <B>static
rsp</B>, <B>geography</B>,<B> countries</B>, and <B>capitals</B> objects provide
prebuilt generators, the last three using<B> </B>all the countries of the world
and their capitals. Note that if you try to create more pairs than are
available, the generators will loop around to the beginning, and if you are
putting the pairs into a <B>Map</B>, the duplicates will just be ignored.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I62' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I63>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is the predefined dataset, which
consists of country names and their capitals. It is set in a small font to
prevent taking up unnecessary space:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: com:bruceeckel:util:CountryCapitals.java</font>
<font color=#0000ff>package</font> com.bruceeckel.util;
<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountryCapitals {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>final</font> String[][] pairs = {
    <font color=#009900>// Africa</font>
    {<font color=#004488>"ALGERIA"</font>,<font color=#004488>"Algiers"</font>}, {<font color=#004488>"ANGOLA"</font>,<font color=#004488>"Luanda"</font>},
    {<font color=#004488>"BENIN"</font>,<font color=#004488>"Porto-Novo"</font>}, {<font color=#004488>"BOTSWANA"</font>,<font color=#004488>"Gaberone"</font>},
    {<font color=#004488>"BURKINA FASO"</font>,<font color=#004488>"Ouagadougou"</font>}, {<font color=#004488>"BURUNDI"</font>,<font color=#004488>"Bujumbura"</font>},
    {<font color=#004488>"CAMEROON"</font>,<font color=#004488>"Yaounde"</font>}, {<font color=#004488>"CAPE VERDE"</font>,<font color=#004488>"Praia"</font>},
    {<font color=#004488>"CENTRAL AFRICAN REPUBLIC"</font>,<font color=#004488>"Bangui"</font>},
    {<font color=#004488>"CHAD"</font>,<font color=#004488>"N'djamena"</font>},  {<font color=#004488>"COMOROS"</font>,<font color=#004488>"Moroni"</font>},
    {<font color=#004488>"CONGO"</font>,<font color=#004488>"Brazzaville"</font>}, {<font color=#004488>"DJIBOUTI"</font>,<font color=#004488>"Dijibouti"</font>},
    {<font color=#004488>"EGYPT"</font>,<font color=#004488>"Cairo"</font>}, {<font color=#004488>"EQUATORIAL GUINEA"</font>,<font color=#004488>"Malabo"</font>},
    {<font color=#004488>"ERITREA"</font>,<font color=#004488>"Asmara"</font>}, {<font color=#004488>"ETHIOPIA"</font>,<font color=#004488>"Addis Ababa"</font>},
    {<font color=#004488>"GABON"</font>,<font color=#004488>"Libreville"</font>}, {<font color=#004488>"THE GAMBIA"</font>,<font color=#004488>"Banjul"</font>},
    {<font color=#004488>"GHANA"</font>,<font color=#004488>"Accra"</font>}, {<font color=#004488>"GUINEA"</font>,<font color=#004488>"Conakry"</font>},
    {<font color=#004488>"GUINEA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"BISSAU"</font>,<font color=#004488>"Bissau"</font>},
    {<font color=#004488>"CETE D'IVOIR (IVORY COAST)"</font>,<font color=#004488>"Yamoussoukro"</font>},
    {<font color=#004488>"KENYA"</font>,<font color=#004488>"Nairobi"</font>}, {<font color=#004488>"LESOTHO"</font>,<font color=#004488>"Maseru"</font>},
    {<font color=#004488>"LIBERIA"</font>,<font color=#004488>"Monrovia"</font>}, {<font color=#004488>"LIBYA"</font>,<font color=#004488>"Tripoli"</font>},
    {<font color=#004488>"MADAGASCAR"</font>,<font color=#004488>"Antananarivo"</font>}, {<font color=#004488>"MALAWI"</font>,<font color=#004488>"Lilongwe"</font>},
    {<font color=#004488>"MALI"</font>,<font color=#004488>"Bamako"</font>}, {<font color=#004488>"MAURITANIA"</font>,<font color=#004488>"Nouakchott"</font>},
    {<font color=#004488>"MAURITIUS"</font>,<font color=#004488>"Port Louis"</font>}, {<font color=#004488>"MOROCCO"</font>,<font color=#004488>"Rabat"</font>},
    {<font color=#004488>"MOZAMBIQUE"</font>,<font color=#004488>"Maputo"</font>}, {<font color=#004488>"NAMIBIA"</font>,<font color=#004488>"Windhoek"</font>},
    {<font color=#004488>"NIGER"</font>,<font color=#004488>"Niamey"</font>}, {<font color=#004488>"NIGERIA"</font>,<font color=#004488>"Abuja"</font>},
    {<font color=#004488>"RWANDA"</font>,<font color=#004488>"Kigali"</font>}, {<font color=#004488>"SAO TOME E PRINCIPE"</font>,<font color=#004488>"Sao Tome"</font>},
    {<font color=#004488>"SENEGAL"</font>,<font color=#004488>"Dakar"</font>}, {<font color=#004488>"SEYCHELLES"</font>,<font color=#004488>"Victoria"</font>},
    {<font color=#004488>"SIERRA LEONE"</font>,<font color=#004488>"Freetown"</font>}, {<font color=#004488>"SOMALIA"</font>,<font color=#004488>"Mogadishu"</font>},
    {<font color=#004488>"SOUTH AFRICA"</font>,<font color=#004488>"Pretoria</font><font color=#004488>/Cape Town"</font>}, {<font color=#004488>"SUDAN"</font>,<font color=#004488>"Khartoum"</font>},
    {<font color=#004488>"SWAZILAND"</font>,<font color=#004488>"Mbabane"</font>}, {<font color=#004488>"TANZANIA"</font>,<font color=#004488>"Dodoma"</font>},
    {<font color=#004488>"TOGO"</font>,<font color=#004488>"Lome"</font>}, {<font color=#004488>"TUNISIA"</font>,<font color=#004488>"Tunis"</font>},
    {<font color=#004488>"UGANDA"</font>,<font color=#004488>"Kampala"</font>},
    {<font color=#004488>"DEMOCRATIC REPUBLIC OF THE CONGO (ZAIRE)"</font>,<font color=#004488>"Kinshasa"</font>},
    {<font color=#004488>"ZAMBIA"</font>,<font color=#004488>"Lusaka"</font>}, {<font color=#004488>"ZIMBABWE"</font>,<font color=#004488>"Harare"</font>},
    <font color=#009900>// Asia</font>
    {<font color=#004488>"AFGHANISTAN"</font>,<font color=#004488>"Kabul"</font>}, {<font color=#004488>"BAHRAIN"</font>,<font color=#004488>"Manama"</font>},
    {<font color=#004488>"BANGLADESH"</font>,<font color=#004488>"Dhaka"</font>}, {<font color=#004488>"BHUTAN"</font>,<font color=#004488>"Thimphu"</font>},
    {<font color=#004488>"BRUNEI"</font>,<font color=#004488>"Bandar Seri Begawan"</font>}, {<font color=#004488>"CAMBODIA"</font>,<font color=#004488>"Phnom Penh"</font>},
    {<font color=#004488>"CHINA"</font>,<font color=#004488>"Beijing"</font>}, {<font color=#004488>"CYPRUS"</font>,<font color=#004488>"Nicosia"</font>},
    {<font color=#004488>"INDIA"</font>,<font color=#004488>"New Delhi"</font>}, {<font color=#004488>"INDONESIA"</font>,<font color=#004488>"Jakarta"</font>},
    {<font color=#004488>"IRAN"</font>,<font color=#004488>"Tehran"</font>}, {<font color=#004488>"IRAQ"</font>,<font color=#004488>"Baghdad"</font>},
    {<font color=#004488>"ISRAEL"</font>,<font color=#004488>"Jerusalem"</font>}, {<font color=#004488>"JAPAN"</font>,<font color=#004488>"Tokyo"</font>},
    {<font color=#004488>"JORDAN"</font>,<font color=#004488>"Amman"</font>}, {<font color=#004488>"KUWAIT"</font>,<font color=#004488>"Kuwait City"</font>},
    {<font color=#004488>"LAOS"</font>,<font color=#004488>"Vientiane"</font>}, {<font color=#004488>"LEBANON"</font>,<font color=#004488>"Beirut"</font>},
    {<font color=#004488>"MALAYSIA"</font>,<font color=#004488>"Kuala Lumpur"</font>}, {<font color=#004488>"THE MALDIVES"</font>,<font color=#004488>"Male"</font>},
    {<font color=#004488>"MONGOLIA"</font>,<font color=#004488>"Ulan Bator"</font>}, {<font color=#004488>"MYANMAR (BURMA)"</font>,<font color=#004488>"Rangoon"</font>},
    {<font color=#004488>"NEPAL"</font>,<font color=#004488>"Katmandu"</font>}, {<font color=#004488>"NORTH KOREA"</font>,<font color=#004488>"P'yongyang"</font>},
    {<font color=#004488>"OMAN"</font>,<font color=#004488>"Muscat"</font>}, {<font color=#004488>"PAKISTAN"</font>,<font color=#004488>"Islamabad"</font>},
    {<font color=#004488>"PHILIPPINES"</font>,<font color=#004488>"Manila"</font>}, {<font color=#004488>"QATAR"</font>,<font color=#004488>"Doha"</font>},
    {<font color=#004488>"SAUDI ARABIA"</font>,<font color=#004488>"Riyadh"</font>}, {<font color=#004488>"SINGAPORE"</font>,<font color=#004488>"Singapore"</font>},
    {<font color=#004488>"SOUTH KOREA"</font>,<font color=#004488>"Seoul"</font>}, {<font color=#004488>"SRI LANKA"</font>,<font color=#004488>"Colombo"</font>},
    {<font color=#004488>"SYRIA"</font>,<font color=#004488>"Damascus"</font>}, {<font color=#004488>"TAIWAN (REPUBLIC OF CHINA)"</font>,<font color=#004488>"Taipei"</font>},
    {<font color=#004488>"THAILAND"</font>,<font color=#004488>"Bangkok"</font>}, {<font color=#004488>"TURKEY"</font>,<font color=#004488>"Ankara"</font>},
    {<font color=#004488>"UNITED ARAB EMIRATES"</font>,<font color=#004488>"Abu Dhabi"</font>}, {<font color=#004488>"VIETNAM"</font>,<font color=#004488>"Hanoi"</font>},
    {<font color=#004488>"YEMEN"</font>,<font color=#004488>"Sana'a"</font>},
    <font color=#009900>// Australia and Oceania</font>
    {<font color=#004488>"AUSTRALIA"</font>,<font color=#004488>"Canberra"</font>}, {<font color=#004488>"FIJI"</font>,<font color=#004488>"Suva"</font>},
    {<font color=#004488>"KIRIBATI"</font>,<font color=#004488>"Bairiki"</font>},
    {<font color=#004488>"MARSHALL ISLANDS"</font>,<font color=#004488>"Dalap-Uliga-Darrit"</font>},
    {<font color=#004488>"MICRONESIA"</font>,<font color=#004488>"Palikir"</font>}, {<font color=#004488>"NAURU"</font>,<font color=#004488>"Yaren"</font>},
    {<font color=#004488>"NEW ZEALAND"</font>,<font color=#004488>"Wellington"</font>}, {<font color=#004488>"PALAU"</font>,<font color=#004488>"Koror"</font>},
    {<font color=#004488>"PAPUA NEW GUINEA"</font>,<font color=#004488>"Port Moresby"</font>},
    {<font color=#004488>"SOLOMON ISLANDS"</font>,<font color=#004488>"Honaira"</font>}, {<font color=#004488>"TONGA"</font>,<font color=#004488>"Nuku'alofa"</font>},
    {<font color=#004488>"TUVALU"</font>,<font color=#004488>"Fongafale"</font>}, {<font color=#004488>"VANUATU"</font>,<font color=#004488>"&lt; Port-Vila"</font>},
    {<font color=#004488>"WESTERN SAMOA"</font>,<font color=#004488>"Apia"</font>},
    <font color=#009900>// Eastern Europe and former USSR </font>
    {<font color=#004488>"ARMENIA"</font>,<font color=#004488>"Yerevan"</font>}, {<font color=#004488>"AZERBAIJAN"</font>,<font color=#004488>"Baku"</font>},
    {<font color=#004488>"BELARUS (BYELORUSSIA)"</font>,<font color=#004488>"Minsk"</font>}, {<font color=#004488>"GEORGIA"</font>,<font color=#004488>"Tbilisi"</font>},
    {<font color=#004488>"KAZAKSTAN"</font>,<font color=#004488>"Almaty"</font>}, {<font color=#004488>"KYRGYZSTAN"</font>,<font color=#004488>"Alma-Ata"</font>},
    {<font color=#004488>"MOLDOVA"</font>,<font color=#004488>"Chisinau"</font>}, {<font color=#004488>"RUSSIA"</font>,<font color=#004488>"Moscow"</font>},
    {<font color=#004488>"TAJIKISTAN"</font>,<font color=#004488>"Dushanbe"</font>}, {<font color=#004488>"TURKMENISTAN"</font>,<font color=#004488>"Ashkabad"</font>},
    {<font color=#004488>"UKRAINE"</font>,<font color=#004488>"Kyiv"</font>}, {<font color=#004488>"UZBEKISTAN"</font>,<font color=#004488>"Tashkent"</font>},
    <font color=#009900>// Europe </font>
    {<font color=#004488>"ALBANIA"</font>,<font color=#004488>"Tirana"</font>}, {<font color=#004488>"ANDORRA"</font>,<font color=#004488>"Andorra la Vella"</font>},
    {<font color=#004488>"AUSTRIA"</font>,<font color=#004488>"Vienna"</font>}, {<font color=#004488>"BELGIUM"</font>,<font color=#004488>"Brussels"</font>},
    {<font color=#004488>"BOSNIA"</font>,<font color=#004488>"-"</font>}, {<font color=#004488>"HERZEGOVINA"</font>,<font color=#004488>"Sarajevo"</font>},
    {<font color=#004488>"CROATIA"</font>,<font color=#004488>"Zagreb"</font>}, {<font color=#004488>"CZECH REPUBLIC"</font>,<font color=#004488>"Prague"</font>},
    {<font color=#004488>"DENMARK"</font>,<font color=#004488>"Copenhagen"</font>}, {<font color=#004488>"ESTONIA"</font>,<font color=#004488>"Tallinn"</font>},
    {<font color=#004488>"FINLAND"</font>,<font color=#004488>"Helsinki"</font>}, {<font color=#004488>"FRANCE"</font>,<font color=#004488>"Paris"</font>},
    {<font color=#004488>"GERMANY"</font>,<font color=#004488>"Berlin"</font>}, {<font color=#004488>"GREECE"</font>,<font color=#004488>"Athens"</font>},
    {<font color=#004488>"HUNGARY"</font>,<font color=#004488>"Budapest"</font>}, {<font color=#004488>"ICELAND"</font>,<font color=#004488>"Reykjavik"</font>},
    {<font color=#004488>"IRELAND"</font>,<font color=#004488>"Dublin"</font>}, {<font color=#004488>"ITALY"</font>,<font color=#004488>"Rome"</font>},
    {<font color=#004488>"LATVIA"</font>,<font color=#004488>"Riga"</font>}, {<font color=#004488>"LIECHTENSTEIN"</font>,<font color=#004488>"Vaduz"</font>},
    {<font color=#004488>"LITHUANIA"</font>,<font color=#004488>"Vilnius"</font>}, {<font color=#004488>"LUXEMBOURG"</font>,<font color=#004488>"Luxembourg"</font>},
    {<font color=#004488>"MACEDONIA"</font>,<font color=#004488>"Skopje"</font>}, {<font color=#004488>"MALTA"</font>,<font color=#004488>"Valletta"</font>},
    {<font color=#004488>"MONACO"</font>,<font color=#004488>"Monaco"</font>}, {<font color=#004488>"MONTENEGRO"</font>,<font color=#004488>"Podgorica"</font>},
    {<font color=#004488>"THE NETHERLANDS"</font>,<font color=#004488>"Amsterdam"</font>}, {<font color=#004488>"NORWAY"</font>,<font color=#004488>"Oslo"</font>},
    {<font color=#004488>"POLAND"</font>,<font color=#004488>"Warsaw"</font>}, {<font color=#004488>"PORTUGAL"</font>,<font color=#004488>"Lisbon"</font>},
    {<font color=#004488>"ROMANIA"</font>,<font color=#004488>"Bucharest"</font>}, {<font color=#004488>"SAN MARINO"</font>,<font color=#004488>"San Marino"</font>},
    {<font color=#004488>"SERBIA"</font>,<font color=#004488>"Belgrade"</font>}, {<font color=#004488>"SLOVAKIA"</font>,<font color=#004488>"Bratislava"</font>},
    {<font color=#004488>"SLOVENIA"</font>,<font color=#004488>"Ljujiana"</font>}, {<font color=#004488>"SPAIN"</font>,<font color=#004488>"Madrid"</font>},
    {<font color=#004488>"SWEDEN"</font>,<font color=#004488>"Stockholm"</font>}, {<font color=#004488>"SWITZERLAND"</font>,<font color=#004488>"Berne"</font>},
    {<font color=#004488>"UNITED KINGDOM"</font>,<font color=#004488>"London"</font>}, {<font color=#004488>"VATICAN CITY"</font>,<font color=#004488>"---"</font>},
    <font color=#009900>// North and Central America</font>
    {<font color=#004488>"ANTIGUA AND BARBUDA"</font>,<font color=#004488>"Saint John's"</font>}, {<font color=#004488>"BAHAMAS"</font>,<font color=#004488>"Nassau"</font>},
    {<font color=#004488>"BARBADOS"</font>,<font color=#004488>"Bridgetown"</font>}, {<font color=#004488>"BELIZE"</font>,<font color=#004488>"Belmopan"</font>},
    {<font color=#004488>"CANADA"</font>,<font color=#004488>"Ottawa"</font>}, {<font color=#004488>"COSTA RICA"</font>,<font color=#004488>"San Jose"</font>},
    {<font color=#004488>"CUBA"</font>,<font color=#004488>"Havana"</font>}, {<font color=#004488>"DOMINICA"</font>,<font color=#004488>"Roseau"</font>},
    {<font color=#004488>"DOMINICAN REPUBLIC"</font>,<font color=#004488>"Santo Domingo"</font>},
    {<font color=#004488>"EL SALVADOR"</font>,<font color=#004488>"San Salvador"</font>}, {<font color=#004488>"GRENADA"</font>,<font color=#004488>"Saint George's"</font>},
    {<font color=#004488>"GUATEMALA"</font>,<font color=#004488>"Guatemala City"</font>}, {<font color=#004488>"HAITI"</font>,<font color=#004488>"Port-au-Prince"</font>},
    {<font color=#004488>"HONDURAS"</font>,<font color=#004488>"Tegucigalpa"</font>}, {<font color=#004488>"JAMAICA"</font>,<font color=#004488>"Kingston"</font>},
    {<font color=#004488>"MEXICO"</font>,<font color=#004488>"Mexico City"</font>}, {<font color=#004488>"NICARAGUA"</font>,<font color=#004488>"Managua"</font>},
    {<font color=#004488>"PANAMA"</font>,<font color=#004488>"Panama City"</font>}, {<font color=#004488>"ST. KITTS"</font>,<font color=#004488>"-"</font>},
    {<font color=#004488>"NEVIS"</font>,<font color=#004488>"Basseterre"</font>}, {<font color=#004488>"ST. LUCIA"</font>,<font color=#004488>"Castries"</font>},
    {<font color=#004488>"ST. VINCENT AND THE GRENADINES"</font>,<font color=#004488>"Kingstown"</font>},
    {<font color=#004488>"UNITED STATES OF AMERICA"</font>,<font color=#004488>"Washington, D.C."</font>},
    <font color=#009900>// South America</font>
    {<font color=#004488>"ARGENTINA"</font>,<font color=#004488>"Buenos Aires"</font>},
    {<font color=#004488>"BOLIVIA"</font>,<font color=#004488>"Sucre (legal)</font><font color=#004488>/La Paz(administrative)"</font>},
    {<font color=#004488>"BRAZIL"</font>,<font color=#004488>"Brasilia"</font>}, {<font color=#004488>"CHILE"</font>,<font color=#004488>"Santiago"</font>},
    {<font color=#004488>"COLOMBIA"</font>,<font color=#004488>"Bogota"</font>}, {<font color=#004488>"ECUADOR"</font>,<font color=#004488>"Quito"</font>},
    {<font color=#004488>"GUYANA"</font>,<font color=#004488>"Georgetown"</font>}, {<font color=#004488>"PARAGUAY"</font>,<font color=#004488>"Asuncion"</font>},
    {<font color=#004488>"PERU"</font>,<font color=#004488>"Lima"</font>}, {<font color=#004488>"SURINAME"</font>,<font color=#004488>"Paramaribo"</font>},
    {<font color=#004488>"TRINIDAD AND TOBAGO"</font>,<font color=#004488>"Port of Spain"</font>},
    {<font color=#004488>"URUGUAY"</font>,<font color=#004488>"Montevideo"</font>}, {<font color=#004488>"VENEZUELA"</font>,<font color=#004488>"Caracas"</font>},
  };
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is simply a two-dimensional array of
<B>String</B>
data</FONT><A NAME="fnB48" HREF="#fn48">[48]</A><FONT FACE="Georgia">.
Here&#8217;s a simple test using the <B>fill(&#160;)</B> methods and
generators:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FillTest.java</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FillTest {
  <font color=#0000ff>static</font> Generator sg = 
    <font color=#0000ff>new</font> Arrays2.RandStringGenerator(7);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, sg, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    List list2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list2, 
      Collections2.capitals, 25);
    System.out.println(list2 + <font color=#004488>"\n"</font>);
    Set set = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(set, sg, 25);
    System.out.println(set + <font color=#004488>"\n"</font>);
    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m, Collections2.rsp, 25);
    System.out.println(m + <font color=#004488>"\n"</font>);
    Map m2 = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m2, 
      Collections2.geography, 25);
    System.out.println(m2);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With these tools you can easily test the
various containers by filling them with interesting data.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I63' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I64>
</FONT><A NAME="_Toc481064679"></A><BR></P></DIV>
<A NAME="Heading292"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Container disadvantage: <BR>unknown type</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;disadvantage&#8221; to using
the Java containers is that you lose type information when you put an object
into a container. This happens because the programmer of that container class
had no idea what specific type you wanted to put in the container, and making
the container hold only your type would prevent it from being a general-purpose
tool. So instead, the container holds references to <B>Object</B>, which is the
root of all the classes so it holds any type. (Of course, this doesn&#8217;t
include primitive types, since they aren&#8217;t inherited from anything.) This
is a great solution, except: <A NAME="Index916"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I64' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I65>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Since the type information
is thrown away when you put an object reference into a container, there&#8217;s
no restriction on the type of object that can be put into your container, even
if you mean it to hold only, say, cats. Someone could just as easily put a dog
into the container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I65' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I66>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Since
the type information is lost, the only thing the container knows that it holds
is a reference to an object. You must perform a cast to the correct type before
you use it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I66' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I67>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">On
the up side, Java won&#8217;t let you <I>misuse</I> the objects that you put
into a container. If you throw a dog into a container of cats and then try to
treat everything in the container as a cat, you&#8217;ll get a run-time
exception when you pull the dog reference out of the cat container and try to
cast it to a cat. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I67' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I68>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example using the basic
workhorse container, <B>ArrayList</B>. For starters, you can think of
<B>ArrayList</B> as &#8220;an array that automatically expands itself.&#8221;
Using an <B>ArrayList</B> is straightforward: create one, put objects in using
<A NAME="Index917"></A><A NAME="Index918"></A><B>add(&#160;),</B> and later get
them out with <A NAME="Index919"></A><A NAME="Index920"></A><B>get(&#160;)
</B>using an index&#8212;just like you would with an array but without the
square
brackets</FONT><A NAME="fnB49" HREF="#fn49">[49]</A><FONT FACE="Georgia">.
<B>ArrayList</B> also has a method
<A NAME="Index921"></A><A NAME="Index922"></A><B>size(&#160;)</B> to let you
know how many elements have been added so you don&#8217;t inadvertently run off
the end and cause an exception.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I68' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I69>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, <B>Cat</B> and <B>Dog</B> classes
are created:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Cat.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Cat {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> catNumber;
  Cat(<font color=#0000ff>int</font> i) { catNumber = i; }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Cat #"</font> + catNumber);
  }
} <font color=#009900>///:~</font>

<font color=#009900>//: c09:Dog.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Dog {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> dogNumber;
  Dog(<font color=#0000ff>int</font> i) { dogNumber = i; }
  <font color=#0000ff>void</font> print() {
    System.out.println(<font color=#004488>"Dog #"</font> + dogNumber);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Cat</B>s and <B>Dog</B>s are placed
into the container, then pulled out:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CatsAndDogs.java</font>
<font color=#009900>// Simple container example.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    <font color=#009900>// Not a problem to add a dog to cats:</font>
    cats.add(<font color=#0000ff>new</font> Dog(7));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cats.size(); i++)
      ((Cat)cats.get(i)).print();
    <font color=#009900>// Dog is detected only at run-time</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The classes <B>Cat</B> and <B>Dog</B> are
distinct&#8212;they have nothing in common except that they are <B>Object</B>s.
(If you don&#8217;t explicitly say what class you&#8217;re inheriting from, you
automatically inherit from <B>Object</B>.) Since <B>ArrayList</B> holds
<B>Object</B>s, you can not only put <B>Cat</B> objects into this container
using the <B>ArrayList </B>method <B>add(&#160;)</B>, but you can also add
<B>Dog</B> objects without complaint at either compile-time or run-time. When
you go to fetch out what you think are <B>Cat</B> objects using the
<B>ArrayList</B> method <B>get(&#160;)</B>, you get back a reference to an
object that you must cast to a <B>Cat</B>. Then you need to surround the entire
expression with parentheses to force the evaluation of the cast before calling
the <B>print(&#160;)</B> method for <B>Cat</B>, otherwise you&#8217;ll get a
syntax error. Then, at run-time, when you try to cast the <B>Dog</B> object to a
<B>Cat</B>, you&#8217;ll get an exception.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I69' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I70>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is more than just an annoyance.
It&#8217;s something that can create difficult-to-find bugs. If one part (or
several parts) of a program inserts objects into a container, and you discover
only in a separate part of the program through an exception that a bad object
was placed in the container, then you must find out where the bad insert
occurred. On the upside, it&#8217;s convenient to start with some standardized
container classes for programming, despite the scarcity and awkwardness.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I70' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I71>
</FONT><A NAME="_Toc481064680"></A><BR></P></DIV>
<A NAME="Heading293"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Sometimes it works anyway</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out that in some cases things
seem to work correctly without casting back to your original type. One case is
quite special: the <B>String</B> class has some extra help from the compiler to
make it work smoothly. Whenever the compiler expects a <B>String</B> object and
it hasn&#8217;t got one, it will automatically call the
<A NAME="Index923"></A><A NAME="Index924"></A><B>toString(&#160;)</B> method
that&#8217;s defined in <B>Object</B> and can be overridden by any Java class.
This method produces the desired <B>String</B> object, which is then used
wherever it was wanted. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I71' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I72>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, all you need to do to make objects
of your class print is to override the <B>toString(&#160;)</B> method, as shown
in the following example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Mouse.java</font>
<font color=#009900>// Overriding toString().</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> Mouse {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> mouseNumber;
  Mouse(<font color=#0000ff>int</font> i) { mouseNumber = i; }
  <font color=#009900>// Override Object.toString():</font>
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Mouse #"</font> + mouseNumber;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> getNumber() {
    <font color=#0000ff>return</font> mouseNumber;
  }
} <font color=#009900>///:~</font>

<font color=#009900>//: c09:WorksAnyway.java</font>
<font color=#009900>// In special cases, things just </font>
<font color=#009900>// seem to work correctly.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MouseTrap {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> caughtYa(Object m) {
    Mouse mouse = (Mouse)m; <font color=#009900>// Cast from Object</font>
    System.out.println(<font color=#004488>"Mouse: "</font> + 
      mouse.getNumber());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> WorksAnyway {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList mice = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++) {
      <font color=#009900>// No cast necessary, automatic </font>
      <font color=#009900>// call to Object.toString():</font>
      System.out.println(
        <font color=#004488>"Free mouse: "</font> + mice.get(i));
      MouseTrap.caughtYa(mice.get(i));
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see <B>toString(&#160;)</B>
overridden in <B>Mouse</B>. In the second <B>for</B> loop in <B>main(&#160;)</B>
you find the statement:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println(<font color=#004488>"Free mouse: "</font> + mice.get(i));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the &#8216;<B>+</B>&#8217; sign the
compiler expects to see a
<A NAME="Index925"></A><A NAME="Index926"></A><B>String</B> object.
<B>get(&#160;)</B> produces an <B>Object</B>, so to get the desired
<B>String</B> the compiler implicitly calls <B>toString(&#160;)</B>.
Unfortunately, you can work this kind of magic only with <B>String</B>; it
isn&#8217;t available for any other type.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I72' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I73>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A second approach to hiding the cast has
been placed inside <B>MouseTrap</B>. The <B>caughtYa(&#160;)</B> method accepts
not a <B>Mouse</B>, but an <B>Object,</B> which it then casts to a <B>Mouse</B>.
This is quite presumptuous, of course, since by accepting an <B>Object</B>
anything could be passed to the method. However, if the cast is
incorrect&#8212;if you passed the wrong type&#8212;you&#8217;ll get an exception
at run-time. This is not as good as compile-time checking but it&#8217;s still
robust. Note that in the use of this method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>MouseTrap.caughtYa(mice.get(i));</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">no cast is necessary.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I73' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I74>
</FONT><A NAME="_Toc481064681"></A><BR></P></DIV>
<A NAME="Heading294"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making a type-conscious
ArrayList<BR><A NAME="Index927"></A><A NAME="Index928"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might not want to give up on this
issue just yet. A more ironclad solution is to create a new class using the
<B>ArrayList</B>, such that it will accept only your type and produce only your
type:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MouseList.java</font>
<font color=#009900>// A type-conscious ArrayList.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseList {
  <font color=#0000ff>private</font> ArrayList list = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> add(Mouse m) {
    list.add(m);
  }
  <font color=#0000ff>public</font> Mouse get(<font color=#0000ff>int</font> index) {
    <font color=#0000ff>return</font> (Mouse)list.get(index);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> size() { <font color=#0000ff>return</font> list.size(); }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a test for the new
container:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MouseListTest.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> MouseListTest {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    MouseList mice = <font color=#0000ff>new</font> MouseList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      mice.add(<font color=#0000ff>new</font> Mouse(i));
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; mice.size(); i++)
      MouseTrap.caughtYa(mice.get(i));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is similar to the previous example,
except that the new <B>MouseList</B> class has a <B>private </B>member of type
<B>ArrayList</B>, and methods just like <B>ArrayList</B>. However, it
doesn&#8217;t accept and produce generic <B>Object</B>s, only <B>Mouse</B>
objects.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I74' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I75>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that if <B>MouseList</B> had instead
been <I>inherited</I> from <B>ArrayList</B>, the <B>add(Mouse)</B> method would
simply overload the existing <B>add(Object)</B> and there would still be no
restriction on what type of objects could be added. Thus, the <B>MouseList</B>
becomes a <I>surrogate</I> to the <B>ArrayList</B>, performing some activities
before passing on the responsibility (see <I>Thinking in Patterns with Java</I>,
downloadable at <I>www.BruceEckel.com</I>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I75' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I76>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because a <B>MouseList</B> will accept
only a <B>Mouse</B>, if you say:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>mice.add(<font color=#0000ff>new</font> Pigeon());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">you will get an error message <I>at
compile-time</I>. This approach, while more tedious from a coding standpoint,
will tell you immediately if you&#8217;re using a type improperly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I76' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I77>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that no cast is necessary when using
<B>get(&#160;)</B>&#8212;it&#8217;s always a <B>Mouse</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I77' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I78>
</FONT><BR></P></DIV>
<A NAME="Heading295"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Parameterized types</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This kind of problem isn&#8217;t
isolated&#8212;there are numerous cases in which you need to create new types
based on other types, and in which it is useful to have specific type
information at compile-time. This is the concept of a
<A NAME="Index929"></A><A NAME="Index930"></A><I>parameterized type</I>. In C++,
this is directly supported by the language with
<A NAME="Index931"></A><A NAME="Index932"></A><I>templates</I>. It is likely
that a future version of Java will support some variation of parameterized
types; the current front-runner automatically creates classes similar to
<B>MouseList</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I78' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I79>
</FONT><A NAME="_Toc375545352"></A><A NAME="_Toc481064682"></A><BR></P></DIV>
<A NAME="Heading296"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Iterators</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In any container class, you must have a
way to put things in and a way to get things out. After all, that&#8217;s the
primary job of a container&#8212;to hold things. In the
<A NAME="Index933"></A><B>ArrayList</B>, <B>add(&#160;)</B> is the way that you
insert objects, and <B>get(&#160;)</B> is <I>one</I> way to get things out.
<B>ArrayList</B> is quite flexible&#8212;you can select anything at any time,
and select multiple elements at once using different
indexes.<A NAME="Index934"></A><A NAME="Index935"></A>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I79' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I80>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to start thinking at a higher
level, there&#8217;s a drawback: you need to know the exact type of the
container in order to use it. This might not seem bad at first, but what if you
start out using an <B>ArrayList</B>, and later on in your program you discover
that because of the way you are using the container it would be much more
efficient to use a <B>LinkedList</B> instead? Or suppose you&#8217;d like to
write a piece of generic code that doesn&#8217;t know or care what type of
container it&#8217;s working with, so that it could be used on different types
of containers without rewriting that code?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I80' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I81>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept of an
<A NAME="Index936"></A><I>iterator</I> can be used to achieve this abstraction.
An iterator is an object whose job is to move through a sequence of objects and
select each object in that sequence without the client programmer knowing or
caring about the underlying structure of that sequence. In addition, an iterator
is usually what&#8217;s called a &#8220;light-weight&#8221; object: one
that&#8217;s cheap to create. For that reason, you&#8217;ll often find seemingly
strange constraints for iterators; for example, some iterators can move in only
one direction. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I81' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I82>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java <B>Iterator</B> is an example of
an iterator with these kinds of constraints. There&#8217;s not much you can do
with one except<A NAME="Index937"></A>:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I82' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I83>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Ask a container to hand
you an <B>Iterator</B> using a method called <B>iterator(&#160;)</B>.<B>
</B>This <B>Iterator </B>will be ready to return the first element in the
sequence on your first call to its <B>next(&#160;)</B>
method.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Get the next
object in the sequence with
<B>next(&#160;)</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">See
if there <I>are</I> any more objects in the sequence with
<B>hasNext(&#160;)</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Remove
the last element returned by the iterator with
<B>remove(&#160;)</B>.</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">That&#8217;s
all. It&#8217;s a simple implementation of an iterator, but still powerful (and
there&#8217;s a more sophisticated <B>ListIterator</B> for <B>List</B>s). To see
how it works, let&#8217;s revisit the <B>CatsAndDogs.java</B> program from
earlier in this chapter. In the original version, the method <B>get(&#160;)</B>
was used to select each element, but in the following modified version an
Iterator is used: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I83' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I84>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CatsAndDogs2.java</font>
<font color=#009900>// Simple container with Iterator.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CatsAndDogs2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList cats = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 7; i++)
      cats.add(<font color=#0000ff>new</font> Cat(i));
    Iterator e = cats.iterator();
    <font color=#0000ff>while</font>(e.hasNext())
      ((Cat)e.next()).print();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that the last few lines now
use an <B>Iterator</B> to step through the sequence instead of a <B>for</B>
loop. With the <B>Iterator</B>, you don&#8217;t need to worry about the number
of elements in the container. That&#8217;s taken care of for you by
<A NAME="Index938"></A><A NAME="Index939"></A><B>hasNext(&#160;)</B> and
<A NAME="Index940"></A><A NAME="Index941"></A><B>next(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I84' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I85>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As another example, consider the creation
of a general-purpose printing method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:HamsterMaze.java</font>
<font color=#009900>// Using an Iterator.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Hamster {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> hamsterNumber;
  Hamster(<font color=#0000ff>int</font> i) { hamsterNumber = i; }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"This is Hamster #"</font> + hamsterNumber;
  }
}

<font color=#0000ff>class</font> Printer {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printAll(Iterator e) {
    <font color=#0000ff>while</font>(e.hasNext())
      System.out.println(e.next());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> HamsterMaze {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 3; i++)
      v.add(<font color=#0000ff>new</font> Hamster(i));
    Printer.printAll(v.iterator());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Look closely at <B>printAll(&#160;)</B>.
Note that there&#8217;s no information about the type of sequence. All you have
is an <B>Iterator</B>, and that&#8217;s all you need to know about the sequence:
that you can get the next object, and that you can know when you&#8217;re at the
end. This idea of taking a container of objects and passing through it to
perform an operation on each one is powerful, and will be seen throughout this
book. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I85' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I86>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index942"></A><A NAME="Index943"></A><A NAME="Index944"></A><FONT FACE="Georgia">The
example is even more generic, since it implicitly uses the
<B>Object.toString(&#160;)</B> method. The <B>println(&#160;)</B> method is
overloaded for all the primitive types as well as <B>Object</B>; in each case a
<B>String</B> is automatically produced by calling the appropriate
<B>toString(&#160;)</B> method. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I86' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I87>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although it&#8217;s unnecessary, you can
be more explicit using a cast, which has the effect of calling
<B>toString(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>System.out.println((String)e.next());</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, however, you&#8217;ll want to
do something more than call <B>Object</B> methods, so you&#8217;ll run up
against the type-casting issue again. You must assume you&#8217;ve gotten an
<B>Iterator</B> to a sequence of the particular type you&#8217;re interested in,
and cast the resulting objects to that type (getting a run-time exception if
you&#8217;re wrong). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I87' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I88>
</FONT><BR></P></DIV>
<A NAME="Heading297"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Unintended recursion</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because (like every other class),
<A NAME="Index945"></A>the Java standard containers are inherited from
<B>Object</B>, they<B> </B>contain a <B>toString(&#160;)</B> method. This has
been overridden so that they can produce a <B>String</B> representation of
themselves, including the objects they hold. Inside <B>ArrayList</B>, for
example, the <B>toString(&#160;)</B> steps through the elements of the
<B>ArrayList</B> and calls <B>toString(&#160;)</B> for each one. Suppose
you&#8217;d like to print the address of your class. It seems to make sense to
simply refer to <B>this </B>(in particular, C++ programmers are prone to this
approach):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:InfiniteRecursion.java</font>
<font color=#009900>// Accidental recursion.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> InfiniteRecursion {
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>" InfiniteRecursion address: "</font> 
      + <font color=#0000ff>this</font> + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      v.add(<font color=#0000ff>new</font> InfiniteRecursion());
    System.out.println(v);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you simply create an
<B>InfiniteRecursion</B> object and then print it, you&#8217;ll get an endless
sequence of exceptions. This is also true if you place the
<B>InfiniteRecursion</B> objects in an <B>ArrayList</B> and print that
<B>ArrayList</B> as shown here. What&#8217;s happening is automatic type
conversion for <B>String</B>s. When you say: </FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#004488>"InfiniteRecursion address: "</font> + <font color=#0000ff>this</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler sees a <B>String</B>
followed by a &#8216;<B>+</B>&#8217; and<B> </B>something that&#8217;s not a
<B>String</B>, so it tries to convert <B>this</B> to a <B>String</B>. It does
this conversion by calling <B>toString(&#160;)</B>, which produces a
<A NAME="Index946"></A>recursive call. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I88' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I89>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you really do want to print the
address of the object in this case, the solution is to call the <B>Object</B>
<B>toString(&#160;)</B> method, which does just that. So instead of saying
<B>this</B>, you&#8217;d say <B>super.toString(&#160;)</B>. (This only works if
you're directly inheriting from <B>Object</B>, or if none of your parent classes
have overridden the <B>toString(&#160;)</B> method.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I89' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I90>
</FONT><A NAME="_Toc375545359"></A><A NAME="_Toc481064683"></A><BR></P></DIV>
<A NAME="Heading298"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Container taxonomy</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Collection</B>s and <B>Map</B>s may be
implemented in different ways, according to your programming needs. It&#8217;s
helpful to look at a diagram of the Java 2 containers:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ225.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This diagram can be a bit overwhelming at
first, but you&#8217;ll see that there are really only three container
components: <B>Map</B>, <B>List</B>, and <B>Set</B>, and only two or three
implementations of each one (with, typically, a preferred version). When you see
this, the containers are not so daunting.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I90' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I91>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The dotted boxes represent
<B>interface</B>s, the dashed boxes represent <B>abstract</B> classes, and the
solid boxes are regular (concrete) classes. The dotted-line arrows indicate that
a particular class is implementing an <B>interface</B> (or in the case of an
<B>abstract</B> class, partially implementing that <B>interface</B>). The solid
arrows show that a class can produce objects of the class the arrow is pointing
to. For example, any <B>Collection</B> can produce an <B>Iterator</B>, while a
<B>List</B> can produce a <B>ListIterator</B> (as well as an ordinary
<B>Iterator</B>, since <B>List</B> is inherited from <B>Collection</B>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I91' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I92>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The interfaces that are concerned with
holding objects are <B>Collection</B>, <B>List</B>, <B>Set</B>, and
<B>Map</B>.<B> </B>Ideally, you&#8217;ll write most of your code to talk to
these interfaces, and the only place where you&#8217;ll specify the precise type
you&#8217;re using is at the point of creation. So you can create a <B>List</B>
like this: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I92' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I93>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> LinkedList();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, you can also decide to make
<B>x </B>a <B>LinkedList </B>(instead of a generic <B>List</B>)<B> </B>and carry
the precise type information around with <B>x</B>. The beauty (and the intent)
of using the <B>interface</B> is that if you decide you want to change your
implementation, all you need to do is change it at the point of creation, like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>List x = <font color=#0000ff>new</font> ArrayList();</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of your code can remain
untouched (some of this genericity can also be achieved with iterators).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I93' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I94>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the class hierarchy, you can see a
number of classes whose names begin with &#8220;<B>Abstract</B>,&#8221; and
these can seem a bit confusing at first. They are simply tools that partially
implement a particular interface. If you were making your own <B>Set</B>, for
example, you wouldn&#8217;t start with the <B>Set</B> interface and implement
all the methods, instead you&#8217;d inherit from
<A NAME="Index947"></A><B>AbstractSet</B> and do the minimal necessary work to
make your new class. However, the containers library contains enough
functionality to satisfy your needs virtually all the time. So for our purposes,
you can ignore any class that begins with &#8220;<B>Abstract</B>.&#8221;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I94' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I95>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Therefore, when you look at the diagram,
you&#8217;re really concerned with only those <B>interface</B>s at the top of
the diagram and the concrete classes (those with solid boxes around them).
You&#8217;ll typically make an object of a concrete class, upcast it to the
corresponding <B>interface</B>, and then use the <B>interface</B> throughout the
rest of your code. In addition, you do not need to consider the legacy elements
when writing new code. Therefore, the diagram can be greatly simplified to look
like this:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><FONT FACE="Georgia"><IMG SRC="TIJ226.gif"></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now it only includes the interfaces and
classes that you will encounter on a regular basis, and also the elements that
we will focus on in this chapter.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I95' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I96>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple example, which
fills a <B>Collection</B> (represented here with an <B>ArrayList</B>) with
<B>String</B> objects, and then prints each element in the
<B>Collection</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SimpleCollection.java</font>
<font color=#009900>// A simple example using Java 2 Collections.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleCollection {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Upcast because we just want to</font>
    <font color=#009900>// work with Collection features</font>
    Collection c = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      c.add(Integer.toString(i));
    Iterator it = c.iterator();
    <font color=#0000ff>while</font>(it.hasNext())
      System.out.println(it.next());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first line in <B>main(&#160;)</B>
creates an <A NAME="Index948"></A><B>ArrayList</B> object and then upcasts it to
a <B>Collection</B>. Since this example uses only the <B>Collection </B>methods,
any object of a class inherited from <B>Collection</B> would work, but
<B>ArrayList</B> is the typical workhorse <B>Collection</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I96' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I97>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>add(&#160;)</B> method, as its
name suggests, puts a new element in the <B>Collection</B>. However, the
documentation carefully states that <B>add(&#160;)</B> &#8220;ensures that this
Container contains the specified element.&#8221; This is to allow for the
meaning of <B>Set</B>, which adds the element only if it isn&#8217;t already
there. With an <B>ArrayList</B>, or any sort of <B>List</B>, <B>add(&#160;)</B>
always means &#8220;put it in,&#8221; because <B>List</B>s don&#8217;t care if
there are duplicates. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I97' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I98>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All <B>Collection</B>s can produce an
<A NAME="Index949"></A><B>Iterator</B> via their
<A NAME="Index950"></A><B>iterator(&#160;)</B> method. Here, an <B>Iterator</B>
is created and used to traverse the <B>Collection</B>, printing each element.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I98' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I99>
</FONT><A NAME="_Toc481064684"></A><BR></P></DIV>
<A NAME="Heading299"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Collection functionality</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following table shows everything you
can do with a <B>Collection</B> (not including the methods that automatically
come through with <B>Object</B>), and thus, everything you can do with a
<B>Set</B> or a <B>List</B>. (<B>List</B> also has additional functionality.)
<B>Map</B>s are not inherited from <B>Collection</B>, and will be treated
separately.</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
add(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ensures that the container holds the
argument. Returns false if it doesn&#8217;t add the argument. (This is an
&#8220;optional&#8221; method, described later in this
chapter.)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
</B></FONT><BR><FONT FACE="Georgia"><B>addAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Adds all the elements in the argument.
Returns <B>true</B> if any elements were added.
(&#8220;Optional.&#8221;)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>void
clear(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Removes all the elements in the
container. (&#8220;Optional.&#8221;)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
</B></FONT><BR><FONT FACE="Georgia"><B>contains(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>true</B> if the container holds the
argument. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
containsAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>true</B> if the container holds all
the elements in the argument. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
isEmpty(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>true</B> if the container has no
elements. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Iterator
iterator(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an <B>Iterator</B> that you can
use to move through the elements in the container. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
</B></FONT><BR><FONT FACE="Georgia"><B>remove(Object)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the argument is in the container, one
instance of that element is removed. Returns <B>true</B> if a removal occurred.
(&#8220;Optional.&#8221;)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
removeAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Removes all the elements that are
contained in the argument. Returns <B>true</B> if any removals occurred.
(&#8220;Optional.&#8221;)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>boolean
retainAll(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Retains only elements that are contained
in the argument (an &#8220;intersection&#8221; from set theory). Returns
<B>true</B> if any changes occurred. (&#8220;Optional.&#8221;)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>int size(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns the number of elements in the
container. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object[]
toArray(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an array containing all the
elements in the container.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object[]
</B></FONT><BR><FONT FACE="Georgia"><B>toArray(Object[] a)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an array containing all the
elements in the container, whose type is that of the array a rather than plain
<B>Object</B> (you must cast the array to the right type).</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that there&#8217;s no
<B>get(&#160;)</B> function for random-access element selection. That&#8217;s
because <B>Collection</B> also includes <B>Set</B>, which maintains its own
internal ordering (and thus makes random-access lookup meaningless). Thus, if
you want to examine all the elements of a <B>Collection</B> you must use an
iterator; that&#8217;s the only way to fetch things back.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example demonstrates all of
these methods. Again, these work with anything that inherits from
<B>Collection</B>, but an <B>ArrayList</B> is used as a kind of
&#8220;least-common denominator&#8221;:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I99' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I100>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Collection1.java</font>
<font color=#009900>// Things you can do with all Collections.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Collection1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, 
      Collections2.countries, 10);    
    c.add(<font color=#004488>"ten"</font>);
    c.add(<font color=#004488>"eleven"</font>);
    System.out.println(c);
    <font color=#009900>// Make an array from the List:</font>
    Object[] array = c.toArray(); 
    <font color=#009900>// Make a String array from the List:</font>
    String[] str = 
      (String[])c.toArray(<font color=#0000ff>new</font> String[1]);
    <font color=#009900>// Find max and min elements; this means</font>
    <font color=#009900>// different things depending on the way</font>
    <font color=#009900>// the Comparable interface is implemented:</font>
    System.out.println(<font color=#004488>"Collections.max(c) = "</font> +
      Collections.max(c));
    System.out.println(<font color=#004488>"Collections.min(c) = "</font> +
      Collections.min(c));
    <font color=#009900>// Add a Collection to another Collection</font>
    Collection c2 = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c2, 
      Collections2.countries, 10);    
    c.addAll(c2);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[0][0]);
    System.out.println(c);
    c.remove(CountryCapitals.pairs[1][0]);
    System.out.println(c);
    <font color=#009900>// Remove all components that are in the</font>
    <font color=#009900>// argument collection:</font>
    c.removeAll(c2);
    System.out.println(c);
    c.addAll(c2);
    System.out.println(c);
    <font color=#009900>// Is an element in this Collection?</font>
    String val = CountryCapitals.pairs[3][0];
    System.out.println(
      <font color=#004488>"c.contains("</font> + val  + <font color=#004488>") = "</font> 
      + c.contains(val));
    <font color=#009900>// Is a Collection in this Collection?</font>
    System.out.println(
      <font color=#004488>"c.containsAll(c2) = "</font>+ c.containsAll(c2));
    Collection c3 = ((List)c).subList(3, 5);
    <font color=#009900>// Keep all the elements that are in both</font>
    <font color=#009900>// c2 and c3 (an intersection of sets):</font>
    c2.retainAll(c3);
    System.out.println(c);
    <font color=#009900>// Throw away all the elements </font>
    <font color=#009900>// in c2 that also appear in c3:</font>
    c2.removeAll(c3);
    System.out.println(<font color=#004488>"c.isEmpty() = "</font> +
      c.isEmpty());
    c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, 
      Collections2.countries, 10);    
    System.out.println(c);
    c.clear(); <font color=#009900>// Remove all elements</font>
    System.out.println(<font color=#004488>"after c.clear():"</font>);
    System.out.println(c);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ArrayList</B>s are created containing
different sets of data and upcast to <B>Collection</B> objects, so it&#8217;s
clear that nothing other than the <B>Collection</B> interface is being used.
<B>main(&#160;)</B> uses simple exercises to show all of the methods in
<B>Collection</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I100' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I101>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following sections describe the
various implementations of <B>List</B>, <B>Set,</B> and <B>Map</B> and indicate
in each case (with an asterisk) which one should be your default choice.
You&#8217;ll notice that the legacy classes <B>Vector</B>, <B>Stack</B>, and
<B>Hashtable</B> are <I>not</I> included because in all cases there are
preferred classes within the Java 2 Containers.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I101' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I102>
</FONT><A NAME="_Toc481064685"></A><BR></P></DIV>
<A NAME="Heading300"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
List
functionality<BR><A NAME="Index951"></A><A NAME="Index952"></A><A NAME="Index953"></A><A NAME="Index954"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic <B>List</B> is quite simple to
use, as you&#8217;ve seen so far with <B>ArrayList</B>. Although most of the
time you&#8217;ll just use <B>add(&#160;)</B> to insert objects,
<B>get(&#160;)</B> to get them out one at a time, and <B>iterator(&#160;)</B> to
get an <B>Iterator</B> to the sequence, there&#8217;s also a set of other
methods that can be useful. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I102' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I103>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, there are actually two types
of <B>List</B>: the basic <B>ArrayList</B>, which excels at randomly accessing
elements, and the much more powerful <B>LinkedList</B> (which is not designed
for fast random access, but has a much more general set of
methods).</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>List</B> (interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Order is the most important feature of a
<B>List</B>; it promises to maintain elements in a particular sequence.
<B>List</B> adds a number of methods to <B>Collection</B> that allow insertion
and removal of elements in the middle of a <B>List</B>. (This is recommended
only for a <B>LinkedList</B>.) A <B>List</B> will produce a <B>ListIterator</B>,
and using this you can traverse the <B>List</B> in both directions, as well as
insert and remove elements in the middle of the <B>List</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ArrayList</B>*</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>List</B> implemented with an array.
Allows rapid random access to elements, but is slow when inserting and removing
elements from the middle of a list. <B>ListIterator</B> should be used only for
back-and-forth traversal of an <B>ArrayList</B>, but not for inserting and
removing elements, which is expensive compared to
<B>LinkedList</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LinkedList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Provides optimal sequential access, with
inexpensive insertions and deletions from the middle of the <B>List</B>.
Relatively slow for random access. (Use <B>ArrayList</B> instead.) Also has
<B>addFirst(&#160;)</B>, <B>addLast(&#160;)</B>, <B>getFirst(&#160;)</B>,
<B>getLast(&#160;)</B>, <B>removeFirst(&#160;)</B>, and
<B>removeLast(&#160;)</B> (which are not defined in any interfaces or base
classes) to allow it to be used as a stack, a queue, and a
deque.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The methods in the following example each
cover a different group of activities: things that every list can do
(<B>basicTest(&#160;)</B>), moving around with an <B>Iterator</B>
(<B>iterMotion(&#160;)</B>)<B> </B>versus changing things with an
<B>Iterator</B> (<B>iterManipulation(&#160;)</B>), seeing the effects of
<B>List</B> manipulation (<B>testVisual(&#160;)</B>), and operations available
only to <B>LinkedList</B>s.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:List1.java</font>
<font color=#009900>// Things you can do with Lists.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> List1 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> List fill(List a) {
    Collections2.countries.reset();
    Collections2.fill(a, 
      Collections2.countries, 10);
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>static</font> <font color=#0000ff>boolean</font> b;
  <font color=#0000ff>static</font> Object o;
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>static</font> Iterator it;
  <font color=#0000ff>static</font> ListIterator lit;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> basicTest(List a) {
    a.add(1, <font color=#004488>"x"</font>); <font color=#009900>// Add at location 1</font>
    a.add(<font color=#004488>"x"</font>); <font color=#009900>// Add at end</font>
    <font color=#009900>// Add a collection:</font>
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Add a collection starting at location 3:</font>
    a.addAll(3, fill(<font color=#0000ff>new</font> ArrayList())); 
    b = a.contains(<font color=#004488>"1"</font>); <font color=#009900>// Is it in there?</font>
    <font color=#009900>// Is the entire collection in there?</font>
    b = a.containsAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Lists allow random access, which is cheap</font>
    <font color=#009900>// for ArrayList, expensive for LinkedList:</font>
    o = a.get(1); <font color=#009900>// Get object at location 1</font>
    i = a.indexOf(<font color=#004488>"1"</font>); <font color=#009900>// Tell index of object</font>
    b = a.isEmpty(); <font color=#009900>// Any elements inside?</font>
    it = a.iterator(); <font color=#009900>// Ordinary Iterator</font>
    lit = a.listIterator(); <font color=#009900>// ListIterator</font>
    lit = a.listIterator(3); <font color=#009900>// Start at loc 3</font>
    i = a.lastIndexOf(<font color=#004488>"1"</font>); <font color=#009900>// Last match </font>
    a.remove(1); <font color=#009900>// Remove location 1</font>
    a.remove(<font color=#004488>"3"</font>); <font color=#009900>// Remove this object</font>
    a.set(1, <font color=#004488>"y"</font>); <font color=#009900>// Set location 1 to "y"</font>
    <font color=#009900>// Keep everything that's in the argument</font>
    <font color=#009900>// (the intersection of the two sets):</font>
    a.retainAll(fill(<font color=#0000ff>new</font> ArrayList()));
    <font color=#009900>// Remove everything that's in the argument:</font>
    a.removeAll(fill(<font color=#0000ff>new</font> ArrayList()));
    i = a.size(); <font color=#009900>// How big is it?</font>
    a.clear(); <font color=#009900>// Remove all elements</font>
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterMotion(List a) {
    ListIterator it = a.listIterator();
    b = it.hasNext();
    b = it.hasPrevious();
    o = it.next();
    i = it.nextIndex();
    o = it.previous();
    i = it.previousIndex();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> iterManipulation(List a) {
    ListIterator it = a.listIterator();
    it.add(<font color=#004488>"47"</font>);
    <font color=#009900>// Must move to an element after add():</font>
    it.next();
    <font color=#009900>// Remove the element that was just produced:</font>
    it.remove(); 
    <font color=#009900>// Must move to an element after remove():</font>
    it.next();
    <font color=#009900>// Change the element that was just produced:</font>
    it.set(<font color=#004488>"47"</font>);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(List a) {
    System.out.println(a);
    List b = <font color=#0000ff>new</font> ArrayList();
    fill(b);
    System.out.print(<font color=#004488>"b = "</font>);
    System.out.println(b);
    a.addAll(b);
    a.addAll(fill(<font color=#0000ff>new</font> ArrayList()));
    System.out.println(a);
    <font color=#009900>// Insert, remove, and replace elements</font>
    <font color=#009900>// using a ListIterator:</font>
    ListIterator x = a.listIterator(a.size()/2);
    x.add(<font color=#004488>"one"</font>); 
    System.out.println(a);
    System.out.println(x.next());
    x.remove();
    System.out.println(x.next());
    x.set(<font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Traverse the list backwards:</font>
    x = a.listIterator(a.size());
    <font color=#0000ff>while</font>(x.hasPrevious())
      System.out.print(x.previous() + <font color=#004488>" "</font>);
    System.out.println();
    System.out.println(<font color=#004488>"testVisual finished"</font>);
  }
  <font color=#009900>// There are some things that only</font>
  <font color=#009900>// LinkedLists can do:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testLinkedList() {
    LinkedList ll = <font color=#0000ff>new</font> LinkedList();
    fill(ll);
    System.out.println(ll);
    <font color=#009900>// Treat it like a stack, pushing:</font>
    ll.addFirst(<font color=#004488>"one"</font>);
    ll.addFirst(<font color=#004488>"two"</font>);
    System.out.println(ll);
    <font color=#009900>// Like "peeking" at the top of a stack:</font>
    System.out.println(ll.getFirst());
    <font color=#009900>// Like popping a stack:</font>
    System.out.println(ll.removeFirst());
    System.out.println(ll.removeFirst());
    <font color=#009900>// Treat it like a queue, pulling elements</font>
    <font color=#009900>// off the tail end:</font>
    System.out.println(ll.removeLast());
    <font color=#009900>// With the above operations, it's a dequeue!</font>
    System.out.println(ll);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#009900>// Make and fill a new list each time:</font>
    basicTest(fill(<font color=#0000ff>new</font> LinkedList()));
    basicTest(fill(<font color=#0000ff>new</font> ArrayList()));
    iterMotion(fill(<font color=#0000ff>new</font> LinkedList()));
    iterMotion(fill(<font color=#0000ff>new</font> ArrayList()));
    iterManipulation(fill(<font color=#0000ff>new</font> LinkedList()));
    iterManipulation(fill(<font color=#0000ff>new</font> ArrayList()));
    testVisual(fill(<font color=#0000ff>new</font> LinkedList()));
    testLinkedList();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>basicTest(&#160;)</B> and
<B>iterMotion(&#160;)</B> the calls are simply made to show the proper syntax,
and while the return value is captured, it is not used. In some cases, the
return value isn&#8217;t captured since it isn&#8217;t typically used. You
should look up the full usage of each of these methods in the online
documentation from <I>java.sun.com</I> before you use them.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I103' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I104>
</FONT><A NAME="_Toc481064686"></A><BR></P></DIV>
<A NAME="Heading301"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making a stack from a LinkedList</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <A NAME="Index955"></A>stack is
sometimes referred to as a &#8220;last-in, first-out&#8221;
(<A NAME="Index956"></A>LIFO) container. That is, whatever you
&#8220;push&#8221; on the stack last is the first item you can &#8220;pop&#8221;
out. Like all of the other containers in Java, what you push and pop are
<B>Object</B>s, so you must cast what you pop, unless you&#8217;re just using
<B>Object</B> behavior. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I104' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I105>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>LinkedList</B> has methods that
directly implement stack functionality, so you can also just use a
<B>LinkedList</B> rather than making a stack class. However, a stack class can
sometimes tell the story better:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I105' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I106>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:StackL.java</font>
<font color=#009900>// Making a stack from a LinkedList.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> StackL {
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> push(Object v) {
    list.addFirst(v);
  }
  <font color=#0000ff>public</font> Object top() { <font color=#0000ff>return</font> list.getFirst(); }
  <font color=#0000ff>public</font> Object pop() { 
    <font color=#0000ff>return</font> list.removeFirst(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    StackL stack = <font color=#0000ff>new</font> StackL();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      stack.push(Collections2.countries.next());
    System.out.println(stack.top());
    System.out.println(stack.top());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
    System.out.println(stack.pop());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want only stack behavior,
inheritance is inappropriate here because it would produce a class with all the
rest of the <B>LinkedList</B> methods (you&#8217;ll see later that this very
mistake was made by the Java 1.0 library designers with <B>Stack</B>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I106' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I107>
</FONT><A NAME="_Toc481064687"></A><BR></P></DIV>
<A NAME="Heading302"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making a queue from a LinkedList</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <A NAME="Index957"></A><I>queue</I> is
a &#8220;<I>first-in, first-out</I>&#8221; (<A NAME="Index958"></A>FIFO)
container. That is, you put things in at one end, and pull them out at the
other. So the order in which you put them in will be the same order that they
come out. <A NAME="Index959"></A><B>LinkedList</B> has methods to support queue
behavior, so these can be used in a <B>Queue</B> class:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Queue.java</font>
<font color=#009900>// Making a queue from a LinkedList.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Queue {
  <font color=#0000ff>private</font> LinkedList list = <font color=#0000ff>new</font> LinkedList();
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> put(Object v) { list.addFirst(v); }
  <font color=#0000ff>public</font> Object get() { 
    <font color=#0000ff>return</font> list.removeLast(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> isEmpty() { 
    <font color=#0000ff>return</font> list.isEmpty(); 
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Queue queue = <font color=#0000ff>new</font> Queue();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      queue.put(Integer.toString(i));
    <font color=#0000ff>while</font>(!queue.isEmpty())
      System.out.println(queue.get());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also easily create a <I>deque</I>
(double-ended queue) from a <B>LinkedList</B>. This is like a queue, but you can
add and remove elements from either end.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I107' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I108>
</FONT><A NAME="_Toc481064688"></A><BR></P></DIV>
<A NAME="Heading303"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Set functionality<BR><A NAME="Index960"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Set</B> has exactly the same interface
as <B>Collection</B>, so there isn&#8217;t any extra functionality like there is
with the two different <B>List</B>s. Instead, the <B>Set</B> is exactly a
<B>Collection</B>, it just has different behavior. (This is the ideal use of
inheritance and polymorphism: to express different behavior.) A <B>Set</B>
refuses to hold more than one instance of each object value (what constitutes
the &#8220;value&#8221; of an object is more complex, as you shall see).
<A NAME="Index961"></A><A NAME="Index962"></A><A NAME="Index963"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Set</B> (interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each element that you add to the
<B>Set</B> must be unique; otherwise the <B>Set</B> doesn&#8217;t add the
duplicate element. <B>Object</B>s added to a <B>Set</B> must define
<B>equals(&#160;)</B> to establish object uniqueness. <B>Set</B> has exactly the
same interface as <B>Collection</B>. The <B>Set</B> interface does not guarantee
it will maintain its elements in any particular order.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashSet</B>*</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For <B>Set</B>s where fast lookup time is
important. <B>Object</B>s must also define
<B>hashCode(&#160;)</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeSet</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An ordered <B>Set</B> backed by a tree.
This way, you can extract an ordered sequence from a
<B>Set</B>.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example does <I>not</I>
show everything you can do with a <B>Set</B>, since the interface is the same as
<B>Collection</B>, and so was exercised in the previous example. Instead, this
demonstrates the behavior that makes a <B>Set</B> unique:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Set1.java</font>
<font color=#009900>// Things you can do with Sets.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set1 {
  <font color=#0000ff>static</font> Collections2.StringGenerator gen = 
    Collections2.countries;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testVisual(Set a) {
    Collections2.fill(a, gen.reset(), 10);    
    Collections2.fill(a, gen.reset(), 10);    
    Collections2.fill(a, gen.reset(), 10);    
    System.out.println(a); <font color=#009900>// No duplicates!</font>
    <font color=#009900>// Add another set to this one:</font>
    a.addAll(a);
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>); 
    a.add(<font color=#004488>"one"</font>);
    System.out.println(a);
    <font color=#009900>// Look something up:</font>
    System.out.println(<font color=#004488>"a.contains(\"</font>one\<font color=#004488>"): "</font> +
      a.contains(<font color=#004488>"one"</font>));
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"HashSet"</font>);
    testVisual(<font color=#0000ff>new</font> HashSet());
    System.out.println(<font color=#004488>"TreeSet"</font>);
    testVisual(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Duplicate values are added to the
<B>Set</B>, but when it is printed you&#8217;ll see the <B>Set</B> has accepted
only one instance of each value.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I108' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I109>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program you&#8217;ll
notice that the order maintained by the <B>HashSet</B> is different from
<B>TreeSet</B>, since each has a different way of storing elements so they can
be located later. (<B>TreeSet</B> keeps them sorted, while <B>HashSet</B> uses a
hashing function, which is designed specifically for rapid lookups.) When
creating your own types, be aware that a <B>Set</B> needs a way to maintain a
storage order, which means you must implement the <B>Comparable </B>interface
and define the <B>compareTo(&#160;) </B>method. Here&#8217;s an
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Set2.java</font>
<font color=#009900>// Putting your own type in a Set.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> MyType <font color=#0000ff>implements</font> Comparable {
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> i;
  <font color=#0000ff>public</font> MyType(<font color=#0000ff>int</font> n) { i = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> 
      (o <font color=#0000ff>instanceof</font> MyType) 
      &amp;&amp; (i == ((MyType)o).i);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> i; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> i + <font color=#004488>" "</font>; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object o) {
    <font color=#0000ff>int</font> i2 = ((MyType)o).i;
    <font color=#0000ff>return</font> (i2 &lt; i ? -1 : (i2 == i ? 0 : 1));
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Set2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> Set fill(Set a, <font color=#0000ff>int</font> size) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
      a.add(<font color=#0000ff>new</font> MyType(i));
    <font color=#0000ff>return</font> a;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Set a) {
    fill(a, 10);
    fill(a, 10); <font color=#009900>// Try to add duplicates</font>
    fill(a, 10);
    a.addAll(fill(<font color=#0000ff>new</font> TreeSet(), 10));
    System.out.println(a);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    test(<font color=#0000ff>new</font> HashSet());
    test(<font color=#0000ff>new</font> TreeSet());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><A NAME="Index964"></A><A NAME="Index965"></A><FONT FACE="Georgia">The
form for the definitions for <A NAME="Index966"></A><B>equals(&#160;)</B> and
<B>hashCode(&#160;)</B> will be described later in this chapter. You must define
an <B>equals(&#160;)</B> in both cases, but the <B>hashCode(&#160;)</B> is
absolutely necessary only if the class will be placed in a <B>HashSet</B> (which
is likely, since that should generally be your first choice as a <B>Set</B>
implementation). However, as a programming style you should always override
<B>hashCode(&#160;)</B> when you override <B>equals(&#160;)</B>. This process
will be fully detailed later in this chapter.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I109' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I110>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the <B>compareTo(&#160;)</B>, note
that I did <I>not</I> use the &#8220;simple and obvious&#8221; form <B>return
i-i2</B>. Although this is a common programming error, it would only work
properly if <B>i</B> and <B>i2</B> were &#8220;unsigned&#8221;<B> int</B>s (if
Java <I>had </I>an &#8220;unsigned&#8221; keyword, which it does not). It breaks
for Java&#8217;s signed <B>int</B>, which is not big enough to represent the
difference of two signed <B>int</B>s. If <B>i</B> is a large positive integer
and <B>j</B> is a large negative integer, <B>i-j</B> will overflow and return a
negative value, which will not work. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I110' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I111>
</FONT><A NAME="_Toc481064689"></A><BR></P></DIV>
<A NAME="Heading304"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
SortedSet</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have a <B>SortedSet</B> (of which
<B>TreeSet</B> is the only one available), the elements are guaranteed to be in
sorted order which allows additional functionality to be provided with these
methods in the <B>SortedSet</B> interface:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I111' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I112>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Comparator comparator():</B> Produces
the <B>Comparator</B> used for this <B>Set</B>, or <B>null</B> for natural
ordering. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object first():</B> Produces the
lowest element. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object last():</B> Produces the
highest element. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedSet subSet(fromElement,
toElement):</B> Produces a view of this <B>Set</B> with elements from
<B>fromElement</B>, inclusive, to <B>toElement</B>, exclusive. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedSet headSet(toElement):</B>
Produces a view of this <B>Set</B> with elements less than <B>toElement</B>.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedSet tailSet(fromElement):</B>
Produces a view of this <B>Set</B> with elements greater than or equal to
<B>fromElement</B>.</FONT><A NAME="_Toc481064690"></A><BR></P></DIV>
<A NAME="Heading305"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Map
functionality<BR><A NAME="Index967"></A><A NAME="Index968"></A><A NAME="Index969"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An <B>ArrayList</B> allows you to select
from a sequence of objects using a number, so in a sense it associates numbers
to objects. But what if you&#8217;d like to select from a sequence of objects
using some other criterion? A stack is an example: its selection criterion is
&#8220;the last thing pushed on the stack.&#8221; A powerful twist on this idea
of &#8220;selecting from a sequence&#8221; is alternately termed a
<A NAME="Index970"></A><I>map</I>, a <A NAME="Index971"></A><I>dictionary,</I>
or an <A NAME="Index972"></A><A NAME="Index973"></A><I>associative array</I>.
Conceptually, it seems like an <B>ArrayList</B>, but instead of looking up
objects using a number, you look them up using <I>another object</I>! This is
often a key process in a program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I112' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I113>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept shows up in Java as the
<B>Map </B>interface. The <B>put(Object key, Object value)</B> method adds a
value (the thing you want), and associates it with a key (the thing you look it
up with). <B>get(Object key)</B> produces the value given the corresponding key.
You can also test a <B>Map</B> to see if it contains a key or a value with
<B>containsKey(&#160;)</B> and <B>containsValue(&#160;)</B>. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I113' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I114>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The standard Java library contains two
different types of <B>Map</B>s: <B>HashMap</B> and <B>TreeMap</B>. Both have the
same interface (since they both implement <B>Map</B>), but they differ in one
distinct way: efficiency. If you look at what must be done for a
<B>get(&#160;)</B>, it seems pretty slow to search through (for example) an
<B>ArrayList</B> for the key. This is where <B>HashMap</B> speeds things up.
Instead of a slow search for the key, it uses a special value called a
<A NAME="Index974"></A><I>hash code</I>.<I> </I>The hash code is a way to take
some information in the object in question and turn it into a &#8220;relatively
unique&#8221; <B>int</B> for that object. All Java objects can produce a hash
code, and <A NAME="Index975"></A><B>hashCode(&#160;)</B> is a method in the root
class <A NAME="Index976"></A><B>Object</B>. A <B>HashMap </B>takes the
<B>hashCode(&#160;)</B> of the object and uses it to quickly hunt for the key.
This results in a dramatic performance
improvement</FONT><A NAME="fnB50" HREF="#fn50">[50]</A><FONT FACE="Georgia">.</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Map</B> (interface)</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Maintains key-value associations (pairs),
so you can look up a value using a key.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashMap</B>*</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Implementation based on a hash table.
(Use this instead of <B>Hashtable</B>.) Provides constant-time performance for
inserting and locating pairs. Performance can be adjusted via constructors that
allow you to set the <I>capacity</I> and <I>load factor</I> of the hash
table.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeMap</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Implementation based on a red-black tree.
When you view the keys or the pairs, they will be in sorted order (determined by
<B>Comparable</B> or <B>Comparator</B>, discussed later). The point of a
<B>TreeMap</B> is that you get the results in sorted order. <B>TreeMap</B> is
the only <B>Map</B> with the <B>subMap(&#160;)</B> method, which allows you to
return a portion of the tree.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes you&#8217;ll also need to know
the details of how hashing works, so we&#8217;ll look at that a little
later.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example uses the
<B>Collections2.fill(&#160;)</B> method and the test data sets that were
previously defined: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I114' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I115>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Map1.java</font>
<font color=#009900>// Things you can do with Maps.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Map1 {
  <font color=#0000ff>static</font> Collections2.StringPairGenerator geo = 
    Collections2.geography;
  <font color=#0000ff>static</font> Collections2.RandStringPairGenerator 
    rsp = Collections2.rsp;
  <font color=#009900>// Producing a Set of the keys:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printKeys(Map m) {
    System.out.print(<font color=#004488>"Size = "</font> + m.size() +<font color=#004488>", "</font>);
    System.out.print(<font color=#004488>"Keys: "</font>);
    System.out.println(m.keySet());
  }
  <font color=#009900>// Producing a Collection of the values:</font>
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> printValues(Map m) {
    System.out.print(<font color=#004488>"Values: "</font>);
    System.out.println(m.values());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(Map m) {
    Collections2.fill(m, geo, 25);
    <font color=#009900>// Map has 'Set' behavior for keys:</font>
    Collections2.fill(m, geo.reset(), 25);
    printKeys(m);
    printValues(m);
    System.out.println(m);
    String key = CountryCapitals.pairs[4][0];
    String value = CountryCapitals.pairs[4][1];
    System.out.println(<font color=#004488>"m.containsKey(\"</font>" + key +
      <font color=#004488>"\"</font>): " + m.containsKey(key));
    System.out.println(<font color=#004488>"m.get(\"</font><font color=#004488>" + key + "</font>\<font color=#004488>"): "</font>
      + m.get(key));
    System.out.println(<font color=#004488>"m.containsValue(\"</font>" 
      + value + <font color=#004488>"\"</font>): " + 
      m.containsValue(value)); 
    Map m2 = <font color=#0000ff>new</font> TreeMap();
    Collections2.fill(m2, rsp, 25);
    m.putAll(m2);
    printKeys(m);
    key = m.keySet().iterator().next().toString();
    System.out.println(<font color=#004488>"First key in map: "</font>+key);
    m.remove(key);
    printKeys(m);
    m.clear();
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
    Collections2.fill(m, geo.reset(), 25);
    <font color=#009900>// Operations on the Set change the Map:</font>
    m.keySet().removeAll(m.keySet());
    System.out.println(<font color=#004488>"m.isEmpty(): "</font> 
      + m.isEmpty());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Testing HashMap"</font>);
    test(<font color=#0000ff>new</font> HashMap());
    System.out.println(<font color=#004488>"Testing TreeMap"</font>);
    test(<font color=#0000ff>new</font> TreeMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>printKeys(&#160;)</B> and
<B>printValues(&#160;)</B> methods are not only useful utilities, they also
demonstrate how to produce <B>Collection</B> views of a <B>Map</B>. The
<B>keySet(&#160;)</B> method produces a <B>Set</B> backed by the keys in the
<B>Map</B>. Similar treatment is given to <B>values(&#160;)</B>, which produces
a <B>Collection</B> containing all the values in the <B>Map.</B> (Note that keys
must be unique, while values may contain duplicates.) Since these
<B>Collection</B>s are backed by the <B>Map</B>, any changes in a
<B>Collection</B> will be reflected in the associated <B>Map</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I115' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I116>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rest of the program provides simple
examples of each <B>Map</B> operation, and tests each type of <B>Map</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I116' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I117>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example of the use of a
<B>HashMap</B>, consider a program to check the randomness of Java&#8217;s
<A NAME="Index977"></A><A NAME="Index978"></A><B>Math.random(&#160;)</B> method.
Ideally, it would produce a perfect distribution of random numbers, but to test
this you need to generate a bunch of random numbers and count the ones that fall
in the various ranges. A <B>HashMap</B> is perfect for this, since it associates
objects with objects (in this case, the value object contains the number
produced by <B>Math.random(&#160;)</B> along with the number of times that
number appears):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Statistics.java</font>
<font color=#009900>// Simple demonstration of HashMap.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Counter { 
  <font color=#0000ff>int</font> i = 1; 
  <font color=#0000ff>public</font> String toString() { 
    <font color=#0000ff>return</font> Integer.toString(i); 
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Statistics {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10000; i++) {
      <font color=#009900>// Produce a number between 0 and 20:</font>
      Integer r = 
        <font color=#0000ff>new</font> Integer((<font color=#0000ff>int</font>)(Math.random() * 20));
      <font color=#0000ff>if</font>(hm.containsKey(r))
        ((Counter)hm.get(r)).i++;
      <font color=#0000ff>else</font>
        hm.put(r, <font color=#0000ff>new</font> Counter());
    }
    System.out.println(hm);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, each time a
random number is generated it is wrapped inside an <B>Integer</B> object so that
reference can be used with the <B>HashMap</B>. (You can&#8217;t use a primitive
with a container, only an object reference.) The <B>containsKey(&#160;)</B>
method checks to see if this key is already in the container. (That is, has the
number been found already?) If so, the <A NAME="Index979"></A><B>get(&#160;)</B>
method produces the associated value for the key, which in this case is a
<B>Counter</B> object. The value <B>i</B> inside the counter is incremented to
indicate that one more of this particular random number has been found.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I117' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I118>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the key has not been found yet, the
method <A NAME="Index980"></A><B>put(&#160;)</B> will place a new key-value pair
into the <B>HashMap</B>. Since <B>Counter</B> automatically initializes its
variable <B>i</B> to one when it&#8217;s created, it indicates the first
occurrence of this particular random number.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I118' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I119>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To display the <B>HashMap</B>, it is
simply printed. The <B>HashMap</B> <B>toString(&#160;)</B> method moves through
all the key-value pairs and calls the <B>toString(&#160;)</B> for each one. The
<B>Integer.toString(&#160;)</B> is predefined, and you can see the
<B>toString(&#160;)</B> for <B>Counter</B>. The output from one run (with some
line breaks added) is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>{19=526, 18=533, 17=460, 16=513, 15=521, 14=495,
 13=512, 12=483, 11=488, 10=487, 9=514, 8=523,
 7=497, 6=487, 5=480, 4=489, 3=509, 2=503, 1=475,
 0=505}</PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might wonder at the necessity of the
class <B>Counter,</B> which seems like it doesn&#8217;t even have the
functionality of the wrapper class <B>Integer</B>. Why not use <B>int</B> or
<B>Integer</B>? Well, you can&#8217;t use an <B>int</B> because all of the
containers can hold only<B> Object </B>references. After seeing containers the
wrapper classes might begin to make a little more sense to you, since you
can&#8217;t put any of the primitive types in containers. However, the only
thing you <I>can</I> do with the Java <A NAME="Index981"></A>wrappers is to
initialize them to a particular value and read that value. That is,
there&#8217;s no way to change a value once a wrapper object has been created.
This makes the <B>Integer</B> wrapper immediately useless to solve our problem,
so we&#8217;re forced to create a new class that does satisfy the need.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I119' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I120>
</FONT><A NAME="_Toc481064691"></A><BR></P></DIV>
<A NAME="Heading306"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
SortedMap</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you have a <B>SortedMap</B> (of which
<B>TreeMap</B> is the only one available), the keys are guaranteed to be in
sorted order which allows additional functionality to be provided with these
methods in the <B>SortedMap</B> interface:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I120' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I121>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Comparator comparator():</B> Produces
the comparator used for this <B>Map</B>, or <B>null</B> for natural ordering.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object firstKey():</B> Produces the
lowest key. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Object lastKey():</B> Produces the
highest key. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedMap subMap(fromKey, toKey):</B>
Produces a view of this <B>Map</B> with keys from <B>fromKey</B>, inclusive, to
<B>toKey</B>, exclusive. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedMap headMap(toKey):</B> Produces
a view of this <B>Map</B> with keys less than <B>toKey</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>SortedMap tailMap(fromKey):</B>
Produces a view of this <B>Map</B> with keys greater than or equal to
<B>fromKey</B>.</FONT><A NAME="_Toc481064692"></A><BR></P></DIV>
<A NAME="Heading307"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Hashing and hash codes</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the previous example, a standard
library class (<B>Integer</B>) was used as a key for the <B>HashMap</B>. It
worked fine as a key, because it has all the necessary wiring to make it work
correctly as a key. But a common pitfall occurs with <B>HashMap</B>s when you
create your own classes to be used as keys. For example, consider a weather
predicting system that matches <B>Groundhog</B> objects to <B>Prediction</B>
objects. It seems fairly straightforward&#8212;you create the two classes, and
use <B>Groundhog</B> as the key and <B>Prediction</B> as the value:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I121' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I122>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SpringDetector.java</font>
<font color=#009900>// Looks plausible, but doesn't work.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog(<font color=#0000ff>int</font> n) { ghNumber = n; }
}

<font color=#0000ff>class</font> Prediction {
  <font color=#0000ff>boolean</font> shadow = Math.random() &gt; 0.5;
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>if</font>(shadow)
      <font color=#0000ff>return</font> <font color=#004488>"Six more weeks of Winter!"</font>;
    <font color=#0000ff>else</font>
      <font color=#0000ff>return</font> <font color=#004488>"Early Spring!"</font>;
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      hm.put(<font color=#0000ff>new</font> Groundhog(i), <font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"hm = "</font> + hm + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for Groundhog #3:"</font>);
    Groundhog gh = <font color=#0000ff>new</font> Groundhog(3);
    <font color=#0000ff>if</font>(hm.containsKey(gh))
      System.out.println((Prediction)hm.get(gh));
    <font color=#0000ff>else</font>
      System.out.println(<font color=#004488>"Key not found: "</font> + gh);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each <B>Groundhog</B> is given an
identity number, so you can look up a <B>Prediction</B> in the <B>HashMap</B> by
saying, &#8220;Give me the <B>Prediction </B>associated with <B>Groundhog</B>
number 3.&#8221; The <B>Prediction</B> class contains a <B>boolean</B> that is
initialized using <B>Math.random(&#160;)</B>, and a <B>toString(&#160;)</B> that
interprets the result for you. In <B>main(&#160;)</B>, a <B>HashMap</B> is
filled with <B>Groundhog</B>s and their associated <B>Prediction</B>s. The
<B>HashMap </B>is printed so you can see that it has been filled. Then a
<B>Groundhog</B> with an identity number of 3 is used as a key to look up the
prediction for <B>Groundhog</B> #3 (which you can see must be in the
<B>Map</B>). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I122' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I123>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It seems simple enough, but it
doesn&#8217;t work. The problem is that <B>Groundhog</B> is inherited from the
common root class <B>Object</B> (which is what happens if you don&#8217;t
specify a base class, thus all classes are ultimately inherited from
<B>Object</B>). It is <B>Object</B>&#8217;s <B>hashCode(&#160;)</B> method that
is used to generate the hash code for each object, and by default it just uses
the address of its object. Thus, the first instance of <B>Groundhog(3)</B> does
<I>not</I> produce a hash code equal to the hash code for the second instance of
<B>Groundhog(3)</B> that we tried to use as a lookup.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I123' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I124>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You might think that all you need to do
is write an appropriate override for
<A NAME="Index982"></A><B>hashCode(&#160;)</B>. But it still won&#8217;t work
until you&#8217;ve done one more thing: override the
<A NAME="Index983"></A><B>equals(&#160;)</B> that is also part of <B>Object</B>.
This method is used by the <B>HashMap</B> when trying to determine if your key
is equal to any of the keys in the table. Again, the default
<B>Object.equals(&#160;)</B> simply compares object addresses, so one
<B>Groundhog(3)</B> is not equal to another <B>Groundhog(3)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I124' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I125>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, to use your own classes as keys in
a <B>HashMap</B>, you must override both <B>hashCode(&#160;)</B> and
<B>equals(&#160;)</B>, as shown in the following solution to the problem
above:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SpringDetector2.java</font>
<font color=#009900>// A class that's used as a key in a HashMap </font>
<font color=#009900>// must override hashCode() and equals().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> Groundhog2 {
  <font color=#0000ff>int</font> ghNumber;
  Groundhog2(<font color=#0000ff>int</font> n) { ghNumber = n; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { <font color=#0000ff>return</font> ghNumber; }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> Groundhog2)
      &amp;&amp; (ghNumber == ((Groundhog2)o).ghNumber);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SpringDetector2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap hm = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
      hm.put(<font color=#0000ff>new</font> Groundhog2(i),<font color=#0000ff>new</font> Prediction());
    System.out.println(<font color=#004488>"hm = "</font> + hm + <font color=#004488>"\n"</font>);
    System.out.println(
      <font color=#004488>"Looking up prediction for groundhog #3:"</font>);
    Groundhog2 gh = <font color=#0000ff>new</font> Groundhog2(3);
    <font color=#0000ff>if</font>(hm.containsKey(gh))
      System.out.println((Prediction)hm.get(gh));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that this uses the <B>Prediction</B>
class from the previous example, so <B>SpringDetector.java</B> must be compiled
first or you&#8217;ll get a compile-time error when you try to compile<B>
SpringDetector2.java</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I125' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I126>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Groundhog2.hashCode(&#160;)</B>
returns the groundhog number as an identifier. In this example, the programmer
is responsible for ensuring that no two groundhogs exist with the same ID
number. The <B>hashCode(&#160;) </B>is not required to return a unique
identifier (something you&#8217;ll understand better later in this chapter), but
the <B>equals(&#160;)</B> method must be able to strictly determine whether two
objects are equivalent. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I126' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I127>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though it appears that the
<B>equals(&#160;)</B> method is only checking to see whether the argument is an
instance of <B>Groundhog2</B> (using the <B>instanceof</B> keyword, which is
fully explained in Chapter 12), the <B>instanceof</B> actually quietly does a
second sanity check, to see if the object is <B>null</B>, since
<B>instanceof</B> produces <B>false</B> if the left-hand argument is
<B>null</B>. Assuming it&#8217;s the correct type and not <B>null</B>, the
comparison is based on the actual <B>ghNumber</B>s. This time, when you run the
program, you&#8217;ll see it produces the correct output.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I127' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I128>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When creating your own class to use in a
<B>HashSet</B>, you must pay attention to the same issues as when it is used as
a key in a <B>HashMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I128' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I129>
</FONT><BR></P></DIV>
<A NAME="Heading308"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Understanding hashCode(&#160;)</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The above example is only a start toward
solving the problem correctly. It shows that if you do not override
<A NAME="Index984"></A><B>hashCode(&#160;)</B> and
<A NAME="Index985"></A><B>equals(&#160;)</B> for your key, the hashed data
structure (<B>HashSet</B> or <B>HashMap</B>) will not be able to deal with your
key properly. However, to get a good solution for the problem you need to
understand what&#8217;s going on inside the hashed data structure.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I129' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I130>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, consider the motivation behind
<A NAME="Index986"></A>hashing: you want to look up an object using another
object. But you can accomplish this with a <B>TreeSet</B> or <B>TreeMap</B>,
too. It&#8217;s also possible to implement your own <B>Map</B>. To do so, the
<B>Map.entrySet(&#160;)</B> method must be supplied to produce a set of
<B>Map.Entry</B> objects. <B>MPair</B> will be defined as the new type of
<A NAME="Index987"></A><B>Map.Entry</B>. In order for it to be placed in a
<B>TreeSet</B> it must implement <B>equals(&#160;)</B> and be
<B>Comparable</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MPair.java</font>
<font color=#009900>// A Map implemented with ArrayLists.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MPair 
<font color=#0000ff>implements</font> Map.Entry, Comparable {
  Object key, value;
  MPair(Object k, Object v) {
    key = k;
    value = v;
  }
  <font color=#0000ff>public</font> Object getKey() { <font color=#0000ff>return</font> key; }
  <font color=#0000ff>public</font> Object getValue() { <font color=#0000ff>return</font> value; }
  <font color=#0000ff>public</font> Object setValue(Object v){
    Object result = value;
    value = v;
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> key.equals(((MPair)o).key);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> compareTo(Object rv) {
    <font color=#0000ff>return</font> ((Comparable)key).compareTo(
      ((MPair)rv).key);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>Notice that the comparisons are only interested in the keys, so duplicate values are perfectly acceptable.</PRE></FONT></BLOCKQUOTE><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
following example implements a <B>Map</B> using a pair of <B>ArrayLists</B>:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I130' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I131>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SlowMap.java</font>
<font color=#009900>// A Map implemented with ArrayLists.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SlowMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#0000ff>private</font> ArrayList 
    keys = <font color=#0000ff>new</font> ArrayList(),
    values = <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = get(key);
    <font color=#0000ff>if</font>(!keys.contains(key)) {
      keys.add(key);
      values.add(value);
    } <font color=#0000ff>else</font>
      values.set(keys.indexOf(key), value);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>if</font>(!keys.contains(key))
      <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    <font color=#0000ff>return</font> values.get(keys.indexOf(key));
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    Iterator
      ki = keys.iterator(),
      vi = values.iterator();
    <font color=#0000ff>while</font>(ki.hasNext())
      entries.add(<font color=#0000ff>new</font> MPair(ki.next(), vi.next()));
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SlowMap m = <font color=#0000ff>new</font> SlowMap();
    Collections2.fill(m, 
      Collections2.geography, 25);
    System.out.println(m);    
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>put(&#160;)</B> method simply
places the keys and values in corresponding <B>ArrayList</B>s. In
<B>main(&#160;)</B>, a <B>SlowMap</B> is loaded and then printed to show that it
works.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This shows that it&#8217;s not that hard
to produce a new type of <B>Map</B>. But as the name suggests, a <B>SlowMap
</B>isn&#8217;t very fast, so you probably wouldn&#8217;t use it if you had an
alternative available. The problem is in the lookup of the key: there is no
order so a simple linear search is used, which is the slowest way to look
something up. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I131' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I132>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The whole point of hashing is speed:
hashing allows the lookup to happen quickly. Since the bottleneck is in the
speed of the key lookup, one of the solutions to the problem could be by keeping
the keys sorted and then using <B>Collections.binarySearch(&#160;)</B> to
perform the lookup (an exercise at the end of this chapter will walk you through
this process). 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I132' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I133>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Hashing goes further by saying that all
you want to do is to store the key <I>somewhere</I> so that it can be quickly
found. As you&#8217;ve seen in this chapter, the fastest structure in which to
store a group of elements is an array, so that will be used for representing the
key information (note carefully that I said &#8220;key information,&#8221; and
not the key itself). Also seen in this chapter was the fact that an array, once
allocated, cannot be resized, so we have a problem: we want to be able to store
any number of values in the <B>Map</B>, but if the number of keys is fixed by
the array size, how can this be?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I133' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I134>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The answer is that the array will not
hold the keys. From the key object, a number will be derived that will index
into the array. This number is the <A NAME="Index988"></A><I>hash code</I>,
produced by the <B>hashCode(&#160;)</B> method (in computer science parlance,
this is the <A NAME="Index989"></A><I>hash function</I>) defined in
<B>Object</B> and presumably overridden by your class. To solve the problem of
the fixed-size array, more than one key may produce the same index. That is,
there may be <A NAME="Index990"></A><I>collisions</I>. Because of this, it
doesn&#8217;t matter how big the array is because each key object will land
somewhere in that array. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I134' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I135>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So the process of looking up a value
starts by computing the hash code and using it to index into the array. If you
could guarantee that there were no collisions (which could be possible if you
have a fixed number of values) then you&#8217;d have a
<A NAME="Index991"></A><A NAME="Index992"></A><I>perfect hashing function</I>,
but that&#8217;s a special case. In all other cases, collisions are handled by
<A NAME="Index993"></A><I>external chaining:</I> the array points not directly
to a value, but instead to a list of values. These values are searched in a
linear fashion using the <B>equals(&#160;)</B> method. Of course, this aspect of
the search is much slower, but if the hash function is good there will only be a
few values in each slot, at the most. So instead of searching through the entire
list, you quickly jump to a slot where you have to compare a few entries to find
the value. This is much faster, which is why the <B>HashMap</B> is so quick.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I135' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I136>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Knowing the basics of hashing, it&#8217;s
possible to implement a simple hashed <B>Map</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SimpleHashMap.java</font>
<font color=#009900>// A demonstration hashed Map.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SimpleHashMap <font color=#0000ff>extends</font> AbstractMap {
  <font color=#009900>// Choose a prime number for the hash table</font>
  <font color=#009900>// size, to achieve a uniform distribution:</font>
  <font color=#0000ff>private</font> <font color=#0000ff>final</font> <font color=#0000ff>static</font> <font color=#0000ff>int</font> SZ = 997;
  <font color=#0000ff>private</font> LinkedList[] bucket= <font color=#0000ff>new</font> LinkedList[SZ];
  <font color=#0000ff>public</font> Object put(Object key, Object value) {
    Object result = <font color=#0000ff>null</font>;
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>)
      bucket[index] = <font color=#0000ff>new</font> LinkedList();
    LinkedList pairs = bucket[index];
    MPair pair = <font color=#0000ff>new</font> MPair(key, value);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>boolean</font> found = <font color=#0000ff>false</font>;
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(pair)) {
        result = ((MPair)iPair).getValue();
        it.set(pair); <font color=#009900>// Replace old with new</font>
        found = <font color=#0000ff>true</font>;
        <font color=#0000ff>break</font>;
      }
    }
    <font color=#0000ff>if</font>(!found)
      bucket[index].add(pair);
    <font color=#0000ff>return</font> result;
  }
  <font color=#0000ff>public</font> Object get(Object key) {
    <font color=#0000ff>int</font> index = key.hashCode() % SZ;
    <font color=#0000ff>if</font>(index &lt; 0) index = -index;
    <font color=#0000ff>if</font>(bucket[index] == <font color=#0000ff>null</font>) <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
    LinkedList pairs = bucket[index];
    MPair match = <font color=#0000ff>new</font> MPair(key, <font color=#0000ff>null</font>);
    ListIterator it = pairs.listIterator();
    <font color=#0000ff>while</font>(it.hasNext()) {
      Object iPair = it.next();
      <font color=#0000ff>if</font>(iPair.equals(match))
        <font color=#0000ff>return</font> ((MPair)iPair).getValue();
    }
    <font color=#0000ff>return</font> <font color=#0000ff>null</font>;
  }
  <font color=#0000ff>public</font> Set entrySet() {
    Set entries = <font color=#0000ff>new</font> HashSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; bucket.length; i++) {
      <font color=#0000ff>if</font>(bucket[i] == <font color=#0000ff>null</font>) <font color=#0000ff>continue</font>;
      Iterator it = bucket[i].iterator();
      <font color=#0000ff>while</font>(it.hasNext())
        entries.add(it.next());
    }
    <font color=#0000ff>return</font> entries;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    SimpleHashMap m = <font color=#0000ff>new</font> SimpleHashMap();
    Collections2.fill(m, 
      Collections2.geography, 25);
    System.out.println(m);    
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the &#8220;slots&#8221; in a hash
table are often referred to as <I>buckets,</I> the array that represents the
actual table is called <B>bucket</B>. To promote even distribution, the number
of buckets is typically a prime number. Notice that it is an array of
<B>LinkedList</B>, which automatically provides for collisions&#8212;each new
item is simply added to the end of the list.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I136' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I137>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The return value of <B>put(&#160;)</B> is
<B>null</B> or, if the key was already in the list, the old value associated
with that key. The return value is <B>result</B>, which is initialized to
<B>null</B>, but if a key is discovered in the list then <B>result</B> is
assigned to that key. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I137' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I138>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For both <B>put(&#160;)</B> and
<B>get(&#160;)</B>, the first thing that happens is that the
<B>hashCode(&#160;)</B> is called for the key, and the result is forced to a
positive number. Then it is forced to fit into the <B>bucket</B> array using the
modulus operator and the size of the array. If that location is <B>null</B>, it
means there are no elements that hash to that location, so a new
<B>LinkedList</B> is created to hold the object that just did. However, the
normal process is to look through the list to see if there are duplicates, and
if there are, the old value is put into <B>result</B> and the new value replaces
the old. The <B>found</B> flag keeps track of whether an old key-value pair was
found and, if not, the new pair is appended to the end of the list.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I138' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I139>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>get(&#160;)</B>, you&#8217;ll see
very similar code as that contained in <B>put(&#160;)</B>, but simpler. The
index is calculated into the <B>bucket</B> array, and if a <B>LinkedList</B>
exists it is searched for a match.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I139' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I140>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>entrySet(&#160;)</B> must find and
traverse all the lists, adding them to the result <B>Set</B>. Once this method
has been created, the <B>Map</B> can be tested by filling it with values and
then printing them. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I140' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I141>
</FONT><BR></P></DIV>
<A NAME="Heading309"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
HashMap performance factors</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the issues, some
terminology is necessary:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index994"></A><FONT FACE="Georgia"><B><I>Capacity</I></B><I>:</I>
The number of buckets in the table.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index995"></A><FONT FACE="Georgia"><B><I>Initial
capacity</I></B><I>:</I> The number of buckets when the table is created.
<B>HashMap</B> and <B>HashSet</B>: have constructors that allow you to specify
the initial capacity.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index996"></A><FONT FACE="Georgia"><B><I>Size</I></B><I>:</I>
The number of entries currently in the table.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index997"></A><FONT FACE="Georgia"><B><I>Load
factor</I></B><I>:</I> size/capacity. A load factor of 0 is an empty table, 0.5
is a half-full table, etc. A lightly-loaded table will have few collisions and
so is optimal for insertions and lookups (but will slow down the process of
traversing with an iterator). <B>HashMap</B> and <B>HashSet</B> have
constructors that allow you to specify the load factor, which means that when
this load factor is reached the container will automatically increase the
capacity (the number of buckets) by roughly doubling it, and will redistribute
the existing objects into the new set of buckets (this is called
<I>rehashing</I>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The default load factor used by
<B>HashMap </B>is 0.75 (it doesn&#8217;t rehash until the table is &#190; full).
This seems to be a good trade-off between time and space costs. A higher load
factor decreases the space required by the table but increases the lookup cost,
which is important because lookup is what you do most of the time (including
both <B>get(&#160;)</B> and <B>put(&#160;)</B>).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I141' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I142>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you know that you&#8217;ll be storing
many entries in a <B>HashMap</B>, creating it with an appropriately large
initial capacity will prevent the overhead of automatic rehashing.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I142' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I143>
</FONT><A NAME="_Toc481064693"></A><BR></P></DIV>
<A NAME="Heading310"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Overriding hashCode(&#160;)</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now that you understand what&#8217;s
involved in the function of the <B>HashMap</B>, the issues involved in writing a
<A NAME="Index998"></A><B>hashCode(&#160;)</B> will make more sense.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I143' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I144>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First of all, you don&#8217;t have
control of the creation of the actual value that&#8217;s used to index into the
array of buckets. That is dependent on the capacity of the particular
<B>HashMap</B> object, and that capacity changes depending on how full the
container is, and what the load factor is. The value produced by your
<B>hashCode(&#160;)</B> will be further processed in order to create the bucket
index (in <B>SimpleHashMap</B> the calculation is just a modulo by the size of
the bucket array).  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I144' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I145>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most important factor in creating a
<B>hashCode(&#160;)</B> is that, regardless of when <B>hashCode(&#160;)</B> is
called, it produces the same value for a particular object every time it is
called. If you end up with an object that produces one <B>hashCode(&#160;)
</B>value when it is <B>put(&#160;)</B> into a <B>HashMap</B>, and another
during a <B>get(&#160;)</B>, you won&#8217;t be able to retrieve the objects. So
if your <B>hashCode(&#160;)</B> depends on mutable data in the object the user
must be made aware that changing the data will effectively produce a different
key by generating a different <B>hashCode(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I145' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I146>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, you will probably <I>not
</I>want to generate a <B>hashCode(&#160;) </B>that is based on unique object
information&#8212;in particular, the value of <B>this</B> makes a bad
<B>hashCode(&#160;) </B>because then you can&#8217;t generate a new identical
key to the one used to <B>put(&#160;) </B>the original key-value pair. This was
the problem that occurred in <B>SpringDetector.java</B> because the default
implementation of <B>hashCode(&#160;) </B><I>does</I> use the object address. So
you&#8217;ll want to use information in the object that identifies the object in
a meaningful way. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I146' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I147>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One example is found in the <B>String</B>
class. <B>String</B>s have the special characteristic that if a program has
several <B>String</B> objects that contain identical character sequences, then
those <B>String</B> objects all map to the same memory (the mechanism for this
is described in Appendix A). So it makes sense that the <B>hashCode(&#160;)</B>
produced by two separate instances of <B>new String(&#8220;hello&#8221;)</B>
should be identical. You can see it by running this program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:StringHashCode.java</font>
<font color=#0000ff>public</font> <font color=#0000ff>class</font> StringHashCode {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
    System.out.println(<font color=#004488>"Hello"</font>.hashCode());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For this to work, the
<B>hashCode(&#160;)</B> for <B>String</B> must be based on the contents of the
<B>String</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I147' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I148>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So for a <B>hashCode(&#160;)</B> to be
effective, it must be fast and it must be meaningful: that is, it must generate
a value based on the contents of the object. Remember that this value
doesn&#8217;t have to be unique&#8212;you should lean toward speed rather than
uniqueness&#8212;but between <B>hashCode(&#160;)</B> and <B>equals(&#160;)</B>
the identity of the object must be completely resolved.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I148' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I149>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the <B>hashCode(&#160;)</B> is
further processed before the bucket index is produced, the range of values is
not important; it just needs to generate an <B>int</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I149' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I150>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one other factor: a good
<B>hashCode(&#160;)</B> should result in an even distribution of values. If the
values tend to cluster, then the <B>HashMap</B> or <B>HashSet </B>will be more
heavily loaded in some areas and will not be as fast as it could be with an
evenly distributed hashing function.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I150' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I151>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example that follows
these guidelines:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CountedString.java</font>
<font color=#009900>// Creating a good hashCode().</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CountedString {
  <font color=#0000ff>private</font> String s;
  <font color=#0000ff>private</font> <font color=#0000ff>int</font> id = 0;
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> ArrayList created = 
    <font color=#0000ff>new</font> ArrayList();
  <font color=#0000ff>public</font> CountedString(String str) {
    s = str;
    created.add(s);
    Iterator it = created.iterator();
    <font color=#009900>// Id is the total number of instances</font>
    <font color=#009900>// of this string in use by CountedString:</font>
    <font color=#0000ff>while</font>(it.hasNext())
      <font color=#0000ff>if</font>(it.next().equals(s))
        id++;
  }
  <font color=#0000ff>public</font> String toString() {
    <font color=#0000ff>return</font> <font color=#004488>"String: "</font> + s + <font color=#004488>" id: "</font> + id +
      <font color=#004488>" hashCode(): "</font> + hashCode() + <font color=#004488>"\n"</font>;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { 
    <font color=#0000ff>return</font> s.hashCode() * id;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object o) {
    <font color=#0000ff>return</font> (o <font color=#0000ff>instanceof</font> CountedString)
      &amp;&amp; s.equals(((CountedString)o).s)
      &amp;&amp; id == ((CountedString)o).id;
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    HashMap m = <font color=#0000ff>new</font> HashMap();
    CountedString[] cs = <font color=#0000ff>new</font> CountedString[10];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      cs[i] = <font color=#0000ff>new</font> CountedString(<font color=#004488>"hi"</font>);
      m.put(cs[i], <font color=#0000ff>new</font> Integer(i));
    }
    System.out.println(m);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; cs.length; i++) {
      System.out.print(<font color=#004488>"Looking up "</font> + cs[i]);
      System.out.println(m.get(cs[i]));
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>CountedString</B> includes a
<B>String</B> and an <B>id</B> that represents the number of
<B>CountedString</B> objects that contain an identical <B>String</B>. The
counting is accomplished in the constructor by iterating through the <B>static
ArrayList</B> where all the <B>String</B>s are stored.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I151' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I152>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both <B>hashCode(&#160;)</B> and
<B>equals(&#160;)</B> produce results based on both fields; if they were just
based on the <B>String</B> alone or the <B>id</B> alone there would be duplicate
matches for distinct values.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I152' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I153>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note how simple the
<B>hashCode(&#160;)</B> is: <B>String</B>&#8217;s <B>hashCode(&#160;)</B> is
multiplied by the <B>id</B>. Smaller is generally better (and faster) for
<B>hashCode(&#160;)</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I153' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I154>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, a bunch of
<B>CountedString</B> objects are created, using the same <B>String</B> to show
that the duplicates create unique values because of the count <B>id</B>. The
<B>HashMap</B> is displayed so that you can see how it is stored internally (no
discernible orders) and then each key is looked up individually to demonstrate
that the lookup mechanism is working properly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I154' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I155>
</FONT><A NAME="_Toc481064694"></A><BR></P></DIV>
<A NAME="Heading311"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Holding references</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>java.lang.ref</B> library contains
a set of classes that allow greater flexibility in garbage collection, which are
especially useful when you have large objects that may cause memory exhaustion.
There are three classes inherited from the abstract class
<A NAME="Index999"></A><B>Reference</B>:
<A NAME="Index1000"></A><B>SoftReference</B>,<B>
<A NAME="Index1001"></A>WeakReference</B>, and<B>
<A NAME="Index1002"></A>PhantomReference</B>. Each of these provides a different
level of indirection for the garbage collector, if the object in question is
<I>only</I> reachable through one of these <B>Reference</B> objects. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I155' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I156>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If an object is
<A NAME="Index1003"></A><A NAME="Index1004"></A><I>reachable</I> it means that
somewhere in your program the object can be found. This could mean that you have
an ordinary reference on the stack that goes right to the object, but you might
also have a reference to an object that has a reference to the object in
question; there could be many intermediate links. If an object is reachable, the
garbage collector cannot release it because it&#8217;s still in use by your
program. If an object isn&#8217;t reachable, there&#8217;s no way for your
program to use it so it&#8217;s safe to garbage-collect that object.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I156' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I157>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You use <B>Reference</B> objects when you
want to continue to hold onto a reference to that object&#8212;you want to be
able to reach that object&#8212;but you also want to allow the garbage collector
to release that object. Thus, you have a way to go on using the object, but if
<A NAME="Index1005"></A>memory exhaustion is imminent you allow that object to
be released. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I157' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I158>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You accomplish this by using a
<B>Reference</B> object as an intermediary between you and the ordinary
reference, <I>and</I> there must be no ordinary references to the object (ones
that are not wrapped inside <B>Reference</B> objects). If the garbage collector
discovers that an object is reachable through an ordinary reference, it will not
release that object. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I158' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I159>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the order <B>SoftReference</B>,<B>
WeakReference</B>, and<B> PhantomReference</B>, each one is &#8220;weaker&#8221;
than the last, and corresponds to a different level of reachability. Soft
references are for implementing memory-sensitive caches. Weak references are for
implementing &#8220;canonicalizing mappings&#8221;&#8212;where instances of
objects can be simultaneously used in multiple places in a program, to save
storage&#8212;that do not prevent their keys (or values) from being reclaimed.
Phantom references are for scheduling pre-mortem cleanup actions in a more
flexible way than is possible with the Java finalization mechanism.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I159' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I160>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">With <B>SoftReference</B>s and<B>
WeakReference</B>s, you have a choice about whether to place them on a
<B>ReferenceQueue</B> (the device used for premortem cleanup actions), but a
<B>PhantomReference</B> can only be built on a <B>ReferenceQueue</B>.
Here&#8217;s a simple demonstration:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:References.java</font>
<font color=#009900>// Demonstrates Reference objects</font>
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> VeryBig {
  <font color=#0000ff>static</font> <font color=#0000ff>final</font> <font color=#0000ff>int</font> SZ = 10000;
  <font color=#0000ff>double</font>[] d = <font color=#0000ff>new</font> <font color=#0000ff>double</font>[SZ];
  String ident;
  <font color=#0000ff>public</font> VeryBig(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing "</font> + ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> References {
  <font color=#0000ff>static</font> ReferenceQueue rq= <font color=#0000ff>new</font> ReferenceQueue();
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> checkQueue() {
    Object inq = rq.poll();
    <font color=#0000ff>if</font>(inq != <font color=#0000ff>null</font>)
      System.out.println(<font color=#004488>"In queue: "</font> + 
        (VeryBig)((Reference)inq).get());
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 10;
    <font color=#009900>// Or, choose size via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);    
    SoftReference[] sa =
      <font color=#0000ff>new</font> SoftReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sa.length; i++) {
      sa[i] = <font color=#0000ff>new</font> SoftReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)sa[i].get());
      checkQueue();
    }
    WeakReference[] wa =
      <font color=#0000ff>new</font> WeakReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; wa.length; i++) {
      wa[i] = <font color=#0000ff>new</font> WeakReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)wa[i].get());
      checkQueue();
    }
    SoftReference s = <font color=#0000ff>new</font> SoftReference(
      <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Soft"</font>));
    WeakReference w = <font color=#0000ff>new</font> WeakReference(
      <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Weak"</font>));
    System.gc();
    PhantomReference[] pa =
      <font color=#0000ff>new</font> PhantomReference[size];
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; pa.length; i++) {
      pa[i] = <font color=#0000ff>new</font> PhantomReference(
        <font color=#0000ff>new</font> VeryBig(<font color=#004488>"Phantom "</font> + i), rq);
      System.out.println(<font color=#004488>"Just created: "</font> +
        (VeryBig)pa[i].get());
      checkQueue();
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program (you&#8217;ll
want to pipe the output through a &#8220;more&#8221; utility so that you can
view the output in pages), you&#8217;ll see that the objects are
garbage-collected, even though you still have access to them through the
<B>Reference</B> object (to get the actual object reference, you use
<B>get(&#160;)</B>). You&#8217;ll also see that the <B>ReferenceQueue</B> always
produces a <B>Reference</B> containing a <B>null</B> object. To make use of
this, you can inherit from the particular <B>Reference</B> class you&#8217;re
interested in and add more useful methods to the new type of <B>Reference</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I160' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I161>
</FONT><A NAME="_Toc481064695"></A><BR></P></DIV>
<A NAME="Heading312"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The WeakHashMap</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The containers library has a special
<B>Map</B> to hold weak references: the
<A NAME="Index1006"></A><B>WeakHashMap</B>. This class is designed to make the
creation of canonicalized mappings easier. In such a mapping, you are saving
storage by making only one instance of a particular value. When the program
needs that value, it looks up the existing object in the mapping and uses that
(rather than creating one from scratch). The mapping may make the values as part
of its initialization, but it&#8217;s more likely that the values are made on
demand.  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I161' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I162>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since this is a storage-saving technique,
it&#8217;s very convenient that the <B>WeakHashMap</B> allows the garbage
collector to automatically clean up the keys and values. You don&#8217;t have to
do anything special to the keys and values you want to place in the
<B>WeakHashMap</B>; these are automatically wrapped in <B>WeakReference</B>s by
the map. The trigger to allow cleanup is if the key is no longer in use, as
demonstrated here:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:CanonicalMapping.java</font>
<font color=#009900>// Demonstrates WeakHashMap.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> java.lang.ref.*;

<font color=#0000ff>class</font> Key {
  String ident;
  <font color=#0000ff>public</font> Key(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>int</font> hashCode() { 
    <font color=#0000ff>return</font> ident.hashCode();
  }
  <font color=#0000ff>public</font> <font color=#0000ff>boolean</font> equals(Object r) {
    <font color=#0000ff>return</font> (r <font color=#0000ff>instanceof</font> Key)
      &amp;&amp; ident.equals(((Key)r).ident);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Key "</font>+ ident);
  }
}

<font color=#0000ff>class</font> Value {
  String ident;
  <font color=#0000ff>public</font> Value(String id) { ident = id; }
  <font color=#0000ff>public</font> String toString() { <font color=#0000ff>return</font> ident; }
  <font color=#0000ff>public</font> <font color=#0000ff>void</font> finalize() {
    System.out.println(<font color=#004488>"Finalizing Value "</font>+ident);
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> CanonicalMapping {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> size = 1000;
    <font color=#009900>// Or, choose size via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      size = Integer.parseInt(args[0]);    
    Key[] keys = <font color=#0000ff>new</font> Key[size];
    WeakHashMap whm = <font color=#0000ff>new</font> WeakHashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++) {
      Key k = <font color=#0000ff>new</font> Key(Integer.toString(i));
      Value v = <font color=#0000ff>new</font> Value(Integer.toString(i));
      <font color=#0000ff>if</font>(i % 3 == 0)
        keys[i] = k; <font color=#009900>// Save as "real" references</font>
      whm.put(k, v);
    }
    System.gc();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>Key</B> class must have a
<B>hashCode(&#160;)</B> and an <B>equals(&#160;)</B> since it is being used as a
key in a hashed data structure, as described previously in this chapter.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I162' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I163>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program you&#8217;ll see
that the garbage collector will skip every third key, because an ordinary
reference to that key has also been placed in the <B>keys</B> array and thus
those objects cannot be garbage-collected.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I163' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I164>
</FONT><A NAME="_Toc375545358"></A><A NAME="_Toc481064696"></A><BR></P></DIV>
<A NAME="Heading313"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Iterators revisited</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">We can now demonstrate the true power of
the <A NAME="Index1007"></A><B>Iterator</B>: the ability to separate the
operation of traversing a sequence from the underlying structure of that
sequence. In the following example, the class <B>PrintData</B> uses an
<B>Iterator</B> to move through a sequence and call the
<A NAME="Index1008"></A><B>toString(&#160;)</B> method for every object. Two
different types of containers are created&#8212;an
<A NAME="Index1009"></A><B>ArrayList</B> and a
<A NAME="Index1010"></A><B>HashMap</B>&#8212;and they are each filled with,
respectively, <B>Mouse </B>and <B>Hamster </B>objects. (These classes are
defined earlier in this chapter.) Because an <B>Iterator </B>hides the structure
of the underlying container, <B>PrintData</B> doesn&#8217;t know or care what
kind of container the <B>Iterator </B>comes from:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Iterators2.java</font>
<font color=#009900>// Revisiting Iterators.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>class</font> PrintData {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> print(Iterator e) {
    <font color=#0000ff>while</font>(e.hasNext())
      System.out.println(e.next());
  }
}

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Iterators2 {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    ArrayList v = <font color=#0000ff>new</font> ArrayList();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      v.add(<font color=#0000ff>new</font> Mouse(i));
    HashMap m = <font color=#0000ff>new</font> HashMap();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 5; i++)
      m.put(<font color=#0000ff>new</font> Integer(i), <font color=#0000ff>new</font> Hamster(i));
    System.out.println(<font color=#004488>"ArrayList"</font>);
    PrintData.print(v.iterator());
    System.out.println(<font color=#004488>"HashMap"</font>);
    PrintData.print(m.entrySet().iterator());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For the <B>HashMap</B>, the
<B>entrySet(&#160;)</B> method produces a <B>Set</B> of <B>Map.entry</B>
objects, which contain both the key and the value for each entry, so you see
both of them printed. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I164' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I165>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>PrintData.print(&#160;)</B>
takes advantage of the fact that the objects in these containers are of class
<B>Object</B> so the call <B>toString(&#160;)</B> by
<B>System.out.println(&#160;) </B>is automatic. It&#8217;s more likely that in
your problem, you must make the assumption that your <B>Iterator</B> is walking
through a container of some specific type. For example, you might assume that
everything in the container is a <B>Shape</B> with a <B>draw(&#160;)</B> method.
Then you must downcast from the <B>Object </B>that <B>Iterator.next(&#160;)</B>
returns to produce a <B>Shape</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I165' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I166>
</FONT><A NAME="_Toc481064697"></A><BR></P></DIV>
<A NAME="Heading314"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Choosing an implementation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By now you should understand that there
are really only three container components: <B>Map</B>, <B>List</B>, and
<B>Set</B>, and only two or three implementations of each interface. If you need
to use the functionality offered by a particular <B>interface</B>, how do you
decide which particular implementation to use?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I166' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I167>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the answer, you must be
aware that each different implementation has its own features, strengths, and
weaknesses. For example, you can see in the diagram that the
&#8220;feature&#8221; of <B>Hashtable</B>, <B>Vector</B>, and <B>Stack</B> is
that they are legacy classes, so that old code doesn&#8217;t break. On the other
hand, it&#8217;s best if you don&#8217;t use those for new (Java 2) code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I167' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I168>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The distinction between the other
containers often comes down to what they are &#8220;backed by&#8221;; that is,
the data structures that physically implement your desired <B>interface</B>.
This means that, for example, <B>ArrayList</B> and<B> LinkedList </B>implement
the <B>List</B> interface so your program will produce the same results
regardless of the one you use. However, <B>ArrayList</B> is backed by an array,
while the <B>LinkedList</B> is implemented in the usual way for a doubly linked
list, as individual objects each containing data along with references to the
previous and next elements in the list. Because of this, if you want to do many
insertions and removals in the middle of a list, a <B>LinkedList</B> is the
appropriate choice. (<B>LinkedList</B> also has additional functionality that is
established in <A NAME="Index1011"></A><B>AbstractSequentialList</B>.) If not,
an <B>ArrayList</B> is typically faster.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I168' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I169>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As another example, a <B>Set</B> can be
implemented as either a <B>TreeSet</B> or a <B>HashSet</B>. A <B>TreeSet</B> is
backed by a <B>TreeMap</B> and is designed to produce a constantly sorted set.
However, if you&#8217;re going to have larger quantities in your <B>Set</B>, the
performance of <B>TreeSet</B> insertions will get slow. When you&#8217;re
writing a program that needs a <B>Set</B>, you should choose <B>HashSet</B> by
default, and change to <B>TreeSet</B> when it's more important to have a
constantly sorted set.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I169' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I170>
</FONT><A NAME="_Toc481064698"></A><BR></P></DIV>
<A NAME="Heading315"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Choosing between Lists</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The most convincing way to see the
differences between the implementations of <B>List</B> is with a performance
test. The following code establishes an inner base class to use as a test
framework, then creates an array of
<A NAME="Index1012"></A><A NAME="Index1013"></A><A NAME="Index1014"></A>anonymous
inner classes, one for each different test. Each of these inner classes is
called by the <B>test(&#160;)</B> method. This approach allows you to easily add
and remove new kinds of tests.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ListPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Lists.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    <font color=#0000ff>int</font> size; <font color=#009900>// Test quantity</font>
    Tester(String name, <font color=#0000ff>int</font> size) { 
      <font color=#0000ff>this</font>.name = name;
      <font color=#0000ff>this</font>.size = size;
    }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; a.size(); j++)
            a.get(j);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>, 300) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          Iterator it = a.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"insert"</font>, 5000) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>int</font> half = a.size()/2;
        String s = <font color=#004488>"test"</font>;
        ListIterator it = a.listIterator(half);
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size * 10; i++)
          it.add(s);
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"remove"</font>, 5000) { 
      <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
        ListIterator it = a.listIterator(3);
        <font color=#0000ff>while</font>(it.hasNext()) {
          it.next();
          it.remove();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> test(List a, <font color=#0000ff>int</font> reps) {
    <font color=#009900>// A trick to print out the class name:</font>
    System.out.println(<font color=#004488>"Testing "</font> + 
      a.getClass().getName());
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      Collections2.fill(a, 
        Collections2.countries.reset(),
        tests[i].size);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> testArray(<font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing array as List"</font>);
    <font color=#009900>// Can only do first two tests on an array:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 2; i++) {
      String[] sa = <font color=#0000ff>new</font> String[tests[i].size];
      Arrays2.fill(sa, 
        Collections2.countries.reset());
      List a = Arrays.asList(sa);
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(a, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + (t2 - t1));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Or, choose the number of repetitions</font>
    <font color=#009900>// via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    System.out.println(reps + <font color=#004488>" repetitions"</font>);
    testArray(reps);
    test(<font color=#0000ff>new</font> ArrayList(), reps);
    test(<font color=#0000ff>new</font> LinkedList(), reps);
    test(<font color=#0000ff>new</font> Vector(), reps);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The inner class <B>Tester</B> is
<B>abstract</B>, to provide a base class for the specific tests. It contains a
<B>String</B> to be printed when the test starts, a <B>size </B>parameter to be
used by the test for quantity of elements or repetitions of tests, a constructor
to initialize the fields, and an <B>abstract</B> method <B>test(&#160;)</B> that
does the work. All the different types of tests are collected in one place, the
array <B>tests</B>, which is initialized with different anonymous inner classes
that inherit from <B>Tester</B>. To add or remove tests, simply add or remove an
inner class definition from the array, and everything else happens
automatically. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I170' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I171>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To compare array access to container
access (primarily against <B>ArrayList</B>), a special test is created for
arrays by wrapping one as a <B>List</B> using <B>Arrays.asList(&#160;)</B>. Note
that only the first two tests can be performed in this case, because you cannot
insert or remove elements from an array.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I171' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I172>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>List</B> that&#8217;s handed to
<B>test(&#160;)</B> is first filled with elements, then each test in the
<B>tests</B> array is timed. The results will vary from machine to machine; they
are intended to give only an order of magnitude comparison between the
performance of the different containers. Here is a summary of one
run:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Type</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Get</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Iteration</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Insert</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Remove</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">array</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1430</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">3850</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">na</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">na</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>ArrayList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">3070</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">12200</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">500</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">46850</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>LinkedList</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">16320</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">9110</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">60</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Vector</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">4890</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">16250</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">550</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">46850</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As expected, arrays are faster than any
container for random-access lookups and iteration. You can see that random
accesses (<B>get(&#160;)</B>) are cheap for <B>ArrayList</B>s and expensive for
<B>LinkedList</B>s. (Oddly, iteration is <I>faster</I> for a
<A NAME="Index1015"></A><B>LinkedList</B> than an
<A NAME="Index1016"></A><B>ArrayList</B>, which is a bit counterintuitive.) On
the other hand, insertions and removals from the middle of a list are
dramatically cheaper for a <B>LinkedList</B> than for an
<B>ArrayList</B>&#8212;<I>especially</I> removals.
<A NAME="Index1017"></A><B>Vector </B>is generally not as fast as
<B>ArrayList</B>, and it should be avoided; it&#8217;s only in the library for
legacy code support (the only reason it works in this program is because it was
adapted to be a <B>List</B> in Java 2).<B> </B>The best approach is probably to
choose an <B>ArrayList</B> as your default, and to change to a <B>LinkedList</B>
if you discover performance problems due to many insertions and removals from
the middle of the list. And of course, if you are working with a fixed-sized
group of elements, use an array.</FONT><A NAME="_Toc481064699"></A><BR></P></DIV>
<A NAME="Heading316"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Choosing between Sets</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can choose between a
<A NAME="Index1018"></A><B>TreeSet </B>and a
<A NAME="Index1019"></A><B>HashSet</B>, depending on the size of the
<A NAME="Index1020"></A><B>Set</B> (if you need to produce an ordered sequence
from a <B>Set</B>, use <B>TreeSet</B>).<B> </B>The following test program gives
an indication of this trade-off:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I172' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I173>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:SetPerformance.java</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> SetPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"add"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          s.clear();
          Collections2.fill(s, 
            Collections2.countries.reset(),size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"contains"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            s.contains(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = s.iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  test(Set s, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing "</font> + 
      s.getClass().getName() + <font color=#004488>" size "</font> + size);
    Collections2.fill(s, 
      Collections2.countries.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(s, size, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Or, choose the number of repetitions</font>
    <font color=#009900>// via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 10, reps);
    test(<font color=#0000ff>new</font> HashSet(), 10, reps);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 100, reps);
    test(<font color=#0000ff>new</font> HashSet(), 100, reps);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> TreeSet(), 1000, reps);
    test(<font color=#0000ff>new</font> HashSet(), 1000, reps);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following table shows the results of
one run. (Of course, this will be different according to the computer and JVM
you are using; you should run the test yourself as well):</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Type</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Test size</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Add</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Contains</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Iteration</B></FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">138.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">115.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">187.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeSet </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">189.5</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">151.1</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">206.5</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">150.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">177.4</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">40.04</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">55.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">82.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">192.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashSet </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">45.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">90.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">202.2</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">36.14</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">106.5</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">39.39</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The performance of <B>HashSet</B> is
generally superior to <B>TreeSet</B> for all operations (but in particular
addition and lookup, the two most important operations). The only reason
<B>TreeSet</B> exists is because it maintains its elements in sorted order, so
you only use it when you need a sorted
<B>Set</B>.</FONT><A NAME="_Toc481064700"></A><BR></P></DIV>
<A NAME="Heading317"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Choosing between Maps</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When choosing between implementations of
<A NAME="Index1021"></A><B>Map</B>, the size of the <B>Map</B> is what most
strongly affects performance, and the following test program gives an indication
of this trade-off: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I173' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I174>
</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:MapPerformance.java</font>
<font color=#009900>// Demonstrates performance differences in Maps.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> MapPerformance {
  <font color=#0000ff>private</font> <font color=#0000ff>abstract</font> <font color=#0000ff>static</font> <font color=#0000ff>class</font> Tester {
    String name;
    Tester(String name) { <font color=#0000ff>this</font>.name = name; }
    <font color=#0000ff>abstract</font> <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps);
  }
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> Tester[] tests = {
    <font color=#0000ff>new</font> Tester(<font color=#004488>"put"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++) {
          m.clear();
          Collections2.fill(m, 
            Collections2.geography.reset(), size);
        }
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"get"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps; i++)
          <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; size; j++)
            m.get(Integer.toString(j));
      }
    },
    <font color=#0000ff>new</font> Tester(<font color=#004488>"iteration"</font>) { 
      <font color=#0000ff>void</font> test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
        <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; reps * 10; i++) {
          Iterator it = m.entrySet().iterator();
          <font color=#0000ff>while</font>(it.hasNext())
            it.next();
        }
      }
    },
  };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> 
  test(Map m, <font color=#0000ff>int</font> size, <font color=#0000ff>int</font> reps) {
    System.out.println(<font color=#004488>"Testing "</font> + 
      m.getClass().getName() + <font color=#004488>" size "</font> + size);
    Collections2.fill(m, 
      Collections2.geography.reset(), size);
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; tests.length; i++) {
      System.out.print(tests[i].name);
      <font color=#0000ff>long</font> t1 = System.currentTimeMillis();
      tests[i].test(m, size, reps);
      <font color=#0000ff>long</font> t2 = System.currentTimeMillis();
      System.out.println(<font color=#004488>": "</font> + 
        ((<font color=#0000ff>double</font>)(t2 - t1)/(<font color=#0000ff>double</font>)size));
    }
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    <font color=#0000ff>int</font> reps = 50000;
    <font color=#009900>// Or, choose the number of repetitions</font>
    <font color=#009900>// via the command line:</font>
    <font color=#0000ff>if</font>(args.length &gt; 0)
      reps = Integer.parseInt(args[0]);
    <font color=#009900>// Small:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 10, reps);
    test(<font color=#0000ff>new</font> HashMap(), 10, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 10, reps);
    <font color=#009900>// Medium:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 100, reps);
    test(<font color=#0000ff>new</font> HashMap(), 100, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 100, reps);
    <font color=#009900>// Large:</font>
    test(<font color=#0000ff>new</font> TreeMap(), 1000, reps);
    test(<font color=#0000ff>new</font> HashMap(), 1000, reps);
    test(<font color=#0000ff>new</font> Hashtable(), 1000, reps);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because the size of the map is the issue,
you&#8217;ll see that the timing tests divide the time by the size to normalize
each measurement. Here is one set of results. (Yours will probably be
different.)</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=76 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Type </B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Test size</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=45 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Put</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=53 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Get</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=72 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Iteration</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">143.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">186.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>TreeMap </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">201.1</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">188.4</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">280.1</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">222.8</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">205.2</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">40.7</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B> </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">66.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">83.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">197.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>HashMap</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">80.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">135.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">278.5</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">48.2</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">105.7</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">41.4</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B> </B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">10</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">61.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">93.0</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">302.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Hashtable</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">100</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">90.6</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">143.3</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">329.0</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<BR></TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">1000</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">54.1</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">110.95</FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">47.3</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you might expect,
<A NAME="Index1022"></A><B>Hashtable</B> performance is roughly equivalent to
<B>HashMap</B>. (You can also see that <B>HashMap</B> is generally a bit faster.
<B>HashMap</B> is intended to replace <B>Hashtable</B>.) The
<A NAME="Index1023"></A><B>TreeMap </B>is generally slower than the
<B>HashMap</B>, so why would you use it? So you could use it not as a
<B>Map</B>,<B> </B>but as a way to create an ordered list. The behavior of a
tree is such that it&#8217;s always in order and doesn&#8217;t have to be
specially sorted. Once you fill a <B>TreeMap</B>, you can call
<A NAME="Index1024"></A><B>keySet(&#160;)</B> to get a <B>Set</B> view of the
keys, then <A NAME="Index1025"></A><B>toArray(&#160;)</B> to produce an array of
those keys. You can then use the <B>static </B>method
<B>Arrays.binarySearch(&#160;)</B> (discussed later) to rapidly find objects in
your sorted array. Of course, you would probably only do this if, for some
reason, the behavior of a <B>HashMap</B> was unacceptable, since <B>HashMap
</B>is designed to rapidly find things. Also, you can easily create a <B>HashMap
</B>from a <B>TreeMap </B>with a single object creation In the end, when
you&#8217;re using a <B>Map </B>your first choice should be <B>HashMap</B>, and
only if you need a constantly sorted <B>Map</B> will you need
<B>TreeMap</B>.</FONT><A NAME="_Toc481064701"></A><BR></P></DIV>
<A NAME="Heading318"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Sorting and searching
Lists<BR><A NAME="Index1026"></A><A NAME="Index1027"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Utilities to perform sorting and
searching for <A NAME="Index1028"></A><B>List</B>s have the same names and
signatures as those for sorting arrays of objects, but are <B>static </B>methods
of <A NAME="Index1029"></A><B>Collections</B> instead of <B>Arrays</B>.
Here&#8217;s an example, modified from
<B>ArraySearching.java</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ListSortSearch.java</font>
<font color=#009900>// Sorting and searching Lists with 'Collections.'</font>
<font color=#0000ff>import</font> com.bruceeckel.util.*;
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ListSortSearch {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    List list = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(list, 
      Collections2.capitals, 25);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Collections.shuffle(list);
    System.out.println(<font color=#004488>"After shuffling: "</font>+list);
    Collections.sort(list);
    System.out.println(list + <font color=#004488>"\n"</font>);
    Object key = list.get(12);
    <font color=#0000ff>int</font> index = 
      Collections.binarySearch(list, key);
    System.out.println(<font color=#004488>"Location of "</font> + key + 
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> + 
      index + <font color=#004488>") = "</font> + list.get(index));
    AlphabeticComparator comp =
      <font color=#0000ff>new</font> AlphabeticComparator();
    Collections.sort(list, comp);
    System.out.println(list + <font color=#004488>"\n"</font>);
    key = list.get(12);
    index = 
      Collections.binarySearch(list, key, comp);
    System.out.println(<font color=#004488>"Location of "</font> + key + 
      <font color=#004488>" is "</font> + index + <font color=#004488>", list.get("</font> + 
      index + <font color=#004488>") = "</font> + list.get(index));
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The use of these methods is identical to
the ones in <B>Arrays</B>, but you&#8217;re using a <B>List</B> instead of an
array. Just like searching and sorting with arrays, if you sort using a
<B>Comparator</B> you must <B>binarySearch(&#160;)</B> using the same
<B>Comparator</B>. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I174' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I175>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program also demonstrates the
<A NAME="Index1030"></A><B>shuffle(&#160;)</B> method in <B>Collections</B>,
which randomizes the order of a <B>List</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I175' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I176>
</FONT><A NAME="_Toc481064702"></A><BR></P></DIV>
<A NAME="Heading319"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Utilities</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are a number of other useful
utilities in the <B>Collections</B> class:
<A NAME="Index1031"></A><A NAME="Index1032"></A></FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>enumeration(Collection)
</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces an old-style <B>Enumeration</B>
for the argument.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>max(Collection) </B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>min(Collection)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the maximum or minimum element
in the argument using the natural comparison method of the objects in the
<B>Collection</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>max(Collection, Comparator)
</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>min(Collection,
Comparator)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produces the maximum or minimum element
in the <B>Collection</B> using the <B>Comparator</B>. </FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>reverse(&#160;)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Reverses all the elements in
place.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>copy(List dest, List
src)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Copies elements from src to
dest.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>fill(List list, Object
o)</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Replaces all the elements of list with
o.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>nCopies(int n, Object o)
</B></FONT><BR></P></DIV>
</TD>
<TD>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Returns an immutable <B>List</B> of size
n whose references all point to o. </FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>min(&#160;)</B> and
<B>max(&#160;)</B> work with <B>Collection</B> objects, not with <B>List</B>s,
so you don&#8217;t need to worry about whether the <B>Collection</B> should be
sorted or not. (As mentioned earlier, you <I>do</I> need to <B>sort(&#160;)</B>
a <B>List</B> or an array before performing a <B>binarySearch(&#160;)</B>.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I176' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I177>
</FONT><A NAME="_Toc481064703"></A><BR></P></DIV>
<A NAME="Heading320"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Making a Collection or Map unmodifiable<BR><A NAME="Index1033"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Often it is convenient to create a
read-only version of a <B>Collection</B> or <B>Map</B>. The <B>Collections</B>
class allows you to do this by passing the original container into a method that
hands back a read-only version. There are four variations on this method, one
each for <B>Collection</B> (if you don&#8217;t want to treat a <B>Collection
</B>as a more specific type), <B>List</B>, <B>Set,</B> and <B>Map</B>. This
example shows the proper way to build read-only versions of
each:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:ReadOnly.java</font>
<font color=#009900>// Using the Collections.unmodifiable methods.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> ReadOnly {
  <font color=#0000ff>static</font> Collections2.StringGenerator gen = 
    Collections2.countries;
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(c, gen, 25); <font color=#009900>// Insert data</font>
    c = Collections.unmodifiableCollection(c);
    System.out.println(c); <font color=#009900>// Reading is OK</font>
    c.add(<font color=#004488>"one"</font>); <font color=#009900>// Can't change it</font>
    
    List a = <font color=#0000ff>new</font> ArrayList();
    Collections2.fill(a, gen.reset(), 25);
    a = Collections.unmodifiableList(a);
    ListIterator lit = a.listIterator();
    System.out.println(lit.next()); <font color=#009900>// Reading OK</font>
    lit.add(<font color=#004488>"one"</font>); <font color=#009900>// Can't change it</font>

    Set s = <font color=#0000ff>new</font> HashSet();
    Collections2.fill(s, gen.reset(), 25);
    s = Collections.unmodifiableSet(s);
    System.out.println(s); <font color=#009900>// Reading OK</font>
    <font color=#009900>//! s.add("one"); // Can't change it</font>
    
    Map m = <font color=#0000ff>new</font> HashMap();
    Collections2.fill(m,
      Collections2.geography, 25);
    m = Collections.unmodifiableMap(m);
    System.out.println(m); <font color=#009900>// Reading OK</font>
    <font color=#009900>//! m.put("Ralph", "Howdy!");</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In each case, you must fill the container
with meaningful data <I>before</I> you make it read-only. Once it is loaded, the
best approach is to replace the existing reference with the reference that is
produced by the &#8220;unmodifiable&#8221; call. That way, you don&#8217;t run
the risk of accidentally changing the contents once you&#8217;ve made it
unmodifiable. On the other hand, this tool also allows you to keep a modifiable
container as <B>private</B> within a class and to return a read-only reference
to that container from a method call. So you can change it from within the
class, but everyone else can only read it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I177' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I178>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Calling the &#8220;unmodifiable&#8221;
method for a particular type does not cause compile-time checking, but once the
transformation has occurred, any calls to methods that modify the contents of a
particular container will produce an <B>UnsupportedOperationException</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I178' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I179>
</FONT><A NAME="_Toc481064704"></A><BR></P></DIV>
<A NAME="Heading321"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Synchronizing a Collection or Map</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index1034"></A><B>synchronized</B> keyword is an important part of the
subject of <A NAME="Index1035"></A><I>multithreading</I>, a more complicated
topic that will not be introduced until Chapter 14. Here, I shall note only that
the <B>Collections</B> class contains a way to automatically synchronize an
entire container. The syntax is similar to the &#8220;unmodifiable&#8221;
methods:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Synchronization.java</font>
<font color=#009900>// Using the Collections.synchronized methods.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Synchronization {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = 
      Collections.synchronizedCollection(
        <font color=#0000ff>new</font> ArrayList());
    List list = Collections.synchronizedList(
      <font color=#0000ff>new</font> ArrayList());
    Set s = Collections.synchronizedSet(
      <font color=#0000ff>new</font> HashSet());
    Map m = Collections.synchronizedMap(
      <font color=#0000ff>new</font> HashMap());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this case, you immediately pass the
new container through the appropriate &#8220;synchronized&#8221; method; that
way there&#8217;s no chance of accidentally exposing the unsynchronized version.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I179' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I180>
</FONT><BR></P></DIV>
<A NAME="Heading322"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Fail fast<BR><A NAME="Index1036"></A><A NAME="Index1037"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java containers also have a mechanism
to prevent more than one process from modifying the contents of a container. The
problem occurs if you&#8217;re iterating through a container and some other
process steps in and inserts, removes, or changes an object in that container.
Maybe you&#8217;ve already passed that object, maybe it&#8217;s ahead of you,
maybe the size of the container shrinks after you call
<B>size(&#160;)</B>&#8212;there are many scenarios for disaster. The Java
containers library incorporates a <I>fail-fast</I> mechanism that looks for any
changes to the container other than the ones your process is personally
responsible for. If it detects that someone else is modifying the container, it
immediately produces a <B>ConcurrentModificationException</B>. This is the
&#8220;fail-fast&#8221; aspect&#8212;it doesn&#8217;t try to detect a problem
later on using a more complex algorithm.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I180' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I181>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s quite easy to see the
fail-fast mechanism in operation&#8212;all you have to do is create an iterator
and then add something to the collection that the iterator is pointing to, like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:FailFast.java</font>
<font color=#009900>// Demonstrates the "fail fast" behavior.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> FailFast {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Collection c = <font color=#0000ff>new</font> ArrayList();
    Iterator it = c.iterator();
    c.add(<font color=#004488>"An object"</font>);
    <font color=#009900>// Causes an exception:</font>
    String s = (String)it.next();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The exception happens because something
is placed in the container <I>after</I> the iterator is acquired from the
container. The possibility that two parts of the program could be modifying the
same container produces an uncertain state, so the exception notifies you that
you should change your code&#8212;in this case, acquire the iterator
<I>after</I> you have added all the elements to the container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I181' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I182>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that you cannot benefit from this
kind of monitoring when you&#8217;re accessing the elements of a <B>List</B>
using <B>get(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I182' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I183>
</FONT><A NAME="_Toc481064705"></A><BR></P></DIV>
<A NAME="Heading323"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Unsupported
operations<BR><A NAME="Index1038"></A><A NAME="Index1039"></A><A NAME="Index1040"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s possible to turn an array into
a <B>List</B> with the <B>Arrays.asList(&#160;)</B> method:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Unsupported.java</font>
<font color=#009900>// Sometimes methods defined in the</font>
<font color=#009900>// Collection interfaces don't work!</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Unsupported {
  <font color=#0000ff>private</font> <font color=#0000ff>static</font> String[] s = {
    <font color=#004488>"one"</font>, <font color=#004488>"two"</font>, <font color=#004488>"three"</font>, <font color=#004488>"four"</font>, <font color=#004488>"five"</font>,
    <font color=#004488>"six"</font>, <font color=#004488>"seven"</font>, <font color=#004488>"eight"</font>, <font color=#004488>"nine"</font>, <font color=#004488>"ten"</font>,
  };
  <font color=#0000ff>static</font> List a = Arrays.asList(s);
  <font color=#0000ff>static</font> List a2 = a.subList(3, 6);
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    System.out.println(a);
    System.out.println(a2);
    System.out.println(
      <font color=#004488>"a.contains("</font> + s[0] + <font color=#004488>") = "</font> + 
      a.contains(s[0]));
    System.out.println(
      <font color=#004488>"a.containsAll(a2) = "</font> + 
      a.containsAll(a2));
    System.out.println(<font color=#004488>"a.isEmpty() = "</font> +
      a.isEmpty());
    System.out.println(
      <font color=#004488>"a.indexOf("</font> + s[5] + <font color=#004488>") = "</font> + 
      a.indexOf(s[5]));
    <font color=#009900>// Traverse backwards:</font>
    ListIterator lit = a.listIterator(a.size());
    <font color=#0000ff>while</font>(lit.hasPrevious())
      System.out.print(lit.previous() + <font color=#004488>" "</font>);
    System.out.println();
    <font color=#009900>// Set the elements to different values:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; a.size(); i++)
      a.set(i, <font color=#004488>"47"</font>);
    System.out.println(a);
    <font color=#009900>// Compiles, but won't run:</font>
    lit.add(<font color=#004488>"X"</font>); <font color=#009900>// Unsupported operation</font>
    a.clear(); <font color=#009900>// Unsupported</font>
    a.add(<font color=#004488>"eleven"</font>); <font color=#009900>// Unsupported</font>
    a.addAll(a2); <font color=#009900>// Unsupported</font>
    a.retainAll(a2); <font color=#009900>// Unsupported</font>
    a.remove(s[0]); <font color=#009900>// Unsupported</font>
    a.removeAll(a2); <font color=#009900>// Unsupported</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll discover that only a portion
of the <B>Collection</B> and <B>List </B>interfaces are actually implemented.
The rest of the methods cause the unwelcome appearance of something called an
<B>UnsupportedOperationException</B>. You&#8217;ll learn all about exceptions in
the next chapter, but the short story is that the <B>Collection</B>
<B>interface</B>&#8212;as well as some of the other <B>interface</B>s in the
Java containers library&#8212;contain &#8220;optional&#8221; methods, which
might or might not be &#8220;supported&#8221; in the concrete class that
<B>implements</B> that <B>interface</B>. Calling an unsupported method causes an
<B>UnsupportedOperationException</B> to indicate a programming error.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I183' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I184>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">&#8220;What?!?&#8221; you say,
incredulous. &#8220;The whole point of <B>interface</B>s and base classes is
that they promise these methods will do something meaningful! This breaks that
promise&#8212;it says that not only will calling some methods <I>not</I> perform
a meaningful behavior, they will stop the program! Type safety was just thrown
out the window!&#8221;  
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I184' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I185>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It&#8217;s not quite that bad. With a
<B>Collection</B>, <B>List</B>, <B>Set</B>, or <B>Map</B>, the compiler still
restricts you to calling only the methods in that <B>interface</B>, so
it&#8217;s not like Smalltalk (in which you can call any method for any object,
and find out only when you run the program whether your call does anything). In
addition, most methods that take a <B>Collection</B> as an argument only read
from that <B>Collection</B>&#8212;all the &#8220;read&#8221; methods of
<B>Collection </B>are <I>not</I> optional.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I185' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I186>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This approach prevents an explosion of
interfaces in the design. Other designs for container libraries always seem to
end up with a confusing plethora of interfaces to describe each of the
variations on the main theme and are thus difficult to learn. It&#8217;s not
even possible to capture all of the special cases in <B>interface</B>s, because
someone can always invent a new <B>interface</B>. The &#8220;unsupported
operation&#8221; approach achieves an important goal of the Java containers
library: the containers are simple to learn and use; unsupported operations are
a special case that can be learned later. For this approach to work, however:

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I186' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I187>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
<B>UnsupportedOperationException</B> must be a rare event. That is, for most
classes all operations should work, and only in special cases should an
operation be unsupported. This is true in the Java containers library, since the
classes you&#8217;ll use 99 percent of the time&#8212;<B>ArrayList</B>,
<B>LinkedList</B>, <B>HashSet</B>, and <B>HashMap</B>, as well as the other
concrete implementations&#8212;support all of the operations. The design does
provide a &#8220;back door&#8221; if you want to create a new <B>Collection</B>
without providing meaningful definitions for all the methods in the
<B>Collection</B> <B>interface</B>, and yet still fit it into the existing
library.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I187' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I188>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">When
an operation <I>is</I> unsupported, there should be reasonable likelihood that
an <B>UnsupportedOperationException</B> will appear at implementation time,
rather than after you&#8217;ve shipped the product to the customer. After all,
it indicates a programming error: you&#8217;ve used an implementation
incorrectly. This point is less certain, and is where the experimental nature of
this design comes into play. Only over time will we find out how well it works.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I188' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I189>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In
the example above, <A NAME="Index1041"></A><B>Arrays.asList(&#160;)</B> produces
a <B>List</B> that is backed by a fixed-size array. Therefore it makes sense
that the only supported operations are the ones that don&#8217;t change the size
of the array. If, on the other hand, a new <B>interface</B> were required to
express this different kind of behavior (called, perhaps,
&#8220;<B>FixedSizeList</B>&#8221;), it would throw open the door to complexity
and soon you wouldn&#8217;t know where to start when trying to use the library.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I189' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I190>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The documentation for a method that takes
a <B>Collection</B>, <B>List</B>, <B>Set</B>, or <B>Map</B> as an argument
should specify which of the optional methods must be implemented. For example,
sorting requires the <B>set(&#160;)</B> and <B>Iterator.set(&#160;) </B>methods,
but not <B>add(&#160;)</B> and <B>remove(&#160;)</B>. 

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I190' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I191>
</FONT><A NAME="_Toc481064706"></A><BR></P></DIV>
<A NAME="Heading324"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Java 1.0/1.1 containers</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unfortunately, a lot of code was written
using the Java 1.0/1.1 containers, and even new code is sometimes written using
these classes. So although you should never use the old containers when writing
new code, you&#8217;ll still need to be aware of them. However, the old
containers were quite limited, so there&#8217;s not that much to say about them.
(Since they are in the past, I will try to refrain from overemphasizing some of
the hideous design decisions.)

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I191' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I192>
</FONT><A NAME="_Toc375545355"></A><A NAME="_Toc481064707"></A><BR></P></DIV>
<A NAME="Heading325"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Vector &amp; Enumeration</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The only self-expanding sequence in Java
1.0/1.1 was the <A NAME="Index1042"></A><B>Vector</B>, and so it saw a lot of
use. Its flaws are too numerous to describe here (see the first edition of this
book, available on this book&#8217;s CD ROM and as a free download from
<I>www.BruceEckel.com</I>). Basically, you can think of it as an
<B>ArrayList</B> with long, awkward method names. In the Java 2 container
library, <B>Vector</B> was adapted so that it could fit as a <B>Collection
</B>and a <B>List</B>, so in the following example the
<B>Collections2.fill(&#160;)</B> method is successfully used. This turns out to
be a bit perverse, as it may confuse some people into thinking that
<B>Vector</B> has gotten better, when it is actually included only to support
pre-Java 2 code. 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I192' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I193>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java 1.0/1.1 version of the iterator
chose to invent a new name, &#8220;enumeration,&#8221; instead of using a term
that everyone was already familiar with. The
<A NAME="Index1043"></A><B>Enumeration</B> interface is smaller than
<B>Iterator</B>, with only two methods, and it uses longer method names:
<B>boolean</B> <B>hasMoreElements(&#160;)</B> produces <B>true</B> if this
enumeration contains more elements, and <B>Object nextElement(&#160;)
</B>returns the next element of this enumeration if there are any more
(otherwise it throws an exception).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I193' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I194>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>Enumeration</B> is only an interface,
not an implementation, and even new libraries sometimes still use the old
<B>Enumeration</B>&#8212;which is unfortunate but generally harmless. Even
though you should always use <B>Iterator</B> when you can in your own code, you
must be prepared for libraries that want to hand you an <B>Enumeration</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I194' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I195>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index1044"></A><FONT FACE="Georgia">In addition, you
can produce an <B>Enumeration</B> for any <B>Collection</B> by using the
<B>Collections.enumeration(&#160;)</B> method, as seen in this
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Enumerations.java</font>
<font color=#009900>// Java 1.0/1.1 Vector and Enumeration.</font>
<font color=#0000ff>import</font> java.util.*;
<font color=#0000ff>import</font> com.bruceeckel.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Enumerations {
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Vector v = <font color=#0000ff>new</font> Vector();
    Collections2.fill(
      v, Collections2.countries, 100);
    Enumeration e = v.elements();
    <font color=#0000ff>while</font>(e.hasMoreElements())
      System.out.println(e.nextElement());
    <font color=#009900>// Produce an Enumeration from a Collection:</font>
    e = Collections.enumeration(<font color=#0000ff>new</font> ArrayList());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Java 1.0/1.1 <B>Vector</B> has only
an <B>addElement(&#160;)</B> method, but <B>fill(&#160;)</B> uses the
<B>add(&#160;)</B> method that was pasted on as <B>Vector</B> was turned into a
<B>List</B>. To produce an <B>Enumeration</B>, you call <B>elements(&#160;)</B>,
then you can use it to perform a forward iteration.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I195' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I196>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The last line creates an <B>ArrayList</B>
and uses <B>enumeration(&#160;)</B> to adapt an <B>Enumeration</B> from the
<B>ArrayList</B> <B>Iterator</B>. Thus, if you have old code that wants an
<B>Enumeration</B>, you can still use the new containers.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I196' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I197>
</FONT><A NAME="_Toc481064708"></A><BR></P></DIV>
<A NAME="Heading326"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Hashtable</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As you&#8217;ve seen in the performance
comparison in this chapter, the basic <A NAME="Index1045"></A><B>Hashtable</B>
is very similar to the <B>HashMap</B>, even down to the method names.
There&#8217;s no reason to use <B>Hashtable</B> instead of <B>HashMap</B> in new
code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I197' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I198>
</FONT><A NAME="_Toc375545356"></A><A NAME="_Toc481064709"></A><BR></P></DIV>
<A NAME="Heading327"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Stack</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The concept of the stack was introduced
earlier, with the <B>LinkedList</B>.<B> </B>What&#8217;s rather odd about the
Java 1.0/1.1 <B>Stack </B>is that instead of using a
<A NAME="Index1046"></A><B>Vector</B> as a building block,
<A NAME="Index1047"></A><B>Stack </B>is <I>inherited</I> from <B>Vector</B>. So
it has all of the characteristics and behaviors of a <B>Vector</B> plus some
extra <B>Stack</B> behaviors. It&#8217;s difficult to know whether the designers
explicitly decided that this was an especially useful way of doing things, or
whether it was just a naive design.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I198' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I199>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple demonstration of
<B>Stack</B> that pushes each line from a <B>String</B> array:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Stacks.java</font>
<font color=#009900>// Demonstration of Stack Class.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Stacks {
  <font color=#0000ff>static</font> String[] months = { 
    <font color=#004488>"January"</font>, <font color=#004488>"February"</font>, <font color=#004488>"March"</font>, <font color=#004488>"April"</font>,
    <font color=#004488>"May"</font>, <font color=#004488>"June"</font>, <font color=#004488>"July"</font>, <font color=#004488>"August"</font>, <font color=#004488>"September"</font>,
    <font color=#004488>"October"</font>, <font color=#004488>"November"</font>, <font color=#004488>"December"</font> };
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Stack stk = <font color=#0000ff>new</font> Stack();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; months.length; i++)
      stk.push(months[i] + <font color=#004488>" "</font>);
    System.out.println(<font color=#004488>"stk = "</font> + stk);
    <font color=#009900>// Treating a stack as a Vector:</font>
    stk.addElement(<font color=#004488>"The last line"</font>);
    System.out.println(
      <font color=#004488>"element 5 = "</font> + stk.elementAt(5));
    System.out.println(<font color=#004488>"popping elements:"</font>);
    <font color=#0000ff>while</font>(!stk.empty())
      System.out.println(stk.pop());
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each line in the <B>months </B>array is
inserted into the <B>Stack</B> with <B>push(&#160;)</B>, and later fetched from
the top of the stack with a <B>pop(&#160;)</B>. To make a point, <B>Vector
</B>operations are also performed on the <B>Stack</B> object. This is possible
because, by virtue of inheritance, a <B>Stack</B> <I>is</I> a <B>Vector</B>.
Thus, all operations that can be performed on a <B>Vector</B> can also be
performed on a <B>Stack</B>, such as <B>elementAt(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I199' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I200>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned earlier, you should use a
<B>LinkedList</B> when you want stack behavior.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I200' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I201>
</FONT><A NAME="_Toc481064710"></A><BR></P></DIV>
<A NAME="Heading328"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
BitSet</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <A NAME="Index1048"></A><B>BitSet</B>
is used if you want to efficiently store a lot of on-off information. It&#8217;s
efficient only from the standpoint of size; if you&#8217;re looking for
efficient access, it is slightly slower than using an array of some native type.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I201' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I202>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, the minimum size of the
<B>BitSet</B> is that of a <B>long</B>: 64 bits. This implies that if
you&#8217;re storing anything smaller, like 8 bits, a <B>BitSet</B> will be
wasteful; you&#8217;re better off creating your own class, or just an array, to
hold your flags if size is an issue.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I202' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I203>
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A normal container expands as you add
more elements, and the <B>BitSet</B> does this as well. The following example
shows how the <B>BitSet </B>works:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: c09:Bits.java</font>
<font color=#009900>// Demonstration of BitSet.</font>
<font color=#0000ff>import</font> java.util.*;

<font color=#0000ff>public</font> <font color=#0000ff>class</font> Bits {
  <font color=#0000ff>static</font> <font color=#0000ff>void</font> printBitSet(BitSet b) {
    System.out.println(<font color=#004488>"bits: "</font> + b);
    String bbits = <font color=#0000ff>new</font> String();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 0; j &lt; b.size() ; j++)
      bbits += (b.get(j) ? <font color=#004488>"1"</font> : <font color=#004488>"0"</font>);
    System.out.println(<font color=#004488>"bit pattern: "</font> + bbits);
  }
  <font color=#0000ff>public</font> <font color=#0000ff>static</font> <font color=#0000ff>void</font> main(String[] args) {
    Random rand = <font color=#0000ff>new</font> Random();
    <font color=#009900>// Take the LSB of nextInt():</font>
    <font color=#0000ff>byte</font> bt = (<font color=#0000ff>byte</font>)rand.nextInt();
    BitSet bb = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 7; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  bt) != 0)
        bb.set(i);
      <font color=#0000ff>else</font>
        bb.clear(i);
    System.out.println(<font color=#004488>"byte value: "</font> + bt);
    printBitSet(bb);

    <font color=#0000ff>short</font> st = (<font color=#0000ff>short</font>)rand.nextInt();
    BitSet bs = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 15; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  st) != 0)
        bs.set(i);
      <font color=#0000ff>else</font>
        bs.clear(i);
    System.out.println(<font color=#004488>"short value: "</font> + st);
    printBitSet(bs);

    <font color=#0000ff>int</font> it = rand.nextInt();
    BitSet bi = <font color=#0000ff>new</font> BitSet();
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 31; i &gt;=0; i--)
      <font color=#0000ff>if</font>(((1 &lt;&lt; i) &amp;  it) != 0)
        bi.set(i);
      <font color=#0000ff>else</font>
        bi.clear(i);
    System.out.println(<font color=#004488>"int value: "</font> + it);
    printBitSet(bi);

    <font color=#009900>// Test bitsets &gt;= 64 bits:</font>
    BitSet b127 = <font color=#0000ff>new</font> BitSet();
    b127.set(127);
    System.out.println(<font color=#004488>"set bit 127: "</font> + b127);
    BitSet b255 = <font color=#0000ff>new</font> BitSet(65);
    b255.set(255);
    System.out.println(<font color=#004488>"set bit 255: "</font> + b255);
    BitSet b1023 = <font color=#0000ff>new</font> BitSet(512);
    b1023.set(1023);
    b1023.set(1024);
    System.out.println(<font color=#004488>"set bit 1023: "</font> + b1023);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The random number generator is used to
create a random <B>byte</B>, <B>short</B>, and <B>int</B>, and each one is
transformed into a corresponding bit pattern in a <B>BitSet</B>. This works fine
because a <B>BitSet</B> is 64 bits, so none of these cause it to increase in
size. Then a <B>BitSet</B> of 512 bits is created. The constructor allocates
storage for twice that number of bits. However, you can still set bit 1024 or
greater.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I203' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I204>
</FONT><A NAME="_Toc481064711"></A><BR></P></DIV>
<A NAME="Heading329"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To review the containers provided in the
standard Java library: 
</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I204' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I205>
</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">An array associates
numerical indices to objects. It holds objects of a known type so that you
don&#8217;t have to cast the result when you&#8217;re looking up an object. It
can be multidimensional, and it can hold primitives. However, its size cannot be
changed once you create it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I205' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I206>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
<B>Collection</B> holds single elements, while a <B>Map</B> holds associated
pairs.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I206' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I207>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Like
an array, a <B>List</B> also associates numerical indices to objects&#8212;you
can think of arrays and <B>List</B>s as ordered containers. The <B>List</B>
automatically resizes itself as you add more elements. But a <B>List</B> can
hold only <B>Object reference</B>s, so it won&#8217;t hold primitives and you
must always cast the result when you pull an <B>Object </B>reference out of a
container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I207' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I208>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Use
an <B>ArrayList</B> if you&#8217;re doing a lot of random accesses, and a
<B>LinkedList</B> if you will be doing a lot of insertions and removals in the
middle of the list.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I208' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I209>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">The
behavior of queues, deques, and stacks is provided via the <B>LinkedList</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I209' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I210>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
<B>Map</B> is a way to associate not numbers, but <I>objects</I> with other
objects. The design of a <B>HashMap</B> is focused on rapid access, while a
<B>TreeMap</B> keeps its keys in sorted order, and thus is not as fast as a
<B>HashMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I210' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I211>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">A
<B>Set</B> only accepts one of each type of object. <B>HashSet</B>s provide
maximally fast lookups, while <B>TreeSet</B>s keep the elements in sorted order.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I211' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I212>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">There&#8217;s
no need to use the legacy classes <B>Vector</B>, <B>Hashtable</B> and
<B>Stack</B> in new code.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I212' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I213>
</FONT></OL><DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
containers are tools that you can use on a day-to-day basis to make your
programs simpler, more powerful, and more effective.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I213' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I214>
</FONT><A NAME="_Toc375545360"></A><A NAME="_Toc481064712"></A><BR></P></DIV>
<A NAME="Heading330"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=2>Solutions to selected exercises
can be found in the electronic document <I>The Thinking in Java Annotated
Solution Guide</I>, available for a small fee from
<I>www.BruceEckel.com</I>.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create an array of
<B>double</B> and <B>fill(&#160;)</B> it using <B>RandDoubleGenerator</B>. Print
the results.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I214' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I215>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a new class called <B>Gerbil</B> with an <B>int gerbilNumber </B>that&#8217;s
initialized in the constructor (similar to the <B>Mouse </B>example in this
chapter). Give it a method called <B>hop(&#160;)</B> that prints out which
gerbil number this is, and that it&#8217;s hopping. Create an <B>ArrayList</B>
and add a bunch of <B>Gerbil</B> objects to the <B>List</B>. Now use the
<B>get(&#160;)</B> method to move through the <B>List</B> and call
<B>hop(&#160;)</B> for each <B>Gerbil</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I215' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I216>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 2 so you use an <B>Iterator</B> to move through the <B>List</B> while
calling <B>hop(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I216' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I217>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Take
the <B>Gerbil</B> class in Exercise 2 and put it into a <B>Map</B> instead,
associating the name of the <B>Gerbil</B> as a <B>String</B> (the key) for each
<B>Gerbil </B>(the value) you put in the table. Get an <B>Iterator</B> for the
<B>keySet(&#160;)</B> and use it to move through the <B>Map</B>, looking up the
<B>Gerbil</B> for each key and printing out the key and telling the
<B>gerbil</B> to <B>hop(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I217' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I218>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a <B>List</B> (try both <B>ArrayList </B>and <B>LinkedList</B>)<B> </B>and fill
it using <B>Collections2.countries</B>. Sort the list and print it, then apply
<B>Collections.shuffle(&#160;)</B> to the list repeatedly, printing it each time
so that you can see how the <B>shuffle(&#160;)</B> method randomizes the list
differently each time.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I218' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I219>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Demonstrate
that you can&#8217;t add anything but a <B>Mouse</B> to a <B>MouseList</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I219' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I220>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>MouseList.java</B> so that it inherits from <B>ArrayList</B> instead of using
composition. Demonstrate the problem with this approach.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I220' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I221>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Repair
<B>CatsAndDogs.java</B> by creating a <B>Cats</B> container (utilizing
<B>ArrayList</B>)<B> </B>that will only accept and retrieve <B>Cat</B> objects.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I221' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I222>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a container that encapsulates an array of <B>String</B>, and that only adds
<B>String</B>s and gets <B>String</B>s, so that there are no casting issues
during use. If the internal array isn&#8217;t big enough for the next add, your
container should automatically resize it. In <B>main(&#160;)</B>, compare the
performance of your container with an <B>ArrayList</B> holding <B>String</B>s.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I222' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I223>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Repeat
Exercise 9 for a container of <B>int</B>, and compare the performance to an
<B>ArrayList</B> holding <B>Integer</B> objects. In your performance comparison,
include the process of incrementing each object in the container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I223' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I224>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
the utilities in <B>com.bruceeckel.util</B>, create an array of each primitive
type and of <B>String</B>, then fill each array using an appropriate generator,
and print each array using the appropriate <B>print(&#160;)</B> method.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I224' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I225>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a generator that produces character names from your favorite movies (you can use
<I>Snow White</I> or <I>Star Wars </I>as a fallback), and loops around to the
beginning when it runs out of names. Use the utilities in
<B>com.bruceeckel.util</B> to fill an array, an <B>ArrayList</B>, a
<B>LinkedList</B> and both types of <B>Set</B>, then print each container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I225' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I226>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a class containing two <B>String</B> objects, and make it <B>Comparable</B> so
that the comparison only cares about the first <B>String</B>. Fill an array and
an <B>ArrayList </B>with objects of your class, using the <B>geography
</B>generator. Demonstrate that sorting works properly. Now make a
<B>Comparator</B> that only cares about the second <B>String</B> and demonstrate
that sorting works properly; also perform a binary search using your
<B>Comparator</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I226' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I227>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
Exercise 13 so that an alphabetic sort is used.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I227' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I228>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Use
<B>Arrays2.RandStringGenerator</B> to fill a <B>TreeSet</B> but using alphabetic
ordering. Print the <B>TreeSet</B> to verify the sort order.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I228' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I229>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
both an <B>ArrayList</B> and a <B>LinkedList</B>, and fill each using the
<B>Collections2.capitals</B> generator. Print each list using an ordinary
<B>Iterator</B>, then insert one list into the other using a
<B>ListIterator</B>, inserting at every other location. Now perform the
insertion starting at the end of the first list and moving backward.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I229' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I230>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a method that uses an <B>Iterator</B> to step through a <B>Collection</B> and
print the <B>hashCode(&#160;)</B> of each object in the container. Fill all the
different types of <B>Collection</B>s with objects and apply your method to each
container.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I230' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I231>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Repair
the problem in <B>InfiniteRecursion.java</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I231' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I232>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a class, then make an initialized array of objects of your class. Fill a
<B>List</B> from your array. Create a subset of your <B>List</B> using
<B>subList(&#160;)</B>, and then remove this subset from your <B>List</B> using
<B>removeAll(&#160;)</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I232' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I233>
</FONT><A NAME="B"></A><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Change
Exercise 6 in Chapter 7 to use an <B>ArrayList</B> to hold the <B>Rodent</B>s
and an <B>Iterator</B> to move through the sequence of <B>Rodent</B>s. Remember
that an <B>ArrayList</B> holds only <B>Object</B>s so you must use a cast when
accessing individual <B>Rodent</B>s.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I233' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I234>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Following
the <B>Queue.java</B> example, create a <B>Deque</B> class and test it.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I234' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I235>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Use
a <B>TreeMap</B> in <B>Statistics.java</B>. Now add code that tests the
performance difference between <B>HashMap</B> and <B>TreeMap</B> in that
program.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I235' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I236>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Produce
a <B>Map</B> and a <B>Set </B>containing all the countries that begin with
&#8216;A.&#8217;

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I236' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I237>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
<B>Collections2.countries</B>, fill a <B>Set</B> multiple times with the same
data and verify that the <B>Set</B> ends up with only one of each instance. Try
this with both kinds of <B>Set</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I237' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I238>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Starting
with <B>Statistics.java</B>, create a program that runs the test repeatedly and
looks to see if any one number tends to appear more than the others in the
results.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I238' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I239>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Rewrite
<B>Statistics.java</B> using a <B>HashSet</B> of <B>Counter</B> objects
(you&#8217;ll have to modify <B>Counter</B> so that it will work in the
<B>HashSet</B>). Which approach seems better?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I239' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I240>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
the class in Exercise 13 so that it will work with <B>HashSet</B>s and as a key
in <B>HashMap</B>s.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I240' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I241>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
<B>SlowMap.java</B> for inspiration, create a <B>SlowSet</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I241' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I242>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Apply
the tests in <B>Map1.java</B> to <B>SlowMap</B> to verify that it works. Fix
anything in <B>SlowMap </B>that doesn&#8217;t work correctly.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I242' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I243>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Implement
the rest of the <B>Map</B> interface for <B>SlowMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I243' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I244>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>MapPerformance.java</B> to include tests of <B>SlowMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I244' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I245>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>SlowMap</B> so that instead of two <B>ArrayList</B>s, it holds a single
<B>ArrayList</B> of <B>MPair</B> objects. Verify that the modified version works
correctly. Using <B>MapPerformance.java</B>, test the speed of your new
<B>Map</B>. Now change the <B>put(&#160;)</B> method so that it performs a
<B>sort(&#160;)</B> after each pair is entered, and modify <B>get(&#160;)</B> to
use <B>Collections.binarySearch(&#160;)</B> to look up the key. Compare the
performance of the new version with the old ones.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I245' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I246>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add
a <B>char</B> field to <B>CountedString</B> that is also initialized in the
constructor, and modify the <B>hashCode(&#160;)</B> and <B>equals(&#160;)</B>
methods to include the value of this <B>char</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I246' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I247>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>SimpleHashMap</B> so that it reports collisions, and test this by adding the
same data set twice so that you see collisions.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I247' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I248>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>SimpleHashMap</B> so that it reports the number of &#8220;probes&#8221;
necessary when collisions occur. That is, how many calls to <B>next(&#160;)</B>
must be made on the <B>Iterator</B>s that walk the <B>LinkedList</B>s looking
for matches?

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I248' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I249>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Implement
the <B>clear(&#160;)</B> and <B>remove(&#160;)</B> methods for
<B>SimpleHashMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I249' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I250>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Implement
the rest of the <B>Map</B> interface for <B>SimpleHashMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I250' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I251>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Add
a <B>private</B> <B>rehash(&#160;)</B> method to <B>SimpleHashMap</B> that is
invoked when the load factor exceeds 0.75. During rehashing, double the number
of buckets, then search for the first prime number greater than that to
determine the new number of buckets.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I251' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I252>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Following
the example in <B>SimpleHashMap.java</B>, create and test a
<B>SimpleHashSet</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I252' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I253>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>SimpleHashMap</B> to use <B>ArrayList</B>s instead of <B>LinkedList</B>s.
Modify <B>MapPerformance.java</B> to compare the performance of the two
implementations.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I253' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I254>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Using
the HTML documentation for the JDK (downloadable from <I>java.sun.com</I>), look
up the <B>HashMap</B> class. Create a <B>HashMap</B>, fill it with elements, and
determine the load factor. Test the lookup speed with this map, then attempt to
increase the speed by making a new <B>HashMap</B> with a larger initial capacity
and copying the old map into the new one, running your lookup speed test again
on the new map.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I254' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I255>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">In
Chapter 8, locate the <B>GreenhouseControls.java</B> example, which consists of
three files. In <B>Controller.java</B>, the class <B>EventSet</B> is just a
container. Change the code to use a <B>LinkedList</B> instead of an
<B>EventSet</B>. This will require more than just replacing <B>EventSet</B> with
<B>LinkedList</B>; you&#8217;ll also need to use an <B>Iterator</B> to cycle
through the set of events.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I255' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I256>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">(Challenging).
Write your own hashed map class, customized for a particular key type: <B>String
</B>for this example. Do not inherit it from <B>Map</B>. Instead, duplicate the
methods so that the <B>put(&#160;)</B> and <B>get(&#160;)</B> methods
specifically take <B>String</B> objects, not <B>Object</B>s, as keys. Everything
that involves keys should not use generic types, but instead work with
<B>String</B>s, to avoid the cost of upcasting and downcasting. Your goal is to
make the fastest possible custom implementation. Modify
<B>MapPerformance.java</B> to test your implementation vs. a <B>HashMap</B>.

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I256' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I257>
</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">(Challenging).
Find the source code for <B>List</B> in the Java source code library that comes
with all Java distributions. Copy this code and make a special version called
<B>intList</B> that holds only <B>int</B>s. Consider what it would take to make
a special version of <B>List</B> for all the primitive types. Now consider what
happens if you want to make a linked list class that works with all the
primitive types. If parameterized types are ever implemented in Java, they will
provide a way to do this work for you automatically (as well as many other
benefits).

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I257' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I258>
</FONT><LI><FONT FACE="Verdana"><U>	</U></FONT><FONT FACE="Georgia"><U>Modify
<B>c08:Month2.java</B> to make it implement the <B>Comparable</B> interface.</U>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I258' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

<backtalk:display ID=TIJ3_CHAPTER9_I259>
</FONT><LI><FONT FACE="Verdana"><U>	</U></FONT><FONT FACE="Georgia"><U>Modify
the <B>hashCode( )</B> in <B>CountedString.java</B> by removing the
multiplication by <B>id</B>, and demonstrate that <B>CountedString</B> still
works as a key. What is the problem with this approach?</U>

</backtalk:display>
[&nbsp;<a href='http://www.mindview.net/backtalk/CommentServlet?ID=TIJ3_CHAPTER9_I259' 
  target="_blank">Add&nbsp;Comment</a>&nbsp;]

</FONT></OL>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn44" HREF="#fnB44">[44]</A><FONT FACE="Georgia" SIZE=2>
It&#8217;s possible, however, to ask how big the <B>vector</B> is, and the
<B>at(&#160;)</B> method <I>does</I> perform bounds checking.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn45" HREF="#fnB45">[45]</A><FONT FACE="Georgia" SIZE=2>
This is one of the places where C++ is distinctly superior to Java, since C++
supports <I>parameterized types</I> with the <B>template</B>
keyword.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn46" HREF="#fnB46">[46]</A><FONT FACE="Georgia" SIZE=2>
The C++ programmer will note how much the code could be collapsed with the use
of default arguments and templates. The Python programmer will note that this
entire library would be largely unnecessary in that language.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn47" HREF="#fnB47">[47]</A><FONT FACE="Georgia" SIZE=2>
By Joshua Bloch at Sun.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn48" HREF="#fnB48">[48]</A><FONT FACE="Georgia" SIZE=2>
This data was found on the Internet, then processed by creating a Python program
(see <I>www.Python.org</I>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn49" HREF="#fnB49">[49]</A><FONT FACE="Georgia" SIZE=2>
This is a place where operator overloading would be nice.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn50" HREF="#fnB50">[50]</A><FONT FACE="Georgia" SIZE=2>
If these speedups still don&#8217;t meet your performance needs, you can further
accelerate table lookup by writing your own <B>Map</B> and customizing it to
your particular types to avoid delays due to casting to and from <B>Object</B>s.
To reach even higher levels of performance, speed enthusiasts can use Donald
Knuth&#8217;s <I>The Art of Computer Programming, Volume 3: Sorting and
Searching, Second Edition</I> to replace overflow bucket lists with arrays that
have two additional benefits: they can be optimized for disk storage
characteristics and they can save most of the time of creating and garbage
collecting individual records.</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chap08.htm">Previous Chapter</a> ] 
    [ <a href="SimpCont.htm">Short TOC</a> ] 
    [ <a href="Contents.htm">Table of Contents</a> ] 
    [ <a href="DocIdx.htm">Index</a> ]
     [ <a href="Chap10.htm">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:05/21/2001</P></DIV>

</BODY>

</HTML>
